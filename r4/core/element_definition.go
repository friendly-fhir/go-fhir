// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.
package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Base StructureDefinition for ElementDefinition Type: Captures constraints on
// each element within the resource, profile, or extension.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/ElementDefinition
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinition struct {

	// Identifies additional names by which this element might also be known.
	Alias []*String `json:"alias"`

	// Information about the base definition of the element, provided to make it
	// unnecessary for tools to trace the deviation of the element through the
	// derived and related profiles. When the element definition is not the
	// original definition of an element - i.g. either in a constraint on another
	// type, or for elements from a super type in a snap shot - then the
	// information in provided in the element definition may be different to the
	// base definition. On the original definition of the element, it will be same.
	Base Element `json:"base"`

	// Binds to a value set if this element is coded (code, Coding,
	// CodeableConcept, Quantity), or the data types (string, uri).
	Binding Element `json:"binding"`

	// A code that has the same meaning as the element in a particular terminology.
	Code []*Coding `json:"code"`

	// Explanatory notes and implementation guidance about the data element,
	// including notes about how to use the data properly, exceptions to proper
	// use, etc. (Note: The text you are reading is specified in
	// ElementDefinition.comment).
	Comment *Markdown `json:"comment"`

	// A reference to an invariant that may make additional statements about the
	// cardinality or value in the instance.
	Condition []*Id `json:"condition"`

	// Formal constraints such as co-occurrence and other constraints that can be
	// computationally evaluated within the context of the instance.
	Constraint []Element `json:"constraint"`

	// Identifies an element defined elsewhere in the definition whose content
	// rules should be applied to the current element. ContentReferences bring
	// across all the rules that are in the ElementDefinition for the element,
	// including definitions, cardinality constraints, bindings, invariants etc.
	ContentReference *Uri `json:"contentReference"`

	// The value that should be used if there is no value stated in the instance
	// (e.g. 'if not otherwise specified, the abstract is false').
	DefaultValue Element `json:"defaultValue"`

	// Provides a complete explanation of the meaning of the data element for human
	// readability. For the case of elements derived from existing elements (e.g.
	// constraints), the definition SHALL be consistent with the base definition,
	// but convey the meaning of the element in the particular context of use of
	// the resource. (Note: The text you are reading is specified in
	// ElementDefinition.definition).
	Definition *Markdown `json:"definition"`

	// A sample value for this element demonstrating the type of information that
	// would typically be found in the element.
	Example []Element `json:"example"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Specifies a value that SHALL be exactly the value for this element in the
	// instance. For purposes of comparison, non-significant whitespace is ignored,
	// and all values must be an exact match (case and accent sensitive). Missing
	// elements/attributes must also be missing.
	Fixed Element `json:"fixed"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// If true, the value of this element affects the interpretation of the element
	// or resource that contains it, and the value of the element cannot be
	// ignored. Typically, this is used for status, negation and qualification
	// codes. The effect of this is that the element cannot be ignored by systems:
	// they SHALL either recognize the element and process it, and/or a
	// pre-determination has been made that it is not relevant to their particular
	// system.
	IsModifier *Boolean `json:"isModifier"`

	// Explains how that element affects the interpretation of the resource or
	// element that contains it.
	IsModifierReason *String `json:"isModifierReason"`

	// Whether the element should be included if a client requests a search with
	// the parameter _summary=true.
	IsSummary *Boolean `json:"isSummary"`

	// A single preferred label which is the text to display beside the element
	// indicating its meaning or to use to prompt for the element in a user display
	// or form.
	Label *String `json:"label"`

	// Identifies a concept from an external specification that roughly corresponds
	// to this element.
	Mapping []Element `json:"mapping"`

	// The maximum number of times this element is permitted to appear in the
	// instance.
	Max *String `json:"max"`

	// Indicates the maximum length in characters that is permitted to be present
	// in conformant instances and which is expected to be supported by conformant
	// consumers that support the element.
	MaxLength *Integer `json:"maxLength"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValue Element `json:"maxValue"`

	// The Implicit meaning that is to be understood when this element is missing
	// (e.g. 'when this element is missing, the period is ongoing').
	MeaningWhenMissing *Markdown `json:"meaningWhenMissing"`

	// The minimum number of times this element SHALL appear in the instance.
	Min *UnsignedInt `json:"min"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValue Element `json:"minValue"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*Extension `json:"modifierExtension"`

	// If true, implementations that produce or consume resources SHALL provide
	// "support" for the element in some meaningful way. If false, the element may
	// be ignored and not supported. If false, whether to populate or use the data
	// element in any way is at the discretion of the implementation.
	MustSupport *Boolean `json:"mustSupport"`

	// If present, indicates that the order of the repeating element has meaning
	// and describes what that meaning is. If absent, it means that the order of
	// the element has no meaning.
	OrderMeaning *String `json:"orderMeaning"`

	// The path identifies the element and is expressed as a "."-separated list of
	// ancestor elements, beginning with the name of the resource or extension.
	Path *String `json:"path"`

	// Specifies a value that the value in the instance SHALL follow - that is, any
	// value in the pattern must be found in the instance. Other additional values
	// may be found too. This is effectively constraint by example.
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	// When pattern[x] is used to constrain an array, it means that each element
	// provided in the pattern[x] array must (recursively) match at least one
	// element from the instance array.
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	// 1. If primitive: it must match exactly the pattern value 2. If a complex
	// object: it must match (recursively) the pattern value 3. If an array: it
	// must match (recursively) the pattern value.
	Pattern Element `json:"pattern"`

	// Codes that define how this element is represented in instances, when the
	// deviation varies from the normal case.
	Representation []*Code `json:"representation"`

	// This element is for traceability of why the element was created and why the
	// constraints exist as they do. This may be used to point to source materials
	// or specifications that drove the structure of this element.
	Requirements *Markdown `json:"requirements"`

	// A concise description of what this element means (e.g. for use in
	// autogenerated summaries).
	Short *String `json:"short"`

	// If true, indicates that this slice definition is constraining a slice
	// definition with the same name in an inherited profile. If false, the slice
	// is not overriding any slice in an inherited profile. If missing, the slice
	// might or might not be overriding a slice in an inherited profile, depending
	// on the sliceName.
	SliceIsConstraining *Boolean `json:"sliceIsConstraining"`

	// The name of this element definition slice, when slicing is working. The name
	// must be a token with no dots or spaces. This is a unique name referring to a
	// specific set of constraints applied to this element, used to provide a name
	// to different slices of the same element.
	SliceName *String `json:"sliceName"`

	// Indicates that the element is sliced into a set of alternative definitions
	// (i.e. in a structure definition, there are multiple different constraints on
	// a single element in the base resource). Slicing can be used in any resource
	// that has cardinality ..* on the base resource, or any resource with a choice
	// of types. The set of slices is any elements that come after this in the
	// element sequence that have the same path, until a shorter path occurs (the
	// shorter path terminates the set).
	Slicing Element `json:"slicing"`

	// The data type or resource that the value of this element is permitted to be.
	Type []Element `json:"type"`

	isElementDefinition profileimpl.BaseElementDefinition
	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

func (v *ElementDefinition) GetDefaultValueBase64Binary() *Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueBoolean() *Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCanonical() *Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCode() *Code {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueId() *Id {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMarkdown() *Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueOid() *Oid {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValuePositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueString() *String {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUri() *Uri {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUrl() *Url {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUuid() *Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAddress() *Address {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAge() *Age {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAnnotation() *Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAttachment() *Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCodeableConcept() *CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCoding() *Coding {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContactPoint() *ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCount() *Count {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDistance() *Distance {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDuration() *Duration {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueHumanName() *HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueIdentifier() *Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMoney() *Money {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValuePeriod() *Period {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRange() *Range {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRatio() *Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueReference() *Reference {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueSampledData() *SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueSignature() *Signature {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTiming() *Timing {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContactDetail() *ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContributor() *Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDataRequirement() *DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueExpression() *Expression {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueParameterDefinition() *ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRelatedArtifact() *RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTriggerDefinition() *TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUsageContext() *UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDosage() *Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMeta() *Meta {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*Meta)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedBase64Binary() *Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedBoolean() *Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCanonical() *Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCode() *Code {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedId() *Id {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMarkdown() *Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedOid() *Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedPositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedString() *String {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUri() *Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUrl() *Url {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUuid() *Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAddress() *Address {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAge() *Age {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAnnotation() *Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAttachment() *Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCodeableConcept() *CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCoding() *Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContactPoint() *ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCount() *Count {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDistance() *Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDuration() *Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedHumanName() *HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedIdentifier() *Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMoney() *Money {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedPeriod() *Period {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRange() *Range {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRatio() *Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedReference() *Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedSampledData() *SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedSignature() *Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTiming() *Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContactDetail() *ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContributor() *Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDataRequirement() *DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedExpression() *Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedParameterDefinition() *ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRelatedArtifact() *RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTriggerDefinition() *TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUsageContext() *UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDosage() *Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMeta() *Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*Meta)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValuePositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValuePositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternBase64Binary() *Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternBoolean() *Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCanonical() *Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCode() *Code {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternId() *Id {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMarkdown() *Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternOid() *Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternPositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternString() *String {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUri() *Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUrl() *Url {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUuid() *Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAddress() *Address {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAge() *Age {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAnnotation() *Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAttachment() *Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCodeableConcept() *CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCoding() *Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContactPoint() *ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCount() *Count {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDistance() *Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDuration() *Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternHumanName() *HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternIdentifier() *Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMoney() *Money {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternPeriod() *Period {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRange() *Range {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRatio() *Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternReference() *Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternSampledData() *SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternSignature() *Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTiming() *Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContactDetail() *ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContributor() *Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDataRequirement() *DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternExpression() *Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternParameterDefinition() *ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRelatedArtifact() *RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTriggerDefinition() *TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUsageContext() *UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDosage() *Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMeta() *Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*Meta)
	if ok {
		return result
	}
	return nil
}
func (e *ElementDefinition) GetAlias() []*String {
	if e == nil {
		return nil
	}
	return e.Alias
}

func (e *ElementDefinition) GetBase() Element {
	if e == nil {
		return nil
	}
	return e.Base
}

func (e *ElementDefinition) GetBinding() Element {
	if e == nil {
		return nil
	}
	return e.Binding
}

func (e *ElementDefinition) GetCode() []*Coding {
	if e == nil {
		return nil
	}
	return e.Code
}

func (e *ElementDefinition) GetComment() *Markdown {
	if e == nil {
		return nil
	}
	return e.Comment
}

func (e *ElementDefinition) GetCondition() []*Id {
	if e == nil {
		return nil
	}
	return e.Condition
}

func (e *ElementDefinition) GetConstraint() []Element {
	if e == nil {
		return nil
	}
	return e.Constraint
}

func (e *ElementDefinition) GetContentReference() *Uri {
	if e == nil {
		return nil
	}
	return e.ContentReference
}

func (e *ElementDefinition) GetDefaultValue() Element {
	if e == nil {
		return nil
	}
	return e.DefaultValue
}

func (e *ElementDefinition) GetDefinition() *Markdown {
	if e == nil {
		return nil
	}
	return e.Definition
}

func (e *ElementDefinition) GetExample() []Element {
	if e == nil {
		return nil
	}
	return e.Example
}

func (e *ElementDefinition) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinition) GetFixed() Element {
	if e == nil {
		return nil
	}
	return e.Fixed
}

func (e *ElementDefinition) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinition) GetIsModifier() *Boolean {
	if e == nil {
		return nil
	}
	return e.IsModifier
}

func (e *ElementDefinition) GetIsModifierReason() *String {
	if e == nil {
		return nil
	}
	return e.IsModifierReason
}

func (e *ElementDefinition) GetIsSummary() *Boolean {
	if e == nil {
		return nil
	}
	return e.IsSummary
}

func (e *ElementDefinition) GetLabel() *String {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *ElementDefinition) GetMapping() []Element {
	if e == nil {
		return nil
	}
	return e.Mapping
}

func (e *ElementDefinition) GetMax() *String {
	if e == nil {
		return nil
	}
	return e.Max
}

func (e *ElementDefinition) GetMaxLength() *Integer {
	if e == nil {
		return nil
	}
	return e.MaxLength
}

func (e *ElementDefinition) GetMaxValue() Element {
	if e == nil {
		return nil
	}
	return e.MaxValue
}

func (e *ElementDefinition) GetMeaningWhenMissing() *Markdown {
	if e == nil {
		return nil
	}
	return e.MeaningWhenMissing
}

func (e *ElementDefinition) GetMin() *UnsignedInt {
	if e == nil {
		return nil
	}
	return e.Min
}

func (e *ElementDefinition) GetMinValue() Element {
	if e == nil {
		return nil
	}
	return e.MinValue
}

func (e *ElementDefinition) GetModifierExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.ModifierExtension
}

func (e *ElementDefinition) GetMustSupport() *Boolean {
	if e == nil {
		return nil
	}
	return e.MustSupport
}

func (e *ElementDefinition) GetOrderMeaning() *String {
	if e == nil {
		return nil
	}
	return e.OrderMeaning
}

func (e *ElementDefinition) GetPath() *String {
	if e == nil {
		return nil
	}
	return e.Path
}

func (e *ElementDefinition) GetPattern() Element {
	if e == nil {
		return nil
	}
	return e.Pattern
}

func (e *ElementDefinition) GetRepresentation() []*Code {
	if e == nil {
		return nil
	}
	return e.Representation
}

func (e *ElementDefinition) GetRequirements() *Markdown {
	if e == nil {
		return nil
	}
	return e.Requirements
}

func (e *ElementDefinition) GetShort() *String {
	if e == nil {
		return nil
	}
	return e.Short
}

func (e *ElementDefinition) GetSliceIsConstraining() *Boolean {
	if e == nil {
		return nil
	}
	return e.SliceIsConstraining
}

func (e *ElementDefinition) GetSliceName() *String {
	if e == nil {
		return nil
	}
	return e.SliceName
}

func (e *ElementDefinition) GetSlicing() Element {
	if e == nil {
		return nil
	}
	return e.Slicing
}

func (e *ElementDefinition) GetType() []Element {
	if e == nil {
		return nil
	}
	return e.Type
}

// Base definition information for tools// Information about the base definition of the element, provided to make it
// unnecessary for tools to trace the deviation of the element through the
// derived and related profiles. When the element definition is not the
// original definition of an element - i.g. either in a constraint on another
// type, or for elements from a super type in a snap shot - then the
// information in provided in the element definition may be different to the
// base definition. On the original definition of the element, it will be same.// The base information does not carry any information that could not be
// determined from the path and related profiles, but making this determination
// requires both that the related profiles are available, and that the
// algorithm to determine them be available. For tooling simplicity, the base
// information must always be populated in element definitions in snap shots,
// even if it is the same.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBase struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Maximum cardinality of the base element identified by the path.
	Max *String `json:"max"`

	// Minimum cardinality of the base element identified by the path.
	Min *UnsignedInt `json:"min"`

	// The Path that identifies the base element - this matches the
	// ElementDefinition.path for that element. Across FHIR, there is only one base
	// definition of any element - that is, an element definition on a
	// [StructureDefinition](structuredefinition.html#) without a
	// StructureDefinition.base.
	Path *String `json:"path"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionBase) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionBase) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionBase) GetMax() *String {
	if e == nil {
		return nil
	}
	return e.Max
}

func (e *ElementDefinitionBase) GetMin() *UnsignedInt {
	if e == nil {
		return nil
	}
	return e.Min
}

func (e *ElementDefinitionBase) GetPath() *String {
	if e == nil {
		return nil
	}
	return e.Path
}

// ValueSet details if this is coded// Binds to a value set if this element is coded (code, Coding,
// CodeableConcept, Quantity), or the data types (string, uri).// For a CodeableConcept, when no codes are allowed - only text, use a binding
// of strength "required" with a description explaining that no coded values
// are allowed and what sort of information to put in the "text" element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBinding struct {

	// Describes the intended use of this particular set of codes.
	Description *String `json:"description"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Indicates the degree of conformance expectations associated with this
	// binding - that is, the degree to which the provided value set must be
	// adhered to in the instances.
	Strength *Code `json:"strength"`

	// Refers to the value set that identifies the set of codes the binding refers
	// to.
	ValueSet *Canonical `json:"valueSet"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionBinding) GetDescription() *String {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *ElementDefinitionBinding) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionBinding) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionBinding) GetStrength() *Code {
	if e == nil {
		return nil
	}
	return e.Strength
}

func (e *ElementDefinitionBinding) GetValueSet() *Canonical {
	if e == nil {
		return nil
	}
	return e.ValueSet
}

// Condition that must evaluate to true// Formal constraints such as co-occurrence and other constraints that can be
// computationally evaluated within the context of the instance.// Constraints should be declared on the "context" element - the lowest element
// in the hierarchy that is common to all nodes referenced by the constraint.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionConstraint struct {

	// A [FHIRPath](fhirpath.html) expression of constraint that can be executed to
	// see if this constraint is met.
	Expression *String `json:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Text that can be used to describe the constraint in messages identifying
	// that the constraint has been violated.
	Human *String `json:"human"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Allows identification of which elements have their cardinalities impacted by
	// the constraint. Will not be referenced for constraints that do not affect
	// cardinality.
	Key *Id `json:"key"`

	// Description of why this constraint is necessary or appropriate.
	Requirements *String `json:"requirements"`

	// Identifies the impact constraint violation has on the conformance of the
	// instance.
	Severity *Code `json:"severity"`

	// A reference to the original source of the constraint, for traceability
	// purposes.
	Source *Canonical `json:"source"`

	// An XPath expression of constraint that can be executed to see if this
	// constraint is met.
	Xpath *String `json:"xpath"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionConstraint) GetExpression() *String {
	if e == nil {
		return nil
	}
	return e.Expression
}

func (e *ElementDefinitionConstraint) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionConstraint) GetHuman() *String {
	if e == nil {
		return nil
	}
	return e.Human
}

func (e *ElementDefinitionConstraint) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionConstraint) GetKey() *Id {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *ElementDefinitionConstraint) GetRequirements() *String {
	if e == nil {
		return nil
	}
	return e.Requirements
}

func (e *ElementDefinitionConstraint) GetSeverity() *Code {
	if e == nil {
		return nil
	}
	return e.Severity
}

func (e *ElementDefinitionConstraint) GetSource() *Canonical {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ElementDefinitionConstraint) GetXpath() *String {
	if e == nil {
		return nil
	}
	return e.Xpath
}

// Example value (as defined for type)// A sample value for this element demonstrating the type of information that
// would typically be found in the element.// Examples will most commonly be present for data where it's not implicitly
// obvious from either the data type or value set what the values might be.
// (I.e. Example values for dates or quantities would generally be
// unnecessary.) If the example value is fully populated, the publication tool
// can generate an instance automatically.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionExample struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Describes the purpose of this example amoung the set of examples.
	Label *String `json:"label"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	Value Element `json:"value"`

	profileimpl.BaseElement
}

func (v *ElementDefinitionExample) GetValueBase64Binary() *Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueBoolean() *Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCanonical() *Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCode() *Code {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDate() *Date {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDecimal() *Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueId() *Id {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueInstant() *Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueInteger() *Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMarkdown() *Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueOid() *Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValuePositiveInt() *PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueString() *String {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTime() *Time {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUnsignedInt() *UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUri() *Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUrl() *Url {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUuid() *Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAddress() *Address {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAge() *Age {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAnnotation() *Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAttachment() *Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCodeableConcept() *CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCoding() *Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContactPoint() *ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCount() *Count {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDistance() *Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDuration() *Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueHumanName() *HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueIdentifier() *Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMoney() *Money {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValuePeriod() *Period {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueQuantity() *Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRange() *Range {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRatio() *Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueReference() *Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueSampledData() *SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueSignature() *Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTiming() *Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContactDetail() *ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContributor() *Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDataRequirement() *DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueExpression() *Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueParameterDefinition() *ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRelatedArtifact() *RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTriggerDefinition() *TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUsageContext() *UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDosage() *Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMeta() *Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Meta)
	if ok {
		return result
	}
	return nil
}
func (e *ElementDefinitionExample) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionExample) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionExample) GetLabel() *String {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *ElementDefinitionExample) GetValue() Element {
	if e == nil {
		return nil
	}
	return e.Value
}

// Map element to another set of definitions// Identifies a concept from an external specification that roughly corresponds
// to this element.// Mappings are not necessarily specific enough for safe translation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionMapping struct {

	// Comments that provide information about the mapping or its use.
	Comment *String `json:"comment"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// An internal reference to the definition of a mapping.
	Identity *Id `json:"identity"`

	// Identifies the computable language in which mapping.map is expressed.
	Language *Code `json:"language"`

	// Expresses what part of the target specification corresponds to this element.
	Map *String `json:"map"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionMapping) GetComment() *String {
	if e == nil {
		return nil
	}
	return e.Comment
}

func (e *ElementDefinitionMapping) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionMapping) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionMapping) GetIdentity() *Id {
	if e == nil {
		return nil
	}
	return e.Identity
}

func (e *ElementDefinitionMapping) GetLanguage() *Code {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ElementDefinitionMapping) GetMap() *String {
	if e == nil {
		return nil
	}
	return e.Map
}

// This element is sliced - slices follow// Indicates that the element is sliced into a set of alternative definitions
// (i.e. in a structure definition, there are multiple different constraints on
// a single element in the base resource). Slicing can be used in any resource
// that has cardinality ..* on the base resource, or any resource with a choice
// of types. The set of slices is any elements that come after this in the
// element sequence that have the same path, until a shorter path occurs (the
// shorter path terminates the set).// The first element in the sequence, the one that carries the slicing, is the
// definition that applies to all the slices. This is based on the
// unconstrained element, but can apply any constraints as appropriate. This
// may include the common constraints on the children of the element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicing struct {

	// A human-readable text description of how the slicing works. If there is no
	// discriminator, this is required to be present to provide whatever
	// information is possible about how the slices can be differentiated.
	Description *String `json:"description"`

	// Designates which child elements are used to discriminate between the slices
	// when processing an instance. If one or more discriminators are provided, the
	// value of the child elements in the instance data SHALL completely
	// distinguish which slice the element in the resource matches based on the
	// allowed values for those elements in each of the slices.
	Discriminator []Element `json:"discriminator"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// If the matching elements have to occur in the same order as defined in the
	// profile.
	Ordered *Boolean `json:"ordered"`

	// Whether additional slices are allowed or not. When the slices are ordered,
	// profile authors can also say that additional slices are only allowed at the
	// end.
	Rules *Code `json:"rules"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionSlicing) GetDescription() *String {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *ElementDefinitionSlicing) GetDiscriminator() []Element {
	if e == nil {
		return nil
	}
	return e.Discriminator
}

func (e *ElementDefinitionSlicing) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionSlicing) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionSlicing) GetOrdered() *Boolean {
	if e == nil {
		return nil
	}
	return e.Ordered
}

func (e *ElementDefinitionSlicing) GetRules() *Code {
	if e == nil {
		return nil
	}
	return e.Rules
}

// Element values that are used to distinguish the slices// Designates which child elements are used to discriminate between the slices
// when processing an instance. If one or more discriminators are provided, the
// value of the child elements in the instance data SHALL completely
// distinguish which slice the element in the resource matches based on the
// allowed values for those elements in each of the slices.// If there is no discriminator, the content is hard to process, so this should
// be avoided.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicingDiscriminator struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// A FHIRPath expression, using [the simple subset of
	// FHIRPath](fhirpath.html#simple), that is used to identify the element on
	// which discrimination is based.
	Path *String `json:"path"`

	// How the element value is interpreted when discrimination is evaluated.
	Type *Code `json:"type"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionSlicingDiscriminator) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionSlicingDiscriminator) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionSlicingDiscriminator) GetPath() *String {
	if e == nil {
		return nil
	}
	return e.Path
}

func (e *ElementDefinitionSlicingDiscriminator) GetType() *Code {
	if e == nil {
		return nil
	}
	return e.Type
}

// Data type and Profile for this element// The data type or resource that the value of this element is permitted to be.// The Type of the element can be left blank in a differential constraint, in
// which case the type is inherited from the resource. Abstract types are not
// permitted to appear as a type when multiple types are listed. (I.e. Abstract
// types cannot be part of a choice).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionType struct {

	// If the type is a reference to another resource, how the resource is or can
	// be aggregated - is it a contained resource, or a reference, and if the
	// context is a bundle, is it included in the bundle.
	Aggregation []*Code `json:"aggregation"`

	// URL of Data type or Resource that is a(or the) type used for this element.
	// References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
	// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only
	// allowed in logical models.
	Code *Uri `json:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Identifies a profile structure or implementation Guide that applies to the
	// datatype this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the type SHALL conform to at least one
	// profile defined in the implementation guide.
	Profile []*Canonical `json:"profile"`

	// Used when the type is "Reference" or "canonical", and identifies a profile
	// structure or implementation Guide that applies to the target of the
	// reference this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the target resource SHALL conform to at
	// least one profile defined in the implementation guide.
	TargetProfile []*Canonical `json:"targetProfile"`

	// Whether this reference needs to be version specific or version independent,
	// or whether either can be used.
	Versioning *Code `json:"versioning"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionType) GetAggregation() []*Code {
	if e == nil {
		return nil
	}
	return e.Aggregation
}

func (e *ElementDefinitionType) GetCode() *Uri {
	if e == nil {
		return nil
	}
	return e.Code
}

func (e *ElementDefinitionType) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionType) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionType) GetProfile() []*Canonical {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *ElementDefinitionType) GetTargetProfile() []*Canonical {
	if e == nil {
		return nil
	}
	return e.TargetProfile
}

func (e *ElementDefinitionType) GetVersioning() *Code {
	if e == nil {
		return nil
	}
	return e.Versioning
}
