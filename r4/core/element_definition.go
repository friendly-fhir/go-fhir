// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Base StructureDefinition for ElementDefinition Type: Captures constraints on
// each element within the resource, profile, or extension.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/ElementDefinition
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinition struct {

	// Identifies additional names by which this element might also be known.
	Alias []*String `fhirpath:"alias"`

	// Information about the base definition of the element, provided to make it
	// unnecessary for tools to trace the deviation of the element through the
	// derived and related profiles. When the element definition is not the
	// original definition of an element - i.g. either in a constraint on another
	// type, or for elements from a super type in a snap shot - then the
	// information in provided in the element definition may be different to the
	// base definition. On the original definition of the element, it will be same.
	Base *ElementDefinitionBase `fhirpath:"base"`

	// Binds to a value set if this element is coded (code, Coding,
	// CodeableConcept, Quantity), or the data types (string, uri).
	Binding *ElementDefinitionBinding `fhirpath:"binding"`

	// A code that has the same meaning as the element in a particular terminology.
	Code []*Coding `fhirpath:"code"`

	// Explanatory notes and implementation guidance about the data element,
	// including notes about how to use the data properly, exceptions to proper
	// use, etc. (Note: The text you are reading is specified in
	// ElementDefinition.comment).
	Comment *Markdown `fhirpath:"comment"`

	// A reference to an invariant that may make additional statements about the
	// cardinality or value in the instance.
	Condition []*ID `fhirpath:"condition"`

	// Formal constraints such as co-occurrence and other constraints that can be
	// computationally evaluated within the context of the instance.
	Constraint []*ElementDefinitionConstraint `fhirpath:"constraint"`

	// Identifies an element defined elsewhere in the definition whose content
	// rules should be applied to the current element. ContentReferences bring
	// across all the rules that are in the ElementDefinition for the element,
	// including definitions, cardinality constraints, bindings, invariants etc.
	ContentReference *URI `fhirpath:"contentReference"`

	// The value that should be used if there is no value stated in the instance
	// (e.g. 'if not otherwise specified, the abstract is false').
	DefaultValue Element `fhirpath:"defaultValue"`

	// Provides a complete explanation of the meaning of the data element for human
	// readability. For the case of elements derived from existing elements (e.g.
	// constraints), the definition SHALL be consistent with the base definition,
	// but convey the meaning of the element in the particular context of use of
	// the resource. (Note: The text you are reading is specified in
	// ElementDefinition.definition).
	Definition *Markdown `fhirpath:"definition"`

	// A sample value for this element demonstrating the type of information that
	// would typically be found in the element.
	Example []*ElementDefinitionExample `fhirpath:"example"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Specifies a value that SHALL be exactly the value for this element in the
	// instance. For purposes of comparison, non-significant whitespace is ignored,
	// and all values must be an exact match (case and accent sensitive). Missing
	// elements/attributes must also be missing.
	Fixed Element `fhirpath:"fixed"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// If true, the value of this element affects the interpretation of the element
	// or resource that contains it, and the value of the element cannot be
	// ignored. Typically, this is used for status, negation and qualification
	// codes. The effect of this is that the element cannot be ignored by systems:
	// they SHALL either recognize the element and process it, and/or a
	// pre-determination has been made that it is not relevant to their particular
	// system.
	IsModifier *Boolean `fhirpath:"isModifier"`

	// Explains how that element affects the interpretation of the resource or
	// element that contains it.
	IsModifierReason *String `fhirpath:"isModifierReason"`

	// Whether the element should be included if a client requests a search with
	// the parameter _summary=true.
	IsSummary *Boolean `fhirpath:"isSummary"`

	// A single preferred label which is the text to display beside the element
	// indicating its meaning or to use to prompt for the element in a user display
	// or form.
	Label *String `fhirpath:"label"`

	// Identifies a concept from an external specification that roughly corresponds
	// to this element.
	Mapping []*ElementDefinitionMapping `fhirpath:"mapping"`

	// The maximum number of times this element is permitted to appear in the
	// instance.
	Max *String `fhirpath:"max"`

	// Indicates the maximum length in characters that is permitted to be present
	// in conformant instances and which is expected to be supported by conformant
	// consumers that support the element.
	MaxLength *Integer `fhirpath:"maxLength"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValue Element `fhirpath:"maxValue"`

	// The Implicit meaning that is to be understood when this element is missing
	// (e.g. 'when this element is missing, the period is ongoing').
	MeaningWhenMissing *Markdown `fhirpath:"meaningWhenMissing"`

	// The minimum number of times this element SHALL appear in the instance.
	Min *UnsignedInt `fhirpath:"min"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValue Element `fhirpath:"minValue"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*Extension `fhirpath:"modifierExtension"`

	// If true, implementations that produce or consume resources SHALL provide
	// "support" for the element in some meaningful way. If false, the element may
	// be ignored and not supported. If false, whether to populate or use the data
	// element in any way is at the discretion of the implementation.
	MustSupport *Boolean `fhirpath:"mustSupport"`

	// If present, indicates that the order of the repeating element has meaning
	// and describes what that meaning is. If absent, it means that the order of
	// the element has no meaning.
	OrderMeaning *String `fhirpath:"orderMeaning"`

	// The path identifies the element and is expressed as a "."-separated list of
	// ancestor elements, beginning with the name of the resource or extension.
	Path *String `fhirpath:"path"`

	// Specifies a value that the value in the instance SHALL follow - that is, any
	// value in the pattern must be found in the instance. Other additional values
	// may be found too. This is effectively constraint by example.
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	// When pattern[x] is used to constrain an array, it means that each element
	// provided in the pattern[x] array must (recursively) match at least one
	// element from the instance array.
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	// 1. If primitive: it must match exactly the pattern value 2. If a complex
	// object: it must match (recursively) the pattern value 3. If an array: it
	// must match (recursively) the pattern value.
	Pattern Element `fhirpath:"pattern"`

	// Codes that define how this element is represented in instances, when the
	// deviation varies from the normal case.
	Representation []*Code `fhirpath:"representation"`

	// This element is for traceability of why the element was created and why the
	// constraints exist as they do. This may be used to point to source materials
	// or specifications that drove the structure of this element.
	Requirements *Markdown `fhirpath:"requirements"`

	// A concise description of what this element means (e.g. for use in
	// autogenerated summaries).
	Short *String `fhirpath:"short"`

	// If true, indicates that this slice definition is constraining a slice
	// definition with the same name in an inherited profile. If false, the slice
	// is not overriding any slice in an inherited profile. If missing, the slice
	// might or might not be overriding a slice in an inherited profile, depending
	// on the sliceName.
	SliceIsConstraining *Boolean `fhirpath:"sliceIsConstraining"`

	// The name of this element definition slice, when slicing is working. The name
	// must be a token with no dots or spaces. This is a unique name referring to a
	// specific set of constraints applied to this element, used to provide a name
	// to different slices of the same element.
	SliceName *String `fhirpath:"sliceName"`

	// Indicates that the element is sliced into a set of alternative definitions
	// (i.e. in a structure definition, there are multiple different constraints on
	// a single element in the base resource). Slicing can be used in any resource
	// that has cardinality ..* on the base resource, or any resource with a choice
	// of types. The set of slices is any elements that come after this in the
	// element sequence that have the same path, until a shorter path occurs (the
	// shorter path terminates the set).
	Slicing *ElementDefinitionSlicing `fhirpath:"slicing"`

	// The data type or resource that the value of this element is permitted to be.
	Type []*ElementDefinitionType `fhirpath:"type"`

	profileimpl.BaseElementDefinition
	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAlias returns the value of the field Alias.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetAlias() []*String {
	if ed == nil {
		return nil
	}
	return ed.Alias
}

// GetBase returns the value of the field Base.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetBase() *ElementDefinitionBase {
	if ed == nil {
		return nil
	}
	return ed.Base
}

// GetBinding returns the value of the field Binding.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetBinding() *ElementDefinitionBinding {
	if ed == nil {
		return nil
	}
	return ed.Binding
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetCode() []*Coding {
	if ed == nil {
		return nil
	}
	return ed.Code
}

// GetComment returns the value of the field Comment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetComment() *Markdown {
	if ed == nil {
		return nil
	}
	return ed.Comment
}

// GetCondition returns the value of the field Condition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetCondition() []*ID {
	if ed == nil {
		return nil
	}
	return ed.Condition
}

// GetConstraint returns the value of the field Constraint.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetConstraint() []*ElementDefinitionConstraint {
	if ed == nil {
		return nil
	}
	return ed.Constraint
}

// GetContentReference returns the value of the field ContentReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetContentReference() *URI {
	if ed == nil {
		return nil
	}
	return ed.ContentReference
}

// GetDefaultValue returns the value of the field DefaultValue.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetDefaultValue() Element {
	if ed == nil {
		return nil
	}
	return ed.DefaultValue
}

// GetDefaultValueBase64Binary returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueBase64Binary() *Base64Binary {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Base64Binary)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueBoolean returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueBoolean() *Boolean {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueCanonical returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueCanonical() *Canonical {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Canonical)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueCode returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueCode() *Code {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Code)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDate returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDate() *Date {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDateTime returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDateTime() *DateTime {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDecimal returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDecimal() *Decimal {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueID returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueID() *ID {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*ID)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueInstant returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueInstant() *Instant {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueInteger returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueInteger() *Integer {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueMarkdown returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueMarkdown() *Markdown {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Markdown)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueOID returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueOID() *OID {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*OID)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValuePositiveInt returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValuePositiveInt() *PositiveInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueString returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueString() *String {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*String)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueTime returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueTime() *Time {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueUnsignedInt returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueUnsignedInt() *UnsignedInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueURI returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueURI() *URI {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*URI)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueURL returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueURL() *URL {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*URL)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueUUID returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueUUID() *UUID {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*UUID)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueAddress returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueAddress() *Address {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Address)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueAge returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueAge() *Age {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Age)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueAnnotation returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueAnnotation() *Annotation {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Annotation)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueAttachment returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueAttachment() *Attachment {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueCodeableConcept returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueCodeableConcept() *CodeableConcept {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueCoding returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueCoding() *Coding {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Coding)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueContactPoint returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueContactPoint() *ContactPoint {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*ContactPoint)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueCount returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueCount() *Count {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Count)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDistance returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDistance() *Distance {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Distance)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDuration returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDuration() *Duration {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueHumanName returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueHumanName() *HumanName {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*HumanName)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueIdentifier returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueIdentifier() *Identifier {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Identifier)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueMoney returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueMoney() *Money {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Money)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValuePeriod returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValuePeriod() *Period {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueQuantity returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueQuantity() *Quantity {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueRange returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueRange() *Range {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Range)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueRatio returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueRatio() *Ratio {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueReference returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueReference() *Reference {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueSampledData returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueSampledData() *SampledData {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueSignature returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueSignature() *Signature {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Signature)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueTiming returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueTiming() *Timing {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Timing)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueContactDetail returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueContactDetail() *ContactDetail {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*ContactDetail)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueContributor returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueContributor() *Contributor {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Contributor)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDataRequirement returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDataRequirement() *DataRequirement {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*DataRequirement)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueExpression returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueExpression() *Expression {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Expression)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueParameterDefinition returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueParameterDefinition() *ParameterDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*ParameterDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueRelatedArtifact returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueRelatedArtifact() *RelatedArtifact {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*RelatedArtifact)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueTriggerDefinition returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueTriggerDefinition() *TriggerDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*TriggerDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueUsageContext returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueUsageContext() *UsageContext {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*UsageContext)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueDosage returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueDosage() *Dosage {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Dosage)
	if !ok {
		return nil
	}
	return val
}

// GetDefaultValueMeta returns the value of the field DefaultValue.
func (ed *ElementDefinition) GetDefaultValueMeta() *Meta {
	if ed == nil {
		return nil
	}
	val, ok := ed.DefaultValue.(*Meta)
	if !ok {
		return nil
	}
	return val
}

// GetDefinition returns the value of the field Definition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetDefinition() *Markdown {
	if ed == nil {
		return nil
	}
	return ed.Definition
}

// GetExample returns the value of the field Example.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetExample() []*ElementDefinitionExample {
	if ed == nil {
		return nil
	}
	return ed.Example
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetExtension() []*Extension {
	if ed == nil {
		return nil
	}
	return ed.Extension
}

// GetFixed returns the value of the field Fixed.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetFixed() Element {
	if ed == nil {
		return nil
	}
	return ed.Fixed
}

// GetFixedBase64Binary returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedBase64Binary() *Base64Binary {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Base64Binary)
	if !ok {
		return nil
	}
	return val
}

// GetFixedBoolean returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedBoolean() *Boolean {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetFixedCanonical returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedCanonical() *Canonical {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Canonical)
	if !ok {
		return nil
	}
	return val
}

// GetFixedCode returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedCode() *Code {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Code)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDate returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDate() *Date {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDateTime returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDateTime() *DateTime {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDecimal returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDecimal() *Decimal {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetFixedID returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedID() *ID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*ID)
	if !ok {
		return nil
	}
	return val
}

// GetFixedInstant returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedInstant() *Instant {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetFixedInteger returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedInteger() *Integer {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetFixedMarkdown returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedMarkdown() *Markdown {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Markdown)
	if !ok {
		return nil
	}
	return val
}

// GetFixedOID returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedOID() *OID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*OID)
	if !ok {
		return nil
	}
	return val
}

// GetFixedPositiveInt returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedPositiveInt() *PositiveInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetFixedString returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedString() *String {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*String)
	if !ok {
		return nil
	}
	return val
}

// GetFixedTime returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedTime() *Time {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetFixedUnsignedInt returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedUnsignedInt() *UnsignedInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetFixedURI returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedURI() *URI {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*URI)
	if !ok {
		return nil
	}
	return val
}

// GetFixedURL returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedURL() *URL {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*URL)
	if !ok {
		return nil
	}
	return val
}

// GetFixedUUID returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedUUID() *UUID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*UUID)
	if !ok {
		return nil
	}
	return val
}

// GetFixedAddress returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedAddress() *Address {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Address)
	if !ok {
		return nil
	}
	return val
}

// GetFixedAge returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedAge() *Age {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Age)
	if !ok {
		return nil
	}
	return val
}

// GetFixedAnnotation returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedAnnotation() *Annotation {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Annotation)
	if !ok {
		return nil
	}
	return val
}

// GetFixedAttachment returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedAttachment() *Attachment {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetFixedCodeableConcept returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedCodeableConcept() *CodeableConcept {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetFixedCoding returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedCoding() *Coding {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Coding)
	if !ok {
		return nil
	}
	return val
}

// GetFixedContactPoint returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedContactPoint() *ContactPoint {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*ContactPoint)
	if !ok {
		return nil
	}
	return val
}

// GetFixedCount returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedCount() *Count {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Count)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDistance returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDistance() *Distance {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Distance)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDuration returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDuration() *Duration {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// GetFixedHumanName returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedHumanName() *HumanName {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*HumanName)
	if !ok {
		return nil
	}
	return val
}

// GetFixedIdentifier returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedIdentifier() *Identifier {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Identifier)
	if !ok {
		return nil
	}
	return val
}

// GetFixedMoney returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedMoney() *Money {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Money)
	if !ok {
		return nil
	}
	return val
}

// GetFixedPeriod returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedPeriod() *Period {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetFixedQuantity returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedQuantity() *Quantity {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetFixedRange returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedRange() *Range {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Range)
	if !ok {
		return nil
	}
	return val
}

// GetFixedRatio returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedRatio() *Ratio {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetFixedReference returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedReference() *Reference {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetFixedSampledData returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedSampledData() *SampledData {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetFixedSignature returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedSignature() *Signature {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Signature)
	if !ok {
		return nil
	}
	return val
}

// GetFixedTiming returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedTiming() *Timing {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Timing)
	if !ok {
		return nil
	}
	return val
}

// GetFixedContactDetail returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedContactDetail() *ContactDetail {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*ContactDetail)
	if !ok {
		return nil
	}
	return val
}

// GetFixedContributor returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedContributor() *Contributor {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Contributor)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDataRequirement returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDataRequirement() *DataRequirement {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*DataRequirement)
	if !ok {
		return nil
	}
	return val
}

// GetFixedExpression returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedExpression() *Expression {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Expression)
	if !ok {
		return nil
	}
	return val
}

// GetFixedParameterDefinition returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedParameterDefinition() *ParameterDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*ParameterDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetFixedRelatedArtifact returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedRelatedArtifact() *RelatedArtifact {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*RelatedArtifact)
	if !ok {
		return nil
	}
	return val
}

// GetFixedTriggerDefinition returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedTriggerDefinition() *TriggerDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*TriggerDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetFixedUsageContext returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedUsageContext() *UsageContext {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*UsageContext)
	if !ok {
		return nil
	}
	return val
}

// GetFixedDosage returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedDosage() *Dosage {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Dosage)
	if !ok {
		return nil
	}
	return val
}

// GetFixedMeta returns the value of the field Fixed.
func (ed *ElementDefinition) GetFixedMeta() *Meta {
	if ed == nil {
		return nil
	}
	val, ok := ed.Fixed.(*Meta)
	if !ok {
		return nil
	}
	return val
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetID() string {
	if ed == nil {
		return ""
	}
	return ed.ID
}

// GetIsModifier returns the value of the field IsModifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetIsModifier() *Boolean {
	if ed == nil {
		return nil
	}
	return ed.IsModifier
}

// GetIsModifierReason returns the value of the field IsModifierReason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetIsModifierReason() *String {
	if ed == nil {
		return nil
	}
	return ed.IsModifierReason
}

// GetIsSummary returns the value of the field IsSummary.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetIsSummary() *Boolean {
	if ed == nil {
		return nil
	}
	return ed.IsSummary
}

// GetLabel returns the value of the field Label.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetLabel() *String {
	if ed == nil {
		return nil
	}
	return ed.Label
}

// GetMapping returns the value of the field Mapping.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMapping() []*ElementDefinitionMapping {
	if ed == nil {
		return nil
	}
	return ed.Mapping
}

// GetMax returns the value of the field Max.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMax() *String {
	if ed == nil {
		return nil
	}
	return ed.Max
}

// GetMaxLength returns the value of the field MaxLength.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMaxLength() *Integer {
	if ed == nil {
		return nil
	}
	return ed.MaxLength
}

// GetMaxValue returns the value of the field MaxValue.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMaxValue() Element {
	if ed == nil {
		return nil
	}
	return ed.MaxValue
}

// GetMaxValueDate returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueDate() *Date {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueDateTime returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueDateTime() *DateTime {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueInstant returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueInstant() *Instant {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueTime returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueTime() *Time {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueDecimal returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueDecimal() *Decimal {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueInteger returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueInteger() *Integer {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValuePositiveInt returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValuePositiveInt() *PositiveInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueUnsignedInt returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueUnsignedInt() *UnsignedInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetMaxValueQuantity returns the value of the field MaxValue.
func (ed *ElementDefinition) GetMaxValueQuantity() *Quantity {
	if ed == nil {
		return nil
	}
	val, ok := ed.MaxValue.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetMeaningWhenMissing returns the value of the field MeaningWhenMissing.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMeaningWhenMissing() *Markdown {
	if ed == nil {
		return nil
	}
	return ed.MeaningWhenMissing
}

// GetMin returns the value of the field Min.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMin() *UnsignedInt {
	if ed == nil {
		return nil
	}
	return ed.Min
}

// GetMinValue returns the value of the field MinValue.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMinValue() Element {
	if ed == nil {
		return nil
	}
	return ed.MinValue
}

// GetMinValueDate returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueDate() *Date {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueDateTime returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueDateTime() *DateTime {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueInstant returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueInstant() *Instant {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueTime returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueTime() *Time {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueDecimal returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueDecimal() *Decimal {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueInteger returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueInteger() *Integer {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetMinValuePositiveInt returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValuePositiveInt() *PositiveInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueUnsignedInt returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueUnsignedInt() *UnsignedInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetMinValueQuantity returns the value of the field MinValue.
func (ed *ElementDefinition) GetMinValueQuantity() *Quantity {
	if ed == nil {
		return nil
	}
	val, ok := ed.MinValue.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetModifierExtension() []*Extension {
	if ed == nil {
		return nil
	}
	return ed.ModifierExtension
}

// GetMustSupport returns the value of the field MustSupport.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetMustSupport() *Boolean {
	if ed == nil {
		return nil
	}
	return ed.MustSupport
}

// GetOrderMeaning returns the value of the field OrderMeaning.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetOrderMeaning() *String {
	if ed == nil {
		return nil
	}
	return ed.OrderMeaning
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetPath() *String {
	if ed == nil {
		return nil
	}
	return ed.Path
}

// GetPattern returns the value of the field Pattern.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetPattern() Element {
	if ed == nil {
		return nil
	}
	return ed.Pattern
}

// GetPatternBase64Binary returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternBase64Binary() *Base64Binary {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Base64Binary)
	if !ok {
		return nil
	}
	return val
}

// GetPatternBoolean returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternBoolean() *Boolean {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetPatternCanonical returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternCanonical() *Canonical {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Canonical)
	if !ok {
		return nil
	}
	return val
}

// GetPatternCode returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternCode() *Code {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Code)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDate returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDate() *Date {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDateTime returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDateTime() *DateTime {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDecimal returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDecimal() *Decimal {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetPatternID returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternID() *ID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*ID)
	if !ok {
		return nil
	}
	return val
}

// GetPatternInstant returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternInstant() *Instant {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetPatternInteger returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternInteger() *Integer {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetPatternMarkdown returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternMarkdown() *Markdown {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Markdown)
	if !ok {
		return nil
	}
	return val
}

// GetPatternOID returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternOID() *OID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*OID)
	if !ok {
		return nil
	}
	return val
}

// GetPatternPositiveInt returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternPositiveInt() *PositiveInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetPatternString returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternString() *String {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*String)
	if !ok {
		return nil
	}
	return val
}

// GetPatternTime returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternTime() *Time {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetPatternUnsignedInt returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternUnsignedInt() *UnsignedInt {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetPatternURI returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternURI() *URI {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*URI)
	if !ok {
		return nil
	}
	return val
}

// GetPatternURL returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternURL() *URL {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*URL)
	if !ok {
		return nil
	}
	return val
}

// GetPatternUUID returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternUUID() *UUID {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*UUID)
	if !ok {
		return nil
	}
	return val
}

// GetPatternAddress returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternAddress() *Address {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Address)
	if !ok {
		return nil
	}
	return val
}

// GetPatternAge returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternAge() *Age {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Age)
	if !ok {
		return nil
	}
	return val
}

// GetPatternAnnotation returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternAnnotation() *Annotation {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Annotation)
	if !ok {
		return nil
	}
	return val
}

// GetPatternAttachment returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternAttachment() *Attachment {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetPatternCodeableConcept returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternCodeableConcept() *CodeableConcept {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetPatternCoding returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternCoding() *Coding {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Coding)
	if !ok {
		return nil
	}
	return val
}

// GetPatternContactPoint returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternContactPoint() *ContactPoint {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*ContactPoint)
	if !ok {
		return nil
	}
	return val
}

// GetPatternCount returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternCount() *Count {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Count)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDistance returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDistance() *Distance {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Distance)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDuration returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDuration() *Duration {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// GetPatternHumanName returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternHumanName() *HumanName {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*HumanName)
	if !ok {
		return nil
	}
	return val
}

// GetPatternIdentifier returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternIdentifier() *Identifier {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Identifier)
	if !ok {
		return nil
	}
	return val
}

// GetPatternMoney returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternMoney() *Money {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Money)
	if !ok {
		return nil
	}
	return val
}

// GetPatternPeriod returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternPeriod() *Period {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetPatternQuantity returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternQuantity() *Quantity {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetPatternRange returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternRange() *Range {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Range)
	if !ok {
		return nil
	}
	return val
}

// GetPatternRatio returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternRatio() *Ratio {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetPatternReference returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternReference() *Reference {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetPatternSampledData returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternSampledData() *SampledData {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetPatternSignature returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternSignature() *Signature {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Signature)
	if !ok {
		return nil
	}
	return val
}

// GetPatternTiming returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternTiming() *Timing {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Timing)
	if !ok {
		return nil
	}
	return val
}

// GetPatternContactDetail returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternContactDetail() *ContactDetail {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*ContactDetail)
	if !ok {
		return nil
	}
	return val
}

// GetPatternContributor returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternContributor() *Contributor {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Contributor)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDataRequirement returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDataRequirement() *DataRequirement {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*DataRequirement)
	if !ok {
		return nil
	}
	return val
}

// GetPatternExpression returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternExpression() *Expression {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Expression)
	if !ok {
		return nil
	}
	return val
}

// GetPatternParameterDefinition returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternParameterDefinition() *ParameterDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*ParameterDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetPatternRelatedArtifact returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternRelatedArtifact() *RelatedArtifact {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*RelatedArtifact)
	if !ok {
		return nil
	}
	return val
}

// GetPatternTriggerDefinition returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternTriggerDefinition() *TriggerDefinition {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*TriggerDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetPatternUsageContext returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternUsageContext() *UsageContext {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*UsageContext)
	if !ok {
		return nil
	}
	return val
}

// GetPatternDosage returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternDosage() *Dosage {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Dosage)
	if !ok {
		return nil
	}
	return val
}

// GetPatternMeta returns the value of the field Pattern.
func (ed *ElementDefinition) GetPatternMeta() *Meta {
	if ed == nil {
		return nil
	}
	val, ok := ed.Pattern.(*Meta)
	if !ok {
		return nil
	}
	return val
}

// GetRepresentation returns the value of the field Representation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetRepresentation() []*Code {
	if ed == nil {
		return nil
	}
	return ed.Representation
}

// GetRequirements returns the value of the field Requirements.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetRequirements() *Markdown {
	if ed == nil {
		return nil
	}
	return ed.Requirements
}

// GetShort returns the value of the field Short.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetShort() *String {
	if ed == nil {
		return nil
	}
	return ed.Short
}

// GetSliceIsConstraining returns the value of the field SliceIsConstraining.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetSliceIsConstraining() *Boolean {
	if ed == nil {
		return nil
	}
	return ed.SliceIsConstraining
}

// GetSliceName returns the value of the field SliceName.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetSliceName() *String {
	if ed == nil {
		return nil
	}
	return ed.SliceName
}

// GetSlicing returns the value of the field Slicing.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetSlicing() *ElementDefinitionSlicing {
	if ed == nil {
		return nil
	}
	return ed.Slicing
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ed *ElementDefinition) GetType() []*ElementDefinitionType {
	if ed == nil {
		return nil
	}
	return ed.Type
}

// Base definition information for tools// Information about the base definition of the element, provided to make it
// unnecessary for tools to trace the deviation of the element through the
// derived and related profiles. When the element definition is not the
// original definition of an element - i.g. either in a constraint on another
// type, or for elements from a super type in a snap shot - then the
// information in provided in the element definition may be different to the
// base definition. On the original definition of the element, it will be same.// The base information does not carry any information that could not be
// determined from the path and related profiles, but making this determination
// requires both that the related profiles are available, and that the
// algorithm to determine them be available. For tooling simplicity, the base
// information must always be populated in element definitions in snap shots,
// even if it is the same.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBase struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Maximum cardinality of the base element identified by the path.
	Max *String `fhirpath:"max"`

	// Minimum cardinality of the base element identified by the path.
	Min *UnsignedInt `fhirpath:"min"`

	// The Path that identifies the base element - this matches the
	// ElementDefinition.path for that element. Across FHIR, there is only one base
	// definition of any element - that is, an element definition on a
	// [StructureDefinition](structuredefinition.html#) without a
	// StructureDefinition.base.
	Path *String `fhirpath:"path"`

	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBase) GetExtension() []*Extension {
	if edb == nil {
		return nil
	}
	return edb.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBase) GetID() string {
	if edb == nil {
		return ""
	}
	return edb.ID
}

// GetMax returns the value of the field Max.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBase) GetMax() *String {
	if edb == nil {
		return nil
	}
	return edb.Max
}

// GetMin returns the value of the field Min.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBase) GetMin() *UnsignedInt {
	if edb == nil {
		return nil
	}
	return edb.Min
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBase) GetPath() *String {
	if edb == nil {
		return nil
	}
	return edb.Path
}

// ValueSet details if this is coded// Binds to a value set if this element is coded (code, Coding,
// CodeableConcept, Quantity), or the data types (string, uri).// For a CodeableConcept, when no codes are allowed - only text, use a binding
// of strength "required" with a description explaining that no coded values
// are allowed and what sort of information to put in the "text" element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBinding struct {

	// Describes the intended use of this particular set of codes.
	Description *String `fhirpath:"description"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Indicates the degree of conformance expectations associated with this
	// binding - that is, the degree to which the provided value set must be
	// adhered to in the instances.
	Strength *Code `fhirpath:"strength"`

	// Refers to the value set that identifies the set of codes the binding refers
	// to.
	ValueSet *Canonical `fhirpath:"valueSet"`

	profileimpl.BaseElement
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBinding) GetDescription() *String {
	if edb == nil {
		return nil
	}
	return edb.Description
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBinding) GetExtension() []*Extension {
	if edb == nil {
		return nil
	}
	return edb.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBinding) GetID() string {
	if edb == nil {
		return ""
	}
	return edb.ID
}

// GetStrength returns the value of the field Strength.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBinding) GetStrength() *Code {
	if edb == nil {
		return nil
	}
	return edb.Strength
}

// GetValueSet returns the value of the field ValueSet.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edb *ElementDefinitionBinding) GetValueSet() *Canonical {
	if edb == nil {
		return nil
	}
	return edb.ValueSet
}

// Condition that must evaluate to true// Formal constraints such as co-occurrence and other constraints that can be
// computationally evaluated within the context of the instance.// Constraints should be declared on the "context" element - the lowest element
// in the hierarchy that is common to all nodes referenced by the constraint.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionConstraint struct {

	// A [FHIRPath](fhirpath.html) expression of constraint that can be executed to
	// see if this constraint is met.
	Expression *String `fhirpath:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Text that can be used to describe the constraint in messages identifying
	// that the constraint has been violated.
	Human *String `fhirpath:"human"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Allows identification of which elements have their cardinalities impacted by
	// the constraint. Will not be referenced for constraints that do not affect
	// cardinality.
	Key *ID `fhirpath:"key"`

	// Description of why this constraint is necessary or appropriate.
	Requirements *String `fhirpath:"requirements"`

	// Identifies the impact constraint violation has on the conformance of the
	// instance.
	Severity *Code `fhirpath:"severity"`

	// A reference to the original source of the constraint, for traceability
	// purposes.
	Source *Canonical `fhirpath:"source"`

	// An XPath expression of constraint that can be executed to see if this
	// constraint is met.
	Xpath *String `fhirpath:"xpath"`

	profileimpl.BaseElement
}

// GetExpression returns the value of the field Expression.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetExpression() *String {
	if edc == nil {
		return nil
	}
	return edc.Expression
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetExtension() []*Extension {
	if edc == nil {
		return nil
	}
	return edc.Extension
}

// GetHuman returns the value of the field Human.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetHuman() *String {
	if edc == nil {
		return nil
	}
	return edc.Human
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetID() string {
	if edc == nil {
		return ""
	}
	return edc.ID
}

// GetKey returns the value of the field Key.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetKey() *ID {
	if edc == nil {
		return nil
	}
	return edc.Key
}

// GetRequirements returns the value of the field Requirements.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetRequirements() *String {
	if edc == nil {
		return nil
	}
	return edc.Requirements
}

// GetSeverity returns the value of the field Severity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetSeverity() *Code {
	if edc == nil {
		return nil
	}
	return edc.Severity
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetSource() *Canonical {
	if edc == nil {
		return nil
	}
	return edc.Source
}

// GetXpath returns the value of the field Xpath.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edc *ElementDefinitionConstraint) GetXpath() *String {
	if edc == nil {
		return nil
	}
	return edc.Xpath
}

// Example value (as defined for type)// A sample value for this element demonstrating the type of information that
// would typically be found in the element.// Examples will most commonly be present for data where it's not implicitly
// obvious from either the data type or value set what the values might be.
// (I.e. Example values for dates or quantities would generally be
// unnecessary.) If the example value is fully populated, the publication tool
// can generate an instance automatically.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionExample struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Describes the purpose of this example amoung the set of examples.
	Label *String `fhirpath:"label"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	Value Element `fhirpath:"value"`

	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ede *ElementDefinitionExample) GetExtension() []*Extension {
	if ede == nil {
		return nil
	}
	return ede.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ede *ElementDefinitionExample) GetID() string {
	if ede == nil {
		return ""
	}
	return ede.ID
}

// GetLabel returns the value of the field Label.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ede *ElementDefinitionExample) GetLabel() *String {
	if ede == nil {
		return nil
	}
	return ede.Label
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ede *ElementDefinitionExample) GetValue() Element {
	if ede == nil {
		return nil
	}
	return ede.Value
}

// GetValueBase64Binary returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueBase64Binary() *Base64Binary {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Base64Binary)
	if !ok {
		return nil
	}
	return val
}

// GetValueBoolean returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueBoolean() *Boolean {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetValueCanonical returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueCanonical() *Canonical {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Canonical)
	if !ok {
		return nil
	}
	return val
}

// GetValueCode returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueCode() *Code {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Code)
	if !ok {
		return nil
	}
	return val
}

// GetValueDate returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDate() *Date {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetValueDateTime returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDateTime() *DateTime {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetValueDecimal returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDecimal() *Decimal {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetValueID returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueID() *ID {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*ID)
	if !ok {
		return nil
	}
	return val
}

// GetValueInstant returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueInstant() *Instant {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Instant)
	if !ok {
		return nil
	}
	return val
}

// GetValueInteger returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueInteger() *Integer {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Integer)
	if !ok {
		return nil
	}
	return val
}

// GetValueMarkdown returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueMarkdown() *Markdown {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Markdown)
	if !ok {
		return nil
	}
	return val
}

// GetValueOID returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueOID() *OID {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*OID)
	if !ok {
		return nil
	}
	return val
}

// GetValuePositiveInt returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValuePositiveInt() *PositiveInt {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*PositiveInt)
	if !ok {
		return nil
	}
	return val
}

// GetValueString returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueString() *String {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*String)
	if !ok {
		return nil
	}
	return val
}

// GetValueTime returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueTime() *Time {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Time)
	if !ok {
		return nil
	}
	return val
}

// GetValueUnsignedInt returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueUnsignedInt() *UnsignedInt {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*UnsignedInt)
	if !ok {
		return nil
	}
	return val
}

// GetValueURI returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueURI() *URI {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*URI)
	if !ok {
		return nil
	}
	return val
}

// GetValueURL returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueURL() *URL {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*URL)
	if !ok {
		return nil
	}
	return val
}

// GetValueUUID returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueUUID() *UUID {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*UUID)
	if !ok {
		return nil
	}
	return val
}

// GetValueAddress returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueAddress() *Address {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Address)
	if !ok {
		return nil
	}
	return val
}

// GetValueAge returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueAge() *Age {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Age)
	if !ok {
		return nil
	}
	return val
}

// GetValueAnnotation returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueAnnotation() *Annotation {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Annotation)
	if !ok {
		return nil
	}
	return val
}

// GetValueAttachment returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueAttachment() *Attachment {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetValueCodeableConcept returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueCodeableConcept() *CodeableConcept {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetValueCoding returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueCoding() *Coding {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Coding)
	if !ok {
		return nil
	}
	return val
}

// GetValueContactPoint returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueContactPoint() *ContactPoint {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*ContactPoint)
	if !ok {
		return nil
	}
	return val
}

// GetValueCount returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueCount() *Count {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Count)
	if !ok {
		return nil
	}
	return val
}

// GetValueDistance returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDistance() *Distance {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Distance)
	if !ok {
		return nil
	}
	return val
}

// GetValueDuration returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDuration() *Duration {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// GetValueHumanName returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueHumanName() *HumanName {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*HumanName)
	if !ok {
		return nil
	}
	return val
}

// GetValueIdentifier returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueIdentifier() *Identifier {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Identifier)
	if !ok {
		return nil
	}
	return val
}

// GetValueMoney returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueMoney() *Money {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Money)
	if !ok {
		return nil
	}
	return val
}

// GetValuePeriod returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValuePeriod() *Period {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetValueQuantity returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueQuantity() *Quantity {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetValueRange returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueRange() *Range {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Range)
	if !ok {
		return nil
	}
	return val
}

// GetValueRatio returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueRatio() *Ratio {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetValueReference returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueReference() *Reference {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetValueSampledData returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueSampledData() *SampledData {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetValueSignature returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueSignature() *Signature {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Signature)
	if !ok {
		return nil
	}
	return val
}

// GetValueTiming returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueTiming() *Timing {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Timing)
	if !ok {
		return nil
	}
	return val
}

// GetValueContactDetail returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueContactDetail() *ContactDetail {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*ContactDetail)
	if !ok {
		return nil
	}
	return val
}

// GetValueContributor returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueContributor() *Contributor {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Contributor)
	if !ok {
		return nil
	}
	return val
}

// GetValueDataRequirement returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDataRequirement() *DataRequirement {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*DataRequirement)
	if !ok {
		return nil
	}
	return val
}

// GetValueExpression returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueExpression() *Expression {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Expression)
	if !ok {
		return nil
	}
	return val
}

// GetValueParameterDefinition returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueParameterDefinition() *ParameterDefinition {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*ParameterDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetValueRelatedArtifact returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueRelatedArtifact() *RelatedArtifact {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*RelatedArtifact)
	if !ok {
		return nil
	}
	return val
}

// GetValueTriggerDefinition returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueTriggerDefinition() *TriggerDefinition {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*TriggerDefinition)
	if !ok {
		return nil
	}
	return val
}

// GetValueUsageContext returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueUsageContext() *UsageContext {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*UsageContext)
	if !ok {
		return nil
	}
	return val
}

// GetValueDosage returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueDosage() *Dosage {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Dosage)
	if !ok {
		return nil
	}
	return val
}

// GetValueMeta returns the value of the field Value.
func (ede *ElementDefinitionExample) GetValueMeta() *Meta {
	if ede == nil {
		return nil
	}
	val, ok := ede.Value.(*Meta)
	if !ok {
		return nil
	}
	return val
}

// Map element to another set of definitions// Identifies a concept from an external specification that roughly corresponds
// to this element.// Mappings are not necessarily specific enough for safe translation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionMapping struct {

	// Comments that provide information about the mapping or its use.
	Comment *String `fhirpath:"comment"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// An internal reference to the definition of a mapping.
	Identity *ID `fhirpath:"identity"`

	// Identifies the computable language in which mapping.map is expressed.
	Language *Code `fhirpath:"language"`

	// Expresses what part of the target specification corresponds to this element.
	Map *String `fhirpath:"map"`

	profileimpl.BaseElement
}

// GetComment returns the value of the field Comment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetComment() *String {
	if edm == nil {
		return nil
	}
	return edm.Comment
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetExtension() []*Extension {
	if edm == nil {
		return nil
	}
	return edm.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetID() string {
	if edm == nil {
		return ""
	}
	return edm.ID
}

// GetIdentity returns the value of the field Identity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetIdentity() *ID {
	if edm == nil {
		return nil
	}
	return edm.Identity
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetLanguage() *Code {
	if edm == nil {
		return nil
	}
	return edm.Language
}

// GetMap returns the value of the field Map.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edm *ElementDefinitionMapping) GetMap() *String {
	if edm == nil {
		return nil
	}
	return edm.Map
}

// This element is sliced - slices follow// Indicates that the element is sliced into a set of alternative definitions
// (i.e. in a structure definition, there are multiple different constraints on
// a single element in the base resource). Slicing can be used in any resource
// that has cardinality ..* on the base resource, or any resource with a choice
// of types. The set of slices is any elements that come after this in the
// element sequence that have the same path, until a shorter path occurs (the
// shorter path terminates the set).// The first element in the sequence, the one that carries the slicing, is the
// definition that applies to all the slices. This is based on the
// unconstrained element, but can apply any constraints as appropriate. This
// may include the common constraints on the children of the element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicing struct {

	// A human-readable text description of how the slicing works. If there is no
	// discriminator, this is required to be present to provide whatever
	// information is possible about how the slices can be differentiated.
	Description *String `fhirpath:"description"`

	// Designates which child elements are used to discriminate between the slices
	// when processing an instance. If one or more discriminators are provided, the
	// value of the child elements in the instance data SHALL completely
	// distinguish which slice the element in the resource matches based on the
	// allowed values for those elements in each of the slices.
	Discriminator []*ElementDefinitionSlicingDiscriminator `fhirpath:"discriminator"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// If the matching elements have to occur in the same order as defined in the
	// profile.
	Ordered *Boolean `fhirpath:"ordered"`

	// Whether additional slices are allowed or not. When the slices are ordered,
	// profile authors can also say that additional slices are only allowed at the
	// end.
	Rules *Code `fhirpath:"rules"`

	profileimpl.BaseElement
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetDescription() *String {
	if eds == nil {
		return nil
	}
	return eds.Description
}

// GetDiscriminator returns the value of the field Discriminator.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetDiscriminator() []*ElementDefinitionSlicingDiscriminator {
	if eds == nil {
		return nil
	}
	return eds.Discriminator
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetExtension() []*Extension {
	if eds == nil {
		return nil
	}
	return eds.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetID() string {
	if eds == nil {
		return ""
	}
	return eds.ID
}

// GetOrdered returns the value of the field Ordered.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetOrdered() *Boolean {
	if eds == nil {
		return nil
	}
	return eds.Ordered
}

// GetRules returns the value of the field Rules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (eds *ElementDefinitionSlicing) GetRules() *Code {
	if eds == nil {
		return nil
	}
	return eds.Rules
}

// Element values that are used to distinguish the slices// Designates which child elements are used to discriminate between the slices
// when processing an instance. If one or more discriminators are provided, the
// value of the child elements in the instance data SHALL completely
// distinguish which slice the element in the resource matches based on the
// allowed values for those elements in each of the slices.// If there is no discriminator, the content is hard to process, so this should
// be avoided.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicingDiscriminator struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// A FHIRPath expression, using [the simple subset of
	// FHIRPath](fhirpath.html#simple), that is used to identify the element on
	// which discrimination is based.
	Path *String `fhirpath:"path"`

	// How the element value is interpreted when discrimination is evaluated.
	Type *Code `fhirpath:"type"`

	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edsd *ElementDefinitionSlicingDiscriminator) GetExtension() []*Extension {
	if edsd == nil {
		return nil
	}
	return edsd.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edsd *ElementDefinitionSlicingDiscriminator) GetID() string {
	if edsd == nil {
		return ""
	}
	return edsd.ID
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edsd *ElementDefinitionSlicingDiscriminator) GetPath() *String {
	if edsd == nil {
		return nil
	}
	return edsd.Path
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edsd *ElementDefinitionSlicingDiscriminator) GetType() *Code {
	if edsd == nil {
		return nil
	}
	return edsd.Type
}

// Data type and Profile for this element// The data type or resource that the value of this element is permitted to be.// The Type of the element can be left blank in a differential constraint, in
// which case the type is inherited from the resource. Abstract types are not
// permitted to appear as a type when multiple types are listed. (I.e. Abstract
// types cannot be part of a choice).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionType struct {

	// If the type is a reference to another resource, how the resource is or can
	// be aggregated - is it a contained resource, or a reference, and if the
	// context is a bundle, is it included in the bundle.
	Aggregation []*Code `fhirpath:"aggregation"`

	// URL of Data type or Resource that is a(or the) type used for this element.
	// References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
	// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only
	// allowed in logical models.
	Code *URI `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Identifies a profile structure or implementation Guide that applies to the
	// datatype this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the type SHALL conform to at least one
	// profile defined in the implementation guide.
	Profile []*Canonical `fhirpath:"profile"`

	// Used when the type is "Reference" or "canonical", and identifies a profile
	// structure or implementation Guide that applies to the target of the
	// reference this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the target resource SHALL conform to at
	// least one profile defined in the implementation guide.
	TargetProfile []*Canonical `fhirpath:"targetProfile"`

	// Whether this reference needs to be version specific or version independent,
	// or whether either can be used.
	Versioning *Code `fhirpath:"versioning"`

	profileimpl.BaseElement
}

// GetAggregation returns the value of the field Aggregation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetAggregation() []*Code {
	if edt == nil {
		return nil
	}
	return edt.Aggregation
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetCode() *URI {
	if edt == nil {
		return nil
	}
	return edt.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetExtension() []*Extension {
	if edt == nil {
		return nil
	}
	return edt.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetID() string {
	if edt == nil {
		return ""
	}
	return edt.ID
}

// GetProfile returns the value of the field Profile.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetProfile() []*Canonical {
	if edt == nil {
		return nil
	}
	return edt.Profile
}

// GetTargetProfile returns the value of the field TargetProfile.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetTargetProfile() []*Canonical {
	if edt == nil {
		return nil
	}
	return edt.TargetProfile
}

// GetVersioning returns the value of the field Versioning.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (edt *ElementDefinitionType) GetVersioning() *Code {
	if edt == nil {
		return nil
	}
	return edt.Versioning
}
