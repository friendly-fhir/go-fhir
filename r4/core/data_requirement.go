// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Base StructureDefinition for DataRequirement Type: Describes a required data
// item for evaluation in terms of the type of data, and optional code or
// date-based filters of the data.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/DataRequirement
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirement struct {

	// Code filters specify additional constraints on the data, specifying the
	// value set of interest for a particular element of the data. Each code filter
	// defines an additional constraint on the data, i.e. code filters are AND'ed,
	// not OR'ed.
	CodeFilter []*DataRequirementCodeFilter `fhirpath:"codeFilter"`

	// Date filters specify additional constraints on the data in terms of the
	// applicable date range for specific elements. Each date filter specifies an
	// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
	DateFilter []*DataRequirementDateFilter `fhirpath:"dateFilter"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Specifies a maximum number of results that are required (uses the _count
	// search parameter).
	Limit *PositiveInt `fhirpath:"limit"`

	// Indicates that specific elements of the type are referenced by the knowledge
	// module and must be supported by the consumer in order to obtain an effective
	// evaluation. This does not mean that a value is required for this element,
	// only that the consuming system must understand the element and be able to
	// provide values for it if they are available.
	// The value of mustSupport SHALL be a FHIRPath resolveable on the type of the
	// DataRequirement. The path SHALL consist only of identifiers, constant
	// indexers, and .resolve() (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	MustSupport []*String `fhirpath:"mustSupport"`

	// The profile of the required data, specified as the uri of the profile
	// definition.
	Profile []*Canonical `fhirpath:"profile"`

	// Specifies the order of the results to be returned.
	Sort []*DataRequirementSort `fhirpath:"sort"`

	// The intended subjects of the data requirement. If this element is not
	// provided, a Patient subject is assumed.
	Subject Element `fhirpath:"subject"`

	// The type of the required data, specified as the type name of a resource. For
	// profiles, this value is set to the type of the base resource of the profile.
	Type *Code `fhirpath:"type"`

	profileimpl.BaseElement
}

// GetCodeFilter returns the value of the field CodeFilter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetCodeFilter() []*DataRequirementCodeFilter {
	if dr == nil {
		return nil
	}
	return dr.CodeFilter
}

// GetDateFilter returns the value of the field DateFilter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetDateFilter() []*DataRequirementDateFilter {
	if dr == nil {
		return nil
	}
	return dr.DateFilter
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetExtension() []*Extension {
	if dr == nil {
		return nil
	}
	return dr.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetID() string {
	if dr == nil {
		return ""
	}
	return dr.ID
}

// GetLimit returns the value of the field Limit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetLimit() *PositiveInt {
	if dr == nil {
		return nil
	}
	return dr.Limit
}

// GetMustSupport returns the value of the field MustSupport.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetMustSupport() []*String {
	if dr == nil {
		return nil
	}
	return dr.MustSupport
}

// GetProfile returns the value of the field Profile.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetProfile() []*Canonical {
	if dr == nil {
		return nil
	}
	return dr.Profile
}

// GetSort returns the value of the field Sort.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetSort() []*DataRequirementSort {
	if dr == nil {
		return nil
	}
	return dr.Sort
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetSubject() Element {
	if dr == nil {
		return nil
	}
	return dr.Subject
}

// GetSubjectCodeableConcept returns the value of the field Subject.
func (dr *DataRequirement) GetSubjectCodeableConcept() *CodeableConcept {
	if dr == nil {
		return nil
	}
	val, ok := dr.Subject.(*CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetSubjectReference returns the value of the field Subject.
func (dr *DataRequirement) GetSubjectReference() *Reference {
	if dr == nil {
		return nil
	}
	val, ok := dr.Subject.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (dr *DataRequirement) GetType() *Code {
	if dr == nil {
		return nil
	}
	return dr.Type
}

// What codes are expected// Code filters specify additional constraints on the data, specifying the
// value set of interest for a particular element of the data. Each code filter
// defines an additional constraint on the data, i.e. code filters are AND'ed,
// not OR'ed.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementCodeFilter struct {

	// The codes for the code filter. If values are given, the filter will return
	// only those data items for which the code-valued attribute specified by the
	// path has a value that is one of the specified codes. If codes are specified
	// in addition to a value set, the filter returns items matching a code in the
	// value set or one of the specified codes.
	Code []*Coding `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The code-valued attribute of the filter. The specified path SHALL be a
	// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
	// consist only of identifiers, constant indexers, and .resolve(). The path is
	// allowed to contain qualifiers (.) to traverse sub-elements, as well as
	// indexers ([x]) to traverse multiple-cardinality sub-elements (see the
	// [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that
	// the index must be an integer constant. The path must resolve to an element
	// of type code, Coding, or CodeableConcept.
	Path *String `fhirpath:"path"`

	// A token parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type code,
	// Coding, or CodeableConcept.
	SearchParam *String `fhirpath:"searchParam"`

	// The valueset for the code filter. The valueSet and code elements are
	// additive. If valueSet is specified, the filter will return only those data
	// items for which the value of the code-valued element specified in the path
	// is a member of the specified valueset.
	ValueSet *Canonical `fhirpath:"valueSet"`

	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetCode() []*Coding {
	if drcf == nil {
		return nil
	}
	return drcf.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetExtension() []*Extension {
	if drcf == nil {
		return nil
	}
	return drcf.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetID() string {
	if drcf == nil {
		return ""
	}
	return drcf.ID
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetPath() *String {
	if drcf == nil {
		return nil
	}
	return drcf.Path
}

// GetSearchParam returns the value of the field SearchParam.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetSearchParam() *String {
	if drcf == nil {
		return nil
	}
	return drcf.SearchParam
}

// GetValueSet returns the value of the field ValueSet.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drcf *DataRequirementCodeFilter) GetValueSet() *Canonical {
	if drcf == nil {
		return nil
	}
	return drcf.ValueSet
}

// What dates/date ranges are expected// Date filters specify additional constraints on the data in terms of the
// applicable date range for specific elements. Each date filter specifies an
// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementDateFilter struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The date-valued attribute of the filter. The specified path SHALL be a
	// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
	// consist only of identifiers, constant indexers, and .resolve(). The path is
	// allowed to contain qualifiers (.) to traverse sub-elements, as well as
	// indexers ([x]) to traverse multiple-cardinality sub-elements (see the
	// [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that
	// the index must be an integer constant. The path must resolve to an element
	// of type date, dateTime, Period, Schedule, or Timing.
	Path *String `fhirpath:"path"`

	// A date parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type date,
	// dateTime, Period, Schedule, or Timing.
	SearchParam *String `fhirpath:"searchParam"`

	// The value of the filter. If period is specified, the filter will return only
	// those data items that fall within the bounds determined by the Period,
	// inclusive of the period boundaries. If dateTime is specified, the filter
	// will return only those data items that are equal to the specified dateTime.
	// If a Duration is specified, the filter will return only those data items
	// that fall within Duration before now.
	Value Element `fhirpath:"value"`

	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drdf *DataRequirementDateFilter) GetExtension() []*Extension {
	if drdf == nil {
		return nil
	}
	return drdf.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drdf *DataRequirementDateFilter) GetID() string {
	if drdf == nil {
		return ""
	}
	return drdf.ID
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drdf *DataRequirementDateFilter) GetPath() *String {
	if drdf == nil {
		return nil
	}
	return drdf.Path
}

// GetSearchParam returns the value of the field SearchParam.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drdf *DataRequirementDateFilter) GetSearchParam() *String {
	if drdf == nil {
		return nil
	}
	return drdf.SearchParam
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drdf *DataRequirementDateFilter) GetValue() Element {
	if drdf == nil {
		return nil
	}
	return drdf.Value
}

// GetValueDateTime returns the value of the field Value.
func (drdf *DataRequirementDateFilter) GetValueDateTime() *DateTime {
	if drdf == nil {
		return nil
	}
	val, ok := drdf.Value.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetValuePeriod returns the value of the field Value.
func (drdf *DataRequirementDateFilter) GetValuePeriod() *Period {
	if drdf == nil {
		return nil
	}
	val, ok := drdf.Value.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetValueDuration returns the value of the field Value.
func (drdf *DataRequirementDateFilter) GetValueDuration() *Duration {
	if drdf == nil {
		return nil
	}
	val, ok := drdf.Value.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// Order of the results// Specifies the order of the results to be returned.// This element can be used in combination with the sort element to specify
// quota requirements such as "the most recent 5" or "the highest 5". When
// multiple sorts are specified, they are applied in the order they appear in
// the resource.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementSort struct {

	// The direction of the sort, ascending or descending.
	Direction *Code `fhirpath:"direction"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The attribute of the sort. The specified path must be resolvable from the
	// type of the required data. The path is allowed to contain qualifiers (.) to
	// traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements. Note that the index must be an integer
	// constant.
	Path *String `fhirpath:"path"`

	profileimpl.BaseElement
}

// GetDirection returns the value of the field Direction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drs *DataRequirementSort) GetDirection() *Code {
	if drs == nil {
		return nil
	}
	return drs.Direction
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drs *DataRequirementSort) GetExtension() []*Extension {
	if drs == nil {
		return nil
	}
	return drs.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drs *DataRequirementSort) GetID() string {
	if drs == nil {
		return ""
	}
	return drs.ID
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (drs *DataRequirementSort) GetPath() *String {
	if drs == nil {
		return nil
	}
	return drs.Path
}
