// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.
package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Base StructureDefinition for DataRequirement Type: Describes a required data
// item for evaluation in terms of the type of data, and optional code or
// date-based filters of the data.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/DataRequirement
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirement struct {

	// Code filters specify additional constraints on the data, specifying the
	// value set of interest for a particular element of the data. Each code filter
	// defines an additional constraint on the data, i.e. code filters are AND'ed,
	// not OR'ed.
	CodeFilter []Element `json:"codeFilter"`

	// Date filters specify additional constraints on the data in terms of the
	// applicable date range for specific elements. Each date filter specifies an
	// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
	DateFilter []Element `json:"dateFilter"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Specifies a maximum number of results that are required (uses the _count
	// search parameter).
	Limit *PositiveInt `json:"limit"`

	// Indicates that specific elements of the type are referenced by the knowledge
	// module and must be supported by the consumer in order to obtain an effective
	// evaluation. This does not mean that a value is required for this element,
	// only that the consuming system must understand the element and be able to
	// provide values for it if they are available.
	// The value of mustSupport SHALL be a FHIRPath resolveable on the type of the
	// DataRequirement. The path SHALL consist only of identifiers, constant
	// indexers, and .resolve() (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	MustSupport []*String `json:"mustSupport"`

	// The profile of the required data, specified as the uri of the profile
	// definition.
	Profile []*Canonical `json:"profile"`

	// Specifies the order of the results to be returned.
	Sort []Element `json:"sort"`

	// The intended subjects of the data requirement. If this element is not
	// provided, a Patient subject is assumed.
	Subject Element `json:"subject"`

	// The type of the required data, specified as the type name of a resource. For
	// profiles, this value is set to the type of the base resource of the profile.
	Type *Code `json:"type"`

	profileimpl.BaseElement
}

func (v *DataRequirement) GetSubjectCodeableConcept() *CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Subject.(*CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *DataRequirement) GetSubjectReference() *Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Subject.(*Reference)
	if ok {
		return result
	}
	return nil
}
func (d *DataRequirement) GetCodeFilter() []Element {
	if d == nil {
		return nil
	}
	return d.CodeFilter
}

func (d *DataRequirement) GetDateFilter() []Element {
	if d == nil {
		return nil
	}
	return d.DateFilter
}

func (d *DataRequirement) GetExtension() []*Extension {
	if d == nil {
		return nil
	}
	return d.Extension
}

func (d *DataRequirement) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DataRequirement) GetLimit() *PositiveInt {
	if d == nil {
		return nil
	}
	return d.Limit
}

func (d *DataRequirement) GetMustSupport() []*String {
	if d == nil {
		return nil
	}
	return d.MustSupport
}

func (d *DataRequirement) GetProfile() []*Canonical {
	if d == nil {
		return nil
	}
	return d.Profile
}

func (d *DataRequirement) GetSort() []Element {
	if d == nil {
		return nil
	}
	return d.Sort
}

func (d *DataRequirement) GetSubject() Element {
	if d == nil {
		return nil
	}
	return d.Subject
}

func (d *DataRequirement) GetType() *Code {
	if d == nil {
		return nil
	}
	return d.Type
}

// What codes are expected// Code filters specify additional constraints on the data, specifying the
// value set of interest for a particular element of the data. Each code filter
// defines an additional constraint on the data, i.e. code filters are AND'ed,
// not OR'ed.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementCodeFilter struct {

	// The codes for the code filter. If values are given, the filter will return
	// only those data items for which the code-valued attribute specified by the
	// path has a value that is one of the specified codes. If codes are specified
	// in addition to a value set, the filter returns items matching a code in the
	// value set or one of the specified codes.
	Code []*Coding `json:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// The code-valued attribute of the filter. The specified path SHALL be a
	// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
	// consist only of identifiers, constant indexers, and .resolve(). The path is
	// allowed to contain qualifiers (.) to traverse sub-elements, as well as
	// indexers ([x]) to traverse multiple-cardinality sub-elements (see the
	// [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that
	// the index must be an integer constant. The path must resolve to an element
	// of type code, Coding, or CodeableConcept.
	Path *String `json:"path"`

	// A token parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type code,
	// Coding, or CodeableConcept.
	SearchParam *String `json:"searchParam"`

	// The valueset for the code filter. The valueSet and code elements are
	// additive. If valueSet is specified, the filter will return only those data
	// items for which the value of the code-valued element specified in the path
	// is a member of the specified valueset.
	ValueSet *Canonical `json:"valueSet"`

	profileimpl.BaseElement
}

func (d *DataRequirementCodeFilter) GetCode() []*Coding {
	if d == nil {
		return nil
	}
	return d.Code
}

func (d *DataRequirementCodeFilter) GetExtension() []*Extension {
	if d == nil {
		return nil
	}
	return d.Extension
}

func (d *DataRequirementCodeFilter) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DataRequirementCodeFilter) GetPath() *String {
	if d == nil {
		return nil
	}
	return d.Path
}

func (d *DataRequirementCodeFilter) GetSearchParam() *String {
	if d == nil {
		return nil
	}
	return d.SearchParam
}

func (d *DataRequirementCodeFilter) GetValueSet() *Canonical {
	if d == nil {
		return nil
	}
	return d.ValueSet
}

// What dates/date ranges are expected// Date filters specify additional constraints on the data in terms of the
// applicable date range for specific elements. Each date filter specifies an
// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementDateFilter struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// The date-valued attribute of the filter. The specified path SHALL be a
	// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
	// consist only of identifiers, constant indexers, and .resolve(). The path is
	// allowed to contain qualifiers (.) to traverse sub-elements, as well as
	// indexers ([x]) to traverse multiple-cardinality sub-elements (see the
	// [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that
	// the index must be an integer constant. The path must resolve to an element
	// of type date, dateTime, Period, Schedule, or Timing.
	Path *String `json:"path"`

	// A date parameter that refers to a search parameter defined on the specified
	// type of the DataRequirement, and which searches on elements of type date,
	// dateTime, Period, Schedule, or Timing.
	SearchParam *String `json:"searchParam"`

	// The value of the filter. If period is specified, the filter will return only
	// those data items that fall within the bounds determined by the Period,
	// inclusive of the period boundaries. If dateTime is specified, the filter
	// will return only those data items that are equal to the specified dateTime.
	// If a Duration is specified, the filter will return only those data items
	// that fall within Duration before now.
	Value Element `json:"value"`

	profileimpl.BaseElement
}

func (v *DataRequirementDateFilter) GetValueDateTime() *DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *DataRequirementDateFilter) GetValuePeriod() *Period {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Period)
	if ok {
		return result
	}
	return nil
}
func (v *DataRequirementDateFilter) GetValueDuration() *Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*Duration)
	if ok {
		return result
	}
	return nil
}
func (d *DataRequirementDateFilter) GetExtension() []*Extension {
	if d == nil {
		return nil
	}
	return d.Extension
}

func (d *DataRequirementDateFilter) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DataRequirementDateFilter) GetPath() *String {
	if d == nil {
		return nil
	}
	return d.Path
}

func (d *DataRequirementDateFilter) GetSearchParam() *String {
	if d == nil {
		return nil
	}
	return d.SearchParam
}

func (d *DataRequirementDateFilter) GetValue() Element {
	if d == nil {
		return nil
	}
	return d.Value
}

// Order of the results// Specifies the order of the results to be returned.// This element can be used in combination with the sort element to specify
// quota requirements such as "the most recent 5" or "the highest 5". When
// multiple sorts are specified, they are applied in the order they appear in
// the resource.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-DataRequirement.json
type DataRequirementSort struct {

	// The direction of the sort, ascending or descending.
	Direction *Code `json:"direction"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// The attribute of the sort. The specified path must be resolvable from the
	// type of the required data. The path is allowed to contain qualifiers (.) to
	// traverse sub-elements, as well as indexers ([x]) to traverse
	// multiple-cardinality sub-elements. Note that the index must be an integer
	// constant.
	Path *String `json:"path"`

	profileimpl.BaseElement
}

func (d *DataRequirementSort) GetDirection() *Code {
	if d == nil {
		return nil
	}
	return d.Direction
}

func (d *DataRequirementSort) GetExtension() []*Extension {
	if d == nil {
		return nil
	}
	return d.Extension
}

func (d *DataRequirementSort) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DataRequirementSort) GetPath() *String {
	if d == nil {
		return nil
	}
	return d.Path
}
