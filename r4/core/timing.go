// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Base StructureDefinition for Timing Type: Specifies an event that may occur
// multiple times. Timing schedules are used to record when things are planned,
// expected or requested to occur. The most common usage is in dosage
// instructions for medications. They are also used when planning care of
// various kinds, and may be used for reporting the schedule to which past
// regular activities were carried out.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Timing
//   - Source File: StructureDefinition-Timing.json
type Timing struct {

	// A code for the timing schedule (or just text in code.text). Some codes such
	// as BID are ubiquitous, but many institutions define their own additional
	// codes. If a code is provided, the code is understood to be a complete
	// statement of whatever is specified in the structured timing data, and either
	// the code or the data may be used to interpret the Timing, with the exception
	// that .repeat.bounds still applies over the code (and is not contained in the
	// code).
	Code *CodeableConcept `fhirpath:"code"`

	// Identifies specific times when the event occurs.
	Event []*DateTime `fhirpath:"event"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*Extension `fhirpath:"modifierExtension"`

	// A set of rules that describe when the event is scheduled.
	Repeat *TimingRepeat `fhirpath:"repeat"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetCode() *CodeableConcept {
	if t == nil {
		return nil
	}
	return t.Code
}

// GetEvent returns the value of the field Event.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetEvent() []*DateTime {
	if t == nil {
		return nil
	}
	return t.Event
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetExtension() []*Extension {
	if t == nil {
		return nil
	}
	return t.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetModifierExtension() []*Extension {
	if t == nil {
		return nil
	}
	return t.ModifierExtension
}

// GetRepeat returns the value of the field Repeat.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (t *Timing) GetRepeat() *TimingRepeat {
	if t == nil {
		return nil
	}
	return t.Repeat
}

// When the event is to occur// A set of rules that describe when the event is scheduled.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Timing.json
type TimingRepeat struct {

	// Either a duration for the length of the timing schedule, a range of possible
	// length, or outer bounds for start and/or end limits of the timing schedule.
	Bounds Element `fhirpath:"bounds"`

	// A total count of the desired number of repetitions across the duration of
	// the entire timing specification. If countMax is present, this element
	// indicates the lower bound of the allowed range of count values.
	Count *PositiveInt `fhirpath:"count"`

	// If present, indicates that the count is a range - so to perform the action
	// between [count] and [countMax] times.
	CountMax *PositiveInt `fhirpath:"countMax"`

	// If one or more days of week is provided, then the action happens only on the
	// specified day(s).
	DayOfWeek []*Code `fhirpath:"dayOfWeek"`

	// How long this thing happens for when it happens. If durationMax is present,
	// this element indicates the lower bound of the allowed range of the duration.
	Duration *Decimal `fhirpath:"duration"`

	// If present, indicates that the duration is a range - so to perform the
	// action between [duration] and [durationMax] time length.
	DurationMax *Decimal `fhirpath:"durationMax"`

	// The units of time for the duration, in UCUM units.
	DurationUnit *Code `fhirpath:"durationUnit"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// The number of times to repeat the action within the specified period. If
	// frequencyMax is present, this element indicates the lower bound of the
	// allowed range of the frequency.
	Frequency *PositiveInt `fhirpath:"frequency"`

	// If present, indicates that the frequency is a range - so to repeat between
	// [frequency] and [frequencyMax] times within the period or period range.
	FrequencyMax *PositiveInt `fhirpath:"frequencyMax"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The number of minutes from the event. If the event code does not indicate
	// whether the minutes is before or after the event, then the offset is assumed
	// to be after the event.
	Offset *UnsignedInt `fhirpath:"offset"`

	// Indicates the duration of time over which repetitions are to occur; e.g. to
	// express "3 times per day", 3 would be the frequency and "1 day" would be the
	// period. If periodMax is present, this element indicates the lower bound of
	// the allowed range of the period length.
	Period *Decimal `fhirpath:"period"`

	// If present, indicates that the period is a range from [period] to
	// [periodMax], allowing expressing concepts such as "do this once every 3-5
	// days.
	PeriodMax *Decimal `fhirpath:"periodMax"`

	// The units of time for the period in UCUM units.
	PeriodUnit *Code `fhirpath:"periodUnit"`

	// Specified time of day for action to take place.
	TimeOfDay []*Time `fhirpath:"timeOfDay"`

	// An approximate time period during the day, potentially linked to an event of
	// daily living that indicates when the action should occur.
	When []*Code `fhirpath:"when"`

	profileimpl.BaseElement
}

// GetBounds returns the value of the field Bounds.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetBounds() Element {
	if tr == nil {
		return nil
	}
	return tr.Bounds
}

// GetBoundsDuration returns the value of the field Bounds.
func (tr *TimingRepeat) GetBoundsDuration() *Duration {
	if tr == nil {
		return nil
	}
	val, ok := tr.Bounds.(*Duration)
	if !ok {
		return nil
	}
	return val
}

// GetBoundsRange returns the value of the field Bounds.
func (tr *TimingRepeat) GetBoundsRange() *Range {
	if tr == nil {
		return nil
	}
	val, ok := tr.Bounds.(*Range)
	if !ok {
		return nil
	}
	return val
}

// GetBoundsPeriod returns the value of the field Bounds.
func (tr *TimingRepeat) GetBoundsPeriod() *Period {
	if tr == nil {
		return nil
	}
	val, ok := tr.Bounds.(*Period)
	if !ok {
		return nil
	}
	return val
}

// GetCount returns the value of the field Count.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetCount() *PositiveInt {
	if tr == nil {
		return nil
	}
	return tr.Count
}

// GetCountMax returns the value of the field CountMax.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetCountMax() *PositiveInt {
	if tr == nil {
		return nil
	}
	return tr.CountMax
}

// GetDayOfWeek returns the value of the field DayOfWeek.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetDayOfWeek() []*Code {
	if tr == nil {
		return nil
	}
	return tr.DayOfWeek
}

// GetDuration returns the value of the field Duration.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetDuration() *Decimal {
	if tr == nil {
		return nil
	}
	return tr.Duration
}

// GetDurationMax returns the value of the field DurationMax.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetDurationMax() *Decimal {
	if tr == nil {
		return nil
	}
	return tr.DurationMax
}

// GetDurationUnit returns the value of the field DurationUnit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetDurationUnit() *Code {
	if tr == nil {
		return nil
	}
	return tr.DurationUnit
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetExtension() []*Extension {
	if tr == nil {
		return nil
	}
	return tr.Extension
}

// GetFrequency returns the value of the field Frequency.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetFrequency() *PositiveInt {
	if tr == nil {
		return nil
	}
	return tr.Frequency
}

// GetFrequencyMax returns the value of the field FrequencyMax.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetFrequencyMax() *PositiveInt {
	if tr == nil {
		return nil
	}
	return tr.FrequencyMax
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetID() string {
	if tr == nil {
		return ""
	}
	return tr.ID
}

// GetOffset returns the value of the field Offset.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetOffset() *UnsignedInt {
	if tr == nil {
		return nil
	}
	return tr.Offset
}

// GetPeriod returns the value of the field Period.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetPeriod() *Decimal {
	if tr == nil {
		return nil
	}
	return tr.Period
}

// GetPeriodMax returns the value of the field PeriodMax.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetPeriodMax() *Decimal {
	if tr == nil {
		return nil
	}
	return tr.PeriodMax
}

// GetPeriodUnit returns the value of the field PeriodUnit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetPeriodUnit() *Code {
	if tr == nil {
		return nil
	}
	return tr.PeriodUnit
}

// GetTimeOfDay returns the value of the field TimeOfDay.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetTimeOfDay() []*Time {
	if tr == nil {
		return nil
	}
	return tr.TimeOfDay
}

// GetWhen returns the value of the field When.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tr *TimingRepeat) GetWhen() []*Code {
	if tr == nil {
		return nil
	}
	return tr.When
}

func (t *Timing) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (t *Timing) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code      *CodeableConcept `json:"code"`
		Event     []*DateTime      `json:"event"`
		Extension []*Extension     `json:"extension"`

		ID                string        `json:"id"`
		ModifierExtension []*Extension  `json:"modifierExtension"`
		Repeat            *TimingRepeat `json:"repeat"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	t.Code = raw.Code
	t.Event = raw.Event
	t.Extension = raw.Extension
	t.ID = raw.ID
	t.ModifierExtension = raw.ModifierExtension
	t.Repeat = raw.Repeat
	return nil
}

var _ json.Marshaler = (*Timing)(nil)
var _ json.Unmarshaler = (*Timing)(nil)

func (tr *TimingRepeat) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tr *TimingRepeat) UnmarshalJSON(data []byte) error {
	var raw struct {
		BoundsDuration *Duration    `json:"boundsDuration"`
		BoundsRange    *Range       `json:"boundsRange"`
		BoundsPeriod   *Period      `json:"boundsPeriod"`
		Count          *PositiveInt `json:"count"`
		CountMax       *PositiveInt `json:"countMax"`
		DayOfWeek      []*Code      `json:"dayOfWeek"`
		Duration       *Decimal     `json:"duration"`
		DurationMax    *Decimal     `json:"durationMax"`
		DurationUnit   *Code        `json:"durationUnit"`
		Extension      []*Extension `json:"extension"`
		Frequency      *PositiveInt `json:"frequency"`
		FrequencyMax   *PositiveInt `json:"frequencyMax"`

		ID         string       `json:"id"`
		Offset     *UnsignedInt `json:"offset"`
		Period     *Decimal     `json:"period"`
		PeriodMax  *Decimal     `json:"periodMax"`
		PeriodUnit *Code        `json:"periodUnit"`
		TimeOfDay  []*Time      `json:"timeOfDay"`
		When       []*Code      `json:"when"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tr.Bounds, err = validate.SelectOneOf[Element]("Timing.repeat.bounds",
		raw.BoundsDuration,
		raw.BoundsRange,
		raw.BoundsPeriod)
	if err != nil {
		return err
	}
	tr.Count = raw.Count
	tr.CountMax = raw.CountMax
	tr.DayOfWeek = raw.DayOfWeek
	tr.Duration = raw.Duration
	tr.DurationMax = raw.DurationMax
	tr.DurationUnit = raw.DurationUnit
	tr.Extension = raw.Extension
	tr.Frequency = raw.Frequency
	tr.FrequencyMax = raw.FrequencyMax
	tr.ID = raw.ID
	tr.Offset = raw.Offset
	tr.Period = raw.Period
	tr.PeriodMax = raw.PeriodMax
	tr.PeriodUnit = raw.PeriodUnit
	tr.TimeOfDay = raw.TimeOfDay
	tr.When = raw.When
	return nil
}

var _ json.Marshaler = (*TimingRepeat)(nil)
var _ json.Unmarshaler = (*TimingRepeat)(nil)
