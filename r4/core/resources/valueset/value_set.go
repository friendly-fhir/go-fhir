// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package valueset

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// A ValueSet resource instance specifies a set of codes drawn from one or more
// code systems, intended for use in a particular context. Value sets link
// between [[[CodeSystem]]] definitions and their use in [coded
// elements](terminologies.html).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/ValueSet
//   - Source File: StructureDefinition-ValueSet.json
type ValueSet struct {

	// A set of criteria that define the contents of the value set by including or
	// excluding codes selected from the specified code system(s) that the value
	// set draws from. This is also known as the Content Logical Definition (CLD).
	Compose *ValueSetCompose `fhirpath:"compose"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []*fhir.ContactDetail `fhirpath:"contact"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// A copyright statement relating to the value set and/or its contents.
	// Copyright statements are generally legal restrictions on the use and
	// publishing of the value set.
	Copyright *fhir.Markdown `fhirpath:"copyright"`

	// The date (and optionally time) when the value set was created or revised
	// (e.g. the 'content logical definition').
	Date *fhir.DateTime `fhirpath:"date"`

	// A free text natural language description of the value set from a consumer's
	// perspective. The textual description specifies the span of meanings for
	// concepts to be included within the Value Set Expansion, and also may specify
	// the intended use and limitations of the Value Set.
	Description *fhir.Markdown `fhirpath:"description"`

	// A value set can also be "expanded", where the value set is turned into a
	// simple collection of enumerated codes. This element holds the expansion, if
	// it has been performed.
	Expansion *ValueSetExpansion `fhirpath:"expansion"`

	// A Boolean value to indicate that this value set is authored for testing
	// purposes (or education/evaluation/marketing) and is not intended to be used
	// for genuine usage.
	Experimental *fhir.Boolean `fhirpath:"experimental"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// A formal identifier that is used to identify this value set when it is
	// represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// If this is set to 'true', then no new versions of the content logical
	// definition can be created. Note: Other metadata might still change.
	Immutable *fhir.Boolean `fhirpath:"immutable"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// A legal or geographic region in which the value set is intended to be used.
	Jurisdiction []*fhir.CodeableConcept `fhirpath:"jurisdiction"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A natural language name identifying the value set. This name should be
	// usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name *fhir.String `fhirpath:"name"`

	// The name of the organization or individual that published the value set.
	Publisher *fhir.String `fhirpath:"publisher"`

	// Explanation of why this value set is needed and why it has been designed as
	// it has.
	Purpose *fhir.Markdown `fhirpath:"purpose"`

	// The status of this value set. Enables tracking the life-cycle of the
	// content. The status of the value set applies to the value set definition
	// (ValueSet.compose) and the associated ValueSet metadata. Expansions do not
	// have a state.
	Status *fhir.Code `fhirpath:"status"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// A short, descriptive, user-friendly title for the value set.
	Title *fhir.String `fhirpath:"title"`

	// An absolute URI that is used to identify this value set when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which at which an authoritative instance of this value set is (or
	// will be) published. This URL can be the target of a canonical reference. It
	// SHALL remain the same when the value set is stored on different servers.
	URL *fhir.URI `fhirpath:"url"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...)
	// or may be references to specific programs (insurance plans, studies, ...)
	// and may be used to assist with indexing and searching for appropriate value
	// set instances.
	UseContext []*fhir.UsageContext `fhirpath:"useContext"`

	// The identifier that is used to identify this version of the value set when
	// it is referenced in a specification, model, design or instance. This is an
	// arbitrary value managed by the value set author and is not expected to be
	// globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
	// managed version is not available. There is also no expectation that versions
	// can be placed in a lexicographical sequence.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseValueSet
	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetCompose returns the value of the field Compose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetCompose() *ValueSetCompose {
	if vs == nil {
		return nil
	}
	return vs.Compose
}

// GetContact returns the value of the field Contact.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetContact() []*fhir.ContactDetail {
	if vs == nil {
		return nil
	}
	return vs.Contact
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetContained() []fhir.Resource {
	if vs == nil {
		return nil
	}
	return vs.Contained
}

// GetCopyright returns the value of the field Copyright.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetCopyright() *fhir.Markdown {
	if vs == nil {
		return nil
	}
	return vs.Copyright
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetDate() *fhir.DateTime {
	if vs == nil {
		return nil
	}
	return vs.Date
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetDescription() *fhir.Markdown {
	if vs == nil {
		return nil
	}
	return vs.Description
}

// GetExpansion returns the value of the field Expansion.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetExpansion() *ValueSetExpansion {
	if vs == nil {
		return nil
	}
	return vs.Expansion
}

// GetExperimental returns the value of the field Experimental.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetExperimental() *fhir.Boolean {
	if vs == nil {
		return nil
	}
	return vs.Experimental
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetExtension() []*fhir.Extension {
	if vs == nil {
		return nil
	}
	return vs.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetID() string {
	if vs == nil {
		return ""
	}
	return vs.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetIdentifier() []*fhir.Identifier {
	if vs == nil {
		return nil
	}
	return vs.Identifier
}

// GetImmutable returns the value of the field Immutable.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetImmutable() *fhir.Boolean {
	if vs == nil {
		return nil
	}
	return vs.Immutable
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetImplicitRules() *fhir.URI {
	if vs == nil {
		return nil
	}
	return vs.ImplicitRules
}

// GetJurisdiction returns the value of the field Jurisdiction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetJurisdiction() []*fhir.CodeableConcept {
	if vs == nil {
		return nil
	}
	return vs.Jurisdiction
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetLanguage() *fhir.Code {
	if vs == nil {
		return nil
	}
	return vs.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetMeta() *fhir.Meta {
	if vs == nil {
		return nil
	}
	return vs.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetModifierExtension() []*fhir.Extension {
	if vs == nil {
		return nil
	}
	return vs.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetName() *fhir.String {
	if vs == nil {
		return nil
	}
	return vs.Name
}

// GetPublisher returns the value of the field Publisher.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetPublisher() *fhir.String {
	if vs == nil {
		return nil
	}
	return vs.Publisher
}

// GetPurpose returns the value of the field Purpose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetPurpose() *fhir.Markdown {
	if vs == nil {
		return nil
	}
	return vs.Purpose
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetStatus() *fhir.Code {
	if vs == nil {
		return nil
	}
	return vs.Status
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetText() *fhir.Narrative {
	if vs == nil {
		return nil
	}
	return vs.Text
}

// GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetTitle() *fhir.String {
	if vs == nil {
		return nil
	}
	return vs.Title
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetURL() *fhir.URI {
	if vs == nil {
		return nil
	}
	return vs.URL
}

// GetUseContext returns the value of the field UseContext.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetUseContext() []*fhir.UsageContext {
	if vs == nil {
		return nil
	}
	return vs.UseContext
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vs *ValueSet) GetVersion() *fhir.String {
	if vs == nil {
		return nil
	}
	return vs.Version
}

// Content logical definition of the value set (CLD)// A set of criteria that define the contents of the value set by including or
// excluding codes selected from the specified code system(s) that the value
// set draws from. This is also known as the Content Logical Definition (CLD).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetCompose struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Whether inactive codes - codes that are not approved for current use - are
	// in the value set. If inactive = true, inactive codes are to be included in
	// the expansion, if inactive = false, the inactive codes will not be included
	// in the expansion. If absent, the behavior is determined by the
	// implementation, or by the applicable $expand parameters (but generally,
	// inactive codes would be expected to be included).
	Inactive *fhir.Boolean `fhirpath:"inactive"`

	// Include one or more codes from a code system or other value set(s).
	Include []*ValueSetComposeInclude `fhirpath:"include"`

	// The Locked Date is the effective date that is used to determine the version
	// of all referenced Code Systems and Value Set Definitions included in the
	// compose that are not already tied to a specific version.
	LockedDate *fhir.Date `fhirpath:"lockedDate"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetExtension() []*fhir.Extension {
	if vsc == nil {
		return nil
	}
	return vsc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetID() string {
	if vsc == nil {
		return ""
	}
	return vsc.ID
}

// GetInactive returns the value of the field Inactive.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetInactive() *fhir.Boolean {
	if vsc == nil {
		return nil
	}
	return vsc.Inactive
}

// GetInclude returns the value of the field Include.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetInclude() []*ValueSetComposeInclude {
	if vsc == nil {
		return nil
	}
	return vsc.Include
}

// GetLockedDate returns the value of the field LockedDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetLockedDate() *fhir.Date {
	if vsc == nil {
		return nil
	}
	return vsc.LockedDate
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsc *ValueSetCompose) GetModifierExtension() []*fhir.Extension {
	if vsc == nil {
		return nil
	}
	return vsc.ModifierExtension
}

// Include one or more codes from a code system or other value set(s)// Include one or more codes from a code system or other value set(s).// All the conditions in an include must be true. If a system is listed, all
// the codes from the system are listed. If one or more filters are listed, all
// of the filters must apply. If one or more value sets are listed, the codes
// must be in all the value sets. E.g. each include is 'include all the codes
// that meet all these conditions'.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetComposeInclude struct {

	// Specifies a concept to be included or excluded.
	Concept []*ValueSetComposeIncludeConcept `fhirpath:"concept"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Select concepts by specify a matching criterion based on the properties
	// (including relationships) defined by the system, or on filters defined by
	// the system. If multiple filters are specified, they SHALL all be true.
	Filter []*ValueSetComposeIncludeFilter `fhirpath:"filter"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// An absolute URI which is the code system from which the selected codes come
	// from.
	System *fhir.URI `fhirpath:"system"`

	// Selects the concepts found in this value set (based on its value set
	// definition). This is an absolute URI that is a reference to ValueSet.url. If
	// multiple value sets are specified this includes the union of the contents of
	// all of the referenced value sets.
	ValueSet []*fhir.Canonical `fhirpath:"valueSet"`

	// The version of the code system that the codes are selected from, or the
	// special version '*' for all versions.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetConcept returns the value of the field Concept.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetConcept() []*ValueSetComposeIncludeConcept {
	if vsci == nil {
		return nil
	}
	return vsci.Concept
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetExtension() []*fhir.Extension {
	if vsci == nil {
		return nil
	}
	return vsci.Extension
}

// GetFilter returns the value of the field Filter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetFilter() []*ValueSetComposeIncludeFilter {
	if vsci == nil {
		return nil
	}
	return vsci.Filter
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetID() string {
	if vsci == nil {
		return ""
	}
	return vsci.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetModifierExtension() []*fhir.Extension {
	if vsci == nil {
		return nil
	}
	return vsci.ModifierExtension
}

// GetSystem returns the value of the field System.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetSystem() *fhir.URI {
	if vsci == nil {
		return nil
	}
	return vsci.System
}

// GetValueSet returns the value of the field ValueSet.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetValueSet() []*fhir.Canonical {
	if vsci == nil {
		return nil
	}
	return vsci.ValueSet
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsci *ValueSetComposeInclude) GetVersion() *fhir.String {
	if vsci == nil {
		return nil
	}
	return vsci.Version
}

// A concept defined in the system// Specifies a concept to be included or excluded.// The list of concepts is considered ordered, though the order might not have
// any particular significance. Typically, the order of an expansion follows
// that defined in the compose element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetComposeIncludeConcept struct {

	// Specifies a code for the concept to be included or excluded.
	Code *fhir.Code `fhirpath:"code"`

	// Additional representations for this concept when used in this value set -
	// other languages, aliases, specialized purposes, used for particular
	// purposes, etc.
	Designation []*ValueSetComposeIncludeConceptDesignation `fhirpath:"designation"`

	// The text to display to the user for this concept in the context of this
	// valueset. If no display is provided, then applications using the value set
	// use the display specified for the code by the system.
	Display *fhir.String `fhirpath:"display"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetCode() *fhir.Code {
	if vscic == nil {
		return nil
	}
	return vscic.Code
}

// GetDesignation returns the value of the field Designation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetDesignation() []*ValueSetComposeIncludeConceptDesignation {
	if vscic == nil {
		return nil
	}
	return vscic.Designation
}

// GetDisplay returns the value of the field Display.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetDisplay() *fhir.String {
	if vscic == nil {
		return nil
	}
	return vscic.Display
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetExtension() []*fhir.Extension {
	if vscic == nil {
		return nil
	}
	return vscic.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetID() string {
	if vscic == nil {
		return ""
	}
	return vscic.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscic *ValueSetComposeIncludeConcept) GetModifierExtension() []*fhir.Extension {
	if vscic == nil {
		return nil
	}
	return vscic.ModifierExtension
}

// Additional representations for this concept// Additional representations for this concept when used in this value set -
// other languages, aliases, specialized purposes, used for particular
// purposes, etc.// Concepts have both a ```display``` and an array of ```designation```. The
// display is equivalent to a special designation with an implied
// ```designation.use``` of "primary code" and a language equal to the
// [Resource Language](resource.html#language).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetComposeIncludeConceptDesignation struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The language this designation is defined for.
	Language *fhir.Code `fhirpath:"language"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A code that represents types of uses of designations.
	Use *fhir.Coding `fhirpath:"use"`

	// The text value for this designation.
	Value *fhir.String `fhirpath:"value"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetExtension() []*fhir.Extension {
	if vscicd == nil {
		return nil
	}
	return vscicd.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetID() string {
	if vscicd == nil {
		return ""
	}
	return vscicd.ID
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetLanguage() *fhir.Code {
	if vscicd == nil {
		return nil
	}
	return vscicd.Language
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetModifierExtension() []*fhir.Extension {
	if vscicd == nil {
		return nil
	}
	return vscicd.ModifierExtension
}

// GetUse returns the value of the field Use.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetUse() *fhir.Coding {
	if vscicd == nil {
		return nil
	}
	return vscicd.Use
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscicd *ValueSetComposeIncludeConceptDesignation) GetValue() *fhir.String {
	if vscicd == nil {
		return nil
	}
	return vscicd.Value
}

// Select codes/concepts by their properties (including relationships)// Select concepts by specify a matching criterion based on the properties
// (including relationships) defined by the system, or on filters defined by
// the system. If multiple filters are specified, they SHALL all be true.// Selecting codes by specifying filters based on properties is only possible
// where the underlying code system defines appropriate properties. Note that
// in some cases, the underlying code system defines the logical concepts but
// not the literal codes for the concepts. In such cases, the literal
// definitions may be provided by a third party.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetComposeIncludeFilter struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The kind of operation to perform as a part of the filter criteria.
	Op *fhir.Code `fhirpath:"op"`

	// A code that identifies a property or a filter defined in the code system.
	Property *fhir.Code `fhirpath:"property"`

	// The match value may be either a code defined by the system, or a string
	// value, which is a regex match on the literal string of the property value
	// (if the filter represents a property defined in CodeSystem) or of the system
	// filter value (if the filter represents a filter defined in CodeSystem) when
	// the operation is 'regex', or one of the values (true and false), when the
	// operation is 'exists'.
	Value *fhir.String `fhirpath:"value"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetExtension() []*fhir.Extension {
	if vscif == nil {
		return nil
	}
	return vscif.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetID() string {
	if vscif == nil {
		return ""
	}
	return vscif.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetModifierExtension() []*fhir.Extension {
	if vscif == nil {
		return nil
	}
	return vscif.ModifierExtension
}

// GetOp returns the value of the field Op.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetOp() *fhir.Code {
	if vscif == nil {
		return nil
	}
	return vscif.Op
}

// GetProperty returns the value of the field Property.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetProperty() *fhir.Code {
	if vscif == nil {
		return nil
	}
	return vscif.Property
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vscif *ValueSetComposeIncludeFilter) GetValue() *fhir.String {
	if vscif == nil {
		return nil
	}
	return vscif.Value
}

// Used when the value set is "expanded"// A value set can also be "expanded", where the value set is turned into a
// simple collection of enumerated codes. This element holds the expansion, if
// it has been performed.// Expansion is performed to produce a collection of codes that are ready to
// use for data entry or validation. Value set expansions are always considered
// to be stateless - they are a record of the set of codes in the value set at
// a point in time under a given set of conditions, and are not subject to
// ongoing maintenance.
// Expansion.parameter is a simplified list of parameters - a subset of the
// features of the [Parameters](parameters.html) resource.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetExpansion struct {

	// The codes that are contained in the value set expansion.
	Contains []*ValueSetExpansionContains `fhirpath:"contains"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// An identifier that uniquely identifies this expansion of the valueset, based
	// on a unique combination of the provided parameters, the system default
	// parameters, and the underlying system code system versions etc. Systems may
	// re-use the same identifier as long as those factors remain the same, and the
	// expansion is the same, but are not required to do so. This is a business
	// identifier.
	Identifier *fhir.URI `fhirpath:"identifier"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// If paging is being used, the offset at which this resource starts. I.e. this
	// resource is a partial view into the expansion. If paging is not being used,
	// this element SHALL NOT be present.
	Offset *fhir.Integer `fhirpath:"offset"`

	// A parameter that controlled the expansion process. These parameters may be
	// used by users of expanded value sets to check whether the expansion is
	// suitable for a particular purpose, or to pick the correct expansion.
	Parameter []*ValueSetExpansionParameter `fhirpath:"parameter"`

	// The time at which the expansion was produced by the expanding system.
	Timestamp *fhir.DateTime `fhirpath:"timestamp"`

	// The total number of concepts in the expansion. If the number of concept
	// nodes in this resource is less than the stated number, then the server can
	// return more using the offset parameter.
	Total *fhir.Integer `fhirpath:"total"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetContains returns the value of the field Contains.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetContains() []*ValueSetExpansionContains {
	if vse == nil {
		return nil
	}
	return vse.Contains
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetExtension() []*fhir.Extension {
	if vse == nil {
		return nil
	}
	return vse.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetID() string {
	if vse == nil {
		return ""
	}
	return vse.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetIdentifier() *fhir.URI {
	if vse == nil {
		return nil
	}
	return vse.Identifier
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetModifierExtension() []*fhir.Extension {
	if vse == nil {
		return nil
	}
	return vse.ModifierExtension
}

// GetOffset returns the value of the field Offset.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetOffset() *fhir.Integer {
	if vse == nil {
		return nil
	}
	return vse.Offset
}

// GetParameter returns the value of the field Parameter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetParameter() []*ValueSetExpansionParameter {
	if vse == nil {
		return nil
	}
	return vse.Parameter
}

// GetTimestamp returns the value of the field Timestamp.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetTimestamp() *fhir.DateTime {
	if vse == nil {
		return nil
	}
	return vse.Timestamp
}

// GetTotal returns the value of the field Total.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vse *ValueSetExpansion) GetTotal() *fhir.Integer {
	if vse == nil {
		return nil
	}
	return vse.Total
}

// Codes in the value set// The codes that are contained in the value set expansion.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetExpansionContains struct {

	// If true, this entry is included in the expansion for navigational purposes,
	// and the user cannot select the code directly as a proper value.
	Abstract *fhir.Boolean `fhirpath:"abstract"`

	// The code for this item in the expansion hierarchy. If this code is missing
	// the entry in the hierarchy is a place holder (abstract) and does not
	// represent a valid code in the value set.
	Code *fhir.Code `fhirpath:"code"`

	// The recommended display for this item in the expansion.
	Display *fhir.String `fhirpath:"display"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// If the concept is inactive in the code system that defines it. Inactive
	// codes are those that are no longer to be used, but are maintained by the
	// code system for understanding legacy data. It might not be known or
	// specified whether an concept is inactive (and it may depend on the context
	// of use).
	Inactive *fhir.Boolean `fhirpath:"inactive"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// An absolute URI which is the code system in which the code for this item in
	// the expansion is defined.
	System *fhir.URI `fhirpath:"system"`

	// The version of the code system from this code was taken. Note that a
	// well-maintained code system does not need the version reported, because the
	// meaning of codes is consistent across versions. However this cannot
	// consistently be assured, and when the meaning is not guaranteed to be
	// consistent, the version SHOULD be exchanged.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAbstract returns the value of the field Abstract.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetAbstract() *fhir.Boolean {
	if vsec == nil {
		return nil
	}
	return vsec.Abstract
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetCode() *fhir.Code {
	if vsec == nil {
		return nil
	}
	return vsec.Code
}

// GetDisplay returns the value of the field Display.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetDisplay() *fhir.String {
	if vsec == nil {
		return nil
	}
	return vsec.Display
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetExtension() []*fhir.Extension {
	if vsec == nil {
		return nil
	}
	return vsec.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetID() string {
	if vsec == nil {
		return ""
	}
	return vsec.ID
}

// GetInactive returns the value of the field Inactive.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetInactive() *fhir.Boolean {
	if vsec == nil {
		return nil
	}
	return vsec.Inactive
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetModifierExtension() []*fhir.Extension {
	if vsec == nil {
		return nil
	}
	return vsec.ModifierExtension
}

// GetSystem returns the value of the field System.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetSystem() *fhir.URI {
	if vsec == nil {
		return nil
	}
	return vsec.System
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsec *ValueSetExpansionContains) GetVersion() *fhir.String {
	if vsec == nil {
		return nil
	}
	return vsec.Version
}

// Parameter that controlled the expansion process// A parameter that controlled the expansion process. These parameters may be
// used by users of expanded value sets to check whether the expansion is
// suitable for a particular purpose, or to pick the correct expansion.// The server decides which parameters to include here, but at a minimum, the
// list SHOULD include all of the parameters that affect the $expand operation.
// If the expansion will be persisted all of these parameters SHALL be
// included. If the codeSystem on the server has a specified version then this
// version SHALL be provided as a parameter in the expansion (note that not all
// code systems have a version).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ValueSet.json
type ValueSetExpansionParameter struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Name of the input parameter to the $expand operation; may be a
	// server-assigned name for additional default or other server-supplied
	// parameters used to control the expansion process.
	Name *fhir.String `fhirpath:"name"`

	// The value of the parameter.
	Value fhir.Element `fhirpath:"value"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsep *ValueSetExpansionParameter) GetExtension() []*fhir.Extension {
	if vsep == nil {
		return nil
	}
	return vsep.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsep *ValueSetExpansionParameter) GetID() string {
	if vsep == nil {
		return ""
	}
	return vsep.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsep *ValueSetExpansionParameter) GetModifierExtension() []*fhir.Extension {
	if vsep == nil {
		return nil
	}
	return vsep.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsep *ValueSetExpansionParameter) GetName() *fhir.String {
	if vsep == nil {
		return nil
	}
	return vsep.Name
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (vsep *ValueSetExpansionParameter) GetValue() fhir.Element {
	if vsep == nil {
		return nil
	}
	return vsep.Value
}

// GetValueString returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueString() *fhir.String {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.String)
	if !ok {
		return nil
	}
	return val
}

// GetValueBoolean returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueBoolean() *fhir.Boolean {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetValueInteger returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueInteger() *fhir.Integer {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.Integer)
	if !ok {
		return nil
	}
	return val
}

// GetValueDecimal returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueDecimal() *fhir.Decimal {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetValueURI returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueURI() *fhir.URI {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.URI)
	if !ok {
		return nil
	}
	return val
}

// GetValueCode returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueCode() *fhir.Code {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.Code)
	if !ok {
		return nil
	}
	return val
}

// GetValueDateTime returns the value of the field Value.
func (vsep *ValueSetExpansionParameter) GetValueDateTime() *fhir.DateTime {
	if vsep == nil {
		return nil
	}
	val, ok := vsep.Value.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}
