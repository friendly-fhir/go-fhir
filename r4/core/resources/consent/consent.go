// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package consent

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// A record of a healthcare consumerâ€™s choices, which permits or denies
// identified recipient(s) or recipient role(s) to perform one or more actions
// within a given policy context, for specific purposes and periods of time.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Consent
//   - Source File: StructureDefinition-Consent.json
type Consent struct {

	// A classification of the type of consents found in the statement. This
	// element supports indexing and retrieval of consent statements.
	Category []*fhir.CodeableConcept `fhirpath:"category"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// When this Consent was issued / created / indexed.
	DateTime *fhir.DateTime `fhirpath:"dateTime"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Unique identifier for this copy of the Consent Statement.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The organization that manages the consent, and the framework within which it
	// is executed.
	Organization []*fhir.Reference `fhirpath:"organization"`

	// The patient/healthcare consumer to whom this consent applies.
	Patient *fhir.Reference `fhirpath:"patient"`

	// Either the Grantor, which is the entity responsible for granting the rights
	// listed in a Consent Directive or the Grantee, which is the entity
	// responsible for complying with the Consent Directive, including any
	// obligations or limitations on authorizations and enforcement of
	// prohibitions.
	Performer []*fhir.Reference `fhirpath:"performer"`

	// The references to the policies that are included in this consent scope.
	// Policies may be organizational, but are often defined jurisdictionally, or
	// in law.
	Policy []*ConsentPolicy `fhirpath:"policy"`

	// A reference to the specific base computable regulation or policy.
	PolicyRule *fhir.CodeableConcept `fhirpath:"policyRule"`

	// An exception to the base policy of this consent. An exception can be an
	// addition or removal of access permissions.
	Provision *ConsentProvision `fhirpath:"provision"`

	// A selector of the type of consent being presented: ADR, Privacy, Treatment,
	// Research. This list is now extensible.
	Scope *fhir.CodeableConcept `fhirpath:"scope"`

	// The source on which this consent statement is based. The source might be a
	// scanned original paper form, or a reference to a consent that links back to
	// such a source, a reference to a document repository (e.g. XDS) that stores
	// the original consent document.
	Source fhir.Element `fhirpath:"source"`

	// Indicates the current state of this consent.
	Status *fhir.Code `fhirpath:"status"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// Whether a treatment instruction (e.g. artificial respiration yes or no) was
	// verified with the patient, his/her family or another authorized person.
	Verification []*ConsentVerification `fhirpath:"verification"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetCategory() []*fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.Category
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetContained() []fhir.Resource {
	if c == nil {
		return nil
	}
	return c.Contained
}

// GetDateTime returns the value of the field DateTime.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetDateTime() *fhir.DateTime {
	if c == nil {
		return nil
	}
	return c.DateTime
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetExtension() []*fhir.Extension {
	if c == nil {
		return nil
	}
	return c.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetIdentifier() []*fhir.Identifier {
	if c == nil {
		return nil
	}
	return c.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetImplicitRules() *fhir.URI {
	if c == nil {
		return nil
	}
	return c.ImplicitRules
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetLanguage() *fhir.Code {
	if c == nil {
		return nil
	}
	return c.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetMeta() *fhir.Meta {
	if c == nil {
		return nil
	}
	return c.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetModifierExtension() []*fhir.Extension {
	if c == nil {
		return nil
	}
	return c.ModifierExtension
}

// GetOrganization returns the value of the field Organization.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetOrganization() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Organization
}

// GetPatient returns the value of the field Patient.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetPatient() *fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Patient
}

// GetPerformer returns the value of the field Performer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetPerformer() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Performer
}

// GetPolicy returns the value of the field Policy.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetPolicy() []*ConsentPolicy {
	if c == nil {
		return nil
	}
	return c.Policy
}

// GetPolicyRule returns the value of the field PolicyRule.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetPolicyRule() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.PolicyRule
}

// GetProvision returns the value of the field Provision.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetProvision() *ConsentProvision {
	if c == nil {
		return nil
	}
	return c.Provision
}

// GetScope returns the value of the field Scope.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetScope() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.Scope
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetSource() fhir.Element {
	if c == nil {
		return nil
	}
	return c.Source
}

// GetSourceAttachment returns the value of the field Source.
func (c *Consent) GetSourceAttachment() *fhir.Attachment {
	if c == nil {
		return nil
	}
	val, ok := c.Source.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetSourceReference returns the value of the field Source.
func (c *Consent) GetSourceReference() *fhir.Reference {
	if c == nil {
		return nil
	}
	val, ok := c.Source.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetStatus() *fhir.Code {
	if c == nil {
		return nil
	}
	return c.Status
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetText() *fhir.Narrative {
	if c == nil {
		return nil
	}
	return c.Text
}

// GetVerification returns the value of the field Verification.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Consent) GetVerification() []*ConsentVerification {
	if c == nil {
		return nil
	}
	return c.Verification
}

// Policies covered by this consent// The references to the policies that are included in this consent scope.
// Policies may be organizational, but are often defined jurisdictionally, or
// in law.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Consent.json
type ConsentPolicy struct {

	// Entity or Organization having regulatory jurisdiction or accountability for
	// enforcing policies pertaining to Consent Directives.
	Authority *fhir.URI `fhirpath:"authority"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The references to the policies that are included in this consent scope.
	// Policies may be organizational, but are often defined jurisdictionally, or
	// in law.
	URI *fhir.URI `fhirpath:"uri"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAuthority returns the value of the field Authority.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentPolicy) GetAuthority() *fhir.URI {
	if cp == nil {
		return nil
	}
	return cp.Authority
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentPolicy) GetExtension() []*fhir.Extension {
	if cp == nil {
		return nil
	}
	return cp.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentPolicy) GetID() string {
	if cp == nil {
		return ""
	}
	return cp.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentPolicy) GetModifierExtension() []*fhir.Extension {
	if cp == nil {
		return nil
	}
	return cp.ModifierExtension
}

// GetURI returns the value of the field URI.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentPolicy) GetURI() *fhir.URI {
	if cp == nil {
		return nil
	}
	return cp.URI
}

// Constraints to the base Consent.policyRule// An exception to the base policy of this consent. An exception can be an
// addition or removal of access permissions.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Consent.json
type ConsentProvision struct {

	// Actions controlled by this Rule.
	Action []*fhir.CodeableConcept `fhirpath:"action"`

	// Who or what is controlled by this rule. Use group to identify a set of
	// actors by some property they share (e.g. 'admitting officers').
	Actor []*ConsentProvisionActor `fhirpath:"actor"`

	// The class of information covered by this rule. The type can be a FHIR
	// resource type, a profile on a type, or a CDA document, or some other type
	// that indicates what sort of information the consent relates to.
	Class []*fhir.Coding `fhirpath:"class"`

	// If this code is found in an instance, then the rule applies.
	Code []*fhir.CodeableConcept `fhirpath:"code"`

	// The resources controlled by this rule if specific resources are referenced.
	Data []*ConsentProvisionData `fhirpath:"data"`

	// Clinical or Operational Relevant period of time that bounds the data
	// controlled by this rule.
	DataPeriod *fhir.Period `fhirpath:"dataPeriod"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The timeframe in this rule is valid.
	Period *fhir.Period `fhirpath:"period"`

	// The context of the activities a user is taking - why the user is accessing
	// the data - that are controlled by this rule.
	Purpose []*fhir.Coding `fhirpath:"purpose"`

	// A security label, comprised of 0..* security label fields (Privacy tags),
	// which define which resources are controlled by this exception.
	SecurityLabel []*fhir.Coding `fhirpath:"securityLabel"`

	// Action to take - permit or deny - when the rule conditions are met. Not
	// permitted in root rule, required in all nested rules.
	Type *fhir.Code `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAction returns the value of the field Action.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetAction() []*fhir.CodeableConcept {
	if cp == nil {
		return nil
	}
	return cp.Action
}

// GetActor returns the value of the field Actor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetActor() []*ConsentProvisionActor {
	if cp == nil {
		return nil
	}
	return cp.Actor
}

// GetClass returns the value of the field Class.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetClass() []*fhir.Coding {
	if cp == nil {
		return nil
	}
	return cp.Class
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetCode() []*fhir.CodeableConcept {
	if cp == nil {
		return nil
	}
	return cp.Code
}

// GetData returns the value of the field Data.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetData() []*ConsentProvisionData {
	if cp == nil {
		return nil
	}
	return cp.Data
}

// GetDataPeriod returns the value of the field DataPeriod.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetDataPeriod() *fhir.Period {
	if cp == nil {
		return nil
	}
	return cp.DataPeriod
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetExtension() []*fhir.Extension {
	if cp == nil {
		return nil
	}
	return cp.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetID() string {
	if cp == nil {
		return ""
	}
	return cp.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetModifierExtension() []*fhir.Extension {
	if cp == nil {
		return nil
	}
	return cp.ModifierExtension
}

// GetPeriod returns the value of the field Period.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetPeriod() *fhir.Period {
	if cp == nil {
		return nil
	}
	return cp.Period
}

// GetPurpose returns the value of the field Purpose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetPurpose() []*fhir.Coding {
	if cp == nil {
		return nil
	}
	return cp.Purpose
}

// GetSecurityLabel returns the value of the field SecurityLabel.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetSecurityLabel() []*fhir.Coding {
	if cp == nil {
		return nil
	}
	return cp.SecurityLabel
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cp *ConsentProvision) GetType() *fhir.Code {
	if cp == nil {
		return nil
	}
	return cp.Type
}

// Who|what controlled by this rule (or group, by role)// Who or what is controlled by this rule. Use group to identify a set of
// actors by some property they share (e.g. 'admitting officers').
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Consent.json
type ConsentProvisionActor struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The resource that identifies the actor. To identify actors by type, use
	// group to identify a set of actors by some property they share (e.g.
	// 'admitting officers').
	Reference *fhir.Reference `fhirpath:"reference"`

	// How the individual is involved in the resources content that is described in
	// the exception.
	Role *fhir.CodeableConcept `fhirpath:"role"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpa *ConsentProvisionActor) GetExtension() []*fhir.Extension {
	if cpa == nil {
		return nil
	}
	return cpa.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpa *ConsentProvisionActor) GetID() string {
	if cpa == nil {
		return ""
	}
	return cpa.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpa *ConsentProvisionActor) GetModifierExtension() []*fhir.Extension {
	if cpa == nil {
		return nil
	}
	return cpa.ModifierExtension
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpa *ConsentProvisionActor) GetReference() *fhir.Reference {
	if cpa == nil {
		return nil
	}
	return cpa.Reference
}

// GetRole returns the value of the field Role.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpa *ConsentProvisionActor) GetRole() *fhir.CodeableConcept {
	if cpa == nil {
		return nil
	}
	return cpa.Role
}

// Data controlled by this rule// The resources controlled by this rule if specific resources are referenced.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Consent.json
type ConsentProvisionData struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// How the resource reference is interpreted when testing consent restrictions.
	Meaning *fhir.Code `fhirpath:"meaning"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A reference to a specific resource that defines which resources are covered
	// by this consent.
	Reference *fhir.Reference `fhirpath:"reference"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpd *ConsentProvisionData) GetExtension() []*fhir.Extension {
	if cpd == nil {
		return nil
	}
	return cpd.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpd *ConsentProvisionData) GetID() string {
	if cpd == nil {
		return ""
	}
	return cpd.ID
}

// GetMeaning returns the value of the field Meaning.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpd *ConsentProvisionData) GetMeaning() *fhir.Code {
	if cpd == nil {
		return nil
	}
	return cpd.Meaning
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpd *ConsentProvisionData) GetModifierExtension() []*fhir.Extension {
	if cpd == nil {
		return nil
	}
	return cpd.ModifierExtension
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cpd *ConsentProvisionData) GetReference() *fhir.Reference {
	if cpd == nil {
		return nil
	}
	return cpd.Reference
}

// Consent Verified by patient or family// Whether a treatment instruction (e.g. artificial respiration yes or no) was
// verified with the patient, his/her family or another authorized person.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Consent.json
type ConsentVerification struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Date verification was collected.
	VerificationDate *fhir.DateTime `fhirpath:"verificationDate"`

	// Has the instruction been verified.
	Verified *fhir.Boolean `fhirpath:"verified"`

	// Who verified the instruction (Patient, Relative or other Authorized Person).
	VerifiedWith *fhir.Reference `fhirpath:"verifiedWith"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetExtension() []*fhir.Extension {
	if cv == nil {
		return nil
	}
	return cv.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetID() string {
	if cv == nil {
		return ""
	}
	return cv.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetModifierExtension() []*fhir.Extension {
	if cv == nil {
		return nil
	}
	return cv.ModifierExtension
}

// GetVerificationDate returns the value of the field VerificationDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetVerificationDate() *fhir.DateTime {
	if cv == nil {
		return nil
	}
	return cv.VerificationDate
}

// GetVerified returns the value of the field Verified.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetVerified() *fhir.Boolean {
	if cv == nil {
		return nil
	}
	return cv.Verified
}

// GetVerifiedWith returns the value of the field VerifiedWith.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cv *ConsentVerification) GetVerifiedWith() *fhir.Reference {
	if cv == nil {
		return nil
	}
	return cv.VerifiedWith
}

func (c *Consent) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (c *Consent) UnmarshalJSON(data []byte) error {
	var raw struct {
		Category  []*fhir.CodeableConcept `json:"category"`
		Contained []fhir.Resource         `json:"contained"`
		DateTime  *fhir.DateTime          `json:"dateTime"`
		Extension []*fhir.Extension       `json:"extension"`

		ID                string                 `json:"id"`
		Identifier        []*fhir.Identifier     `json:"identifier"`
		ImplicitRules     *fhir.URI              `json:"implicitRules"`
		Language          *fhir.Code             `json:"language"`
		Meta              *fhir.Meta             `json:"meta"`
		ModifierExtension []*fhir.Extension      `json:"modifierExtension"`
		Organization      []*fhir.Reference      `json:"organization"`
		Patient           *fhir.Reference        `json:"patient"`
		Performer         []*fhir.Reference      `json:"performer"`
		Policy            []*ConsentPolicy       `json:"policy"`
		PolicyRule        *fhir.CodeableConcept  `json:"policyRule"`
		Provision         *ConsentProvision      `json:"provision"`
		Scope             *fhir.CodeableConcept  `json:"scope"`
		SourceAttachment  *fhir.Attachment       `json:"sourceAttachment"`
		SourceReference   *fhir.Reference        `json:"sourceReference"`
		Status            *fhir.Code             `json:"status"`
		Text              *fhir.Narrative        `json:"text"`
		Verification      []*ConsentVerification `json:"verification"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	c.Category = raw.Category
	c.Contained = raw.Contained
	c.DateTime = raw.DateTime
	c.Extension = raw.Extension
	c.ID = raw.ID
	c.Identifier = raw.Identifier
	c.ImplicitRules = raw.ImplicitRules
	c.Language = raw.Language
	c.Meta = raw.Meta
	c.ModifierExtension = raw.ModifierExtension
	c.Organization = raw.Organization
	c.Patient = raw.Patient
	c.Performer = raw.Performer
	c.Policy = raw.Policy
	c.PolicyRule = raw.PolicyRule
	c.Provision = raw.Provision
	c.Scope = raw.Scope
	c.Source, err = validate.SelectOneOf[fhir.Element]("Consent.source",
		raw.SourceAttachment,
		raw.SourceReference)
	if err != nil {
		return err
	}
	c.Status = raw.Status
	c.Text = raw.Text
	c.Verification = raw.Verification
	return nil
}

var _ json.Marshaler = (*Consent)(nil)
var _ json.Unmarshaler = (*Consent)(nil)

func (cp *ConsentPolicy) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cp *ConsentPolicy) UnmarshalJSON(data []byte) error {
	var raw struct {
		Authority *fhir.URI         `json:"authority"`
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		URI               *fhir.URI         `json:"uri"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cp.Authority = raw.Authority
	cp.Extension = raw.Extension
	cp.ID = raw.ID
	cp.ModifierExtension = raw.ModifierExtension
	cp.URI = raw.URI
	return nil
}

var _ json.Marshaler = (*ConsentPolicy)(nil)
var _ json.Unmarshaler = (*ConsentPolicy)(nil)

func (cp *ConsentProvision) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cp *ConsentProvision) UnmarshalJSON(data []byte) error {
	var raw struct {
		Action     []*fhir.CodeableConcept  `json:"action"`
		Actor      []*ConsentProvisionActor `json:"actor"`
		Class      []*fhir.Coding           `json:"class"`
		Code       []*fhir.CodeableConcept  `json:"code"`
		Data       []*ConsentProvisionData  `json:"data"`
		DataPeriod *fhir.Period             `json:"dataPeriod"`
		Extension  []*fhir.Extension        `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Period            *fhir.Period      `json:"period"`
		Purpose           []*fhir.Coding    `json:"purpose"`
		SecurityLabel     []*fhir.Coding    `json:"securityLabel"`
		Type              *fhir.Code        `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cp.Action = raw.Action
	cp.Actor = raw.Actor
	cp.Class = raw.Class
	cp.Code = raw.Code
	cp.Data = raw.Data
	cp.DataPeriod = raw.DataPeriod
	cp.Extension = raw.Extension
	cp.ID = raw.ID
	cp.ModifierExtension = raw.ModifierExtension
	cp.Period = raw.Period
	cp.Purpose = raw.Purpose
	cp.SecurityLabel = raw.SecurityLabel
	cp.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*ConsentProvision)(nil)
var _ json.Unmarshaler = (*ConsentProvision)(nil)

func (cpa *ConsentProvisionActor) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cpa *ConsentProvisionActor) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string                `json:"id"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Reference         *fhir.Reference       `json:"reference"`
		Role              *fhir.CodeableConcept `json:"role"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cpa.Extension = raw.Extension
	cpa.ID = raw.ID
	cpa.ModifierExtension = raw.ModifierExtension
	cpa.Reference = raw.Reference
	cpa.Role = raw.Role
	return nil
}

var _ json.Marshaler = (*ConsentProvisionActor)(nil)
var _ json.Unmarshaler = (*ConsentProvisionActor)(nil)

func (cpd *ConsentProvisionData) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cpd *ConsentProvisionData) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		Meaning           *fhir.Code        `json:"meaning"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Reference         *fhir.Reference   `json:"reference"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cpd.Extension = raw.Extension
	cpd.ID = raw.ID
	cpd.Meaning = raw.Meaning
	cpd.ModifierExtension = raw.ModifierExtension
	cpd.Reference = raw.Reference
	return nil
}

var _ json.Marshaler = (*ConsentProvisionData)(nil)
var _ json.Unmarshaler = (*ConsentProvisionData)(nil)

func (cv *ConsentVerification) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cv *ConsentVerification) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		VerificationDate  *fhir.DateTime    `json:"verificationDate"`
		Verified          *fhir.Boolean     `json:"verified"`
		VerifiedWith      *fhir.Reference   `json:"verifiedWith"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cv.Extension = raw.Extension
	cv.ID = raw.ID
	cv.ModifierExtension = raw.ModifierExtension
	cv.VerificationDate = raw.VerificationDate
	cv.Verified = raw.Verified
	cv.VerifiedWith = raw.VerifiedWith
	return nil
}

var _ json.Marshaler = (*ConsentVerification)(nil)
var _ json.Unmarshaler = (*ConsentVerification)(nil)
