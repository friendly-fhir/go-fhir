// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package terminologycapabilities

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// A TerminologyCapabilities resource documents a set of capabilities
// (behaviors) of a FHIR Terminology Server that may be used as a statement of
// actual server functionality or a statement of required or desired server
// implementation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/TerminologyCapabilities
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilities struct {

	// Whether the $closure operation is supported.
	Closure *TerminologyCapabilitiesClosure `fhirpath:"closure"`

	// The degree to which the server supports the code search parameter on
	// ValueSet, if it is supported.
	CodeSearch *fhir.Code `fhirpath:"codeSearch"`

	// Identifies a code system that is supported by the server. If there is a no
	// code system URL, then this declares the general assumptions a client can
	// make about support for any CodeSystem resource.
	CodeSystem []*TerminologyCapabilitiesCodeSystem `fhirpath:"codeSystem"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []*fhir.ContactDetail `fhirpath:"contact"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// A copyright statement relating to the terminology capabilities and/or its
	// contents. Copyright statements are generally legal restrictions on the use
	// and publishing of the terminology capabilities.
	Copyright *fhir.Markdown `fhirpath:"copyright"`

	// The date (and optionally time) when the terminology capabilities was
	// published. The date must change when the business version changes and it
	// must change if the status code changes. In addition, it should change when
	// the substantive content of the terminology capabilities changes.
	Date *fhir.DateTime `fhirpath:"date"`

	// A free text natural language description of the terminology capabilities
	// from a consumer's perspective. Typically, this is used when the capability
	// statement describes a desired rather than an actual solution, for example as
	// a formal expression of requirements as part of an RFP.
	Description *fhir.Markdown `fhirpath:"description"`

	// Information about the [ValueSet/$expand](valueset-operation-expand.html)
	// operation.
	Expansion *TerminologyCapabilitiesExpansion `fhirpath:"expansion"`

	// A Boolean value to indicate that this terminology capabilities is authored
	// for testing purposes (or education/evaluation/marketing) and is not intended
	// to be used for genuine usage.
	Experimental *fhir.Boolean `fhirpath:"experimental"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Identifies a specific implementation instance that is described by the
	// terminology capability statement - i.e. a particular installation, rather
	// than the capabilities of a software program.
	Implementation *TerminologyCapabilitiesImplementation `fhirpath:"implementation"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// A legal or geographic region in which the terminology capabilities is
	// intended to be used.
	Jurisdiction []*fhir.CodeableConcept `fhirpath:"jurisdiction"`

	// The way that this statement is intended to be used, to describe an actual
	// running instance of software, a particular product (kind, not instance of
	// software) or a class of implementation (e.g. a desired purchase).
	Kind *fhir.Code `fhirpath:"kind"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// Whether the server supports lockedDate.
	LockedDate *fhir.Boolean `fhirpath:"lockedDate"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A natural language name identifying the terminology capabilities. This name
	// should be usable as an identifier for the module by machine processing
	// applications such as code generation.
	Name *fhir.String `fhirpath:"name"`

	// The name of the organization or individual that published the terminology
	// capabilities.
	Publisher *fhir.String `fhirpath:"publisher"`

	// Explanation of why this terminology capabilities is needed and why it has
	// been designed as it has.
	Purpose *fhir.Markdown `fhirpath:"purpose"`

	// Software that is covered by this terminology capability statement. It is
	// used when the statement describes the capabilities of a particular software
	// version, independent of an installation.
	Software *TerminologyCapabilitiesSoftware `fhirpath:"software"`

	// The status of this terminology capabilities. Enables tracking the life-cycle
	// of the content.
	Status *fhir.Code `fhirpath:"status"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// A short, descriptive, user-friendly title for the terminology capabilities.
	Title *fhir.String `fhirpath:"title"`

	// Information about the
	// [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
	Translation *TerminologyCapabilitiesTranslation `fhirpath:"translation"`

	// An absolute URI that is used to identify this terminology capabilities when
	// it is referenced in a specification, model, design or an instance; also
	// called its canonical identifier. This SHOULD be globally unique and SHOULD
	// be a literal address at which at which an authoritative instance of this
	// terminology capabilities is (or will be) published. This URL can be the
	// target of a canonical reference. It SHALL remain the same when the
	// terminology capabilities is stored on different servers.
	URL *fhir.URI `fhirpath:"url"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...)
	// or may be references to specific programs (insurance plans, studies, ...)
	// and may be used to assist with indexing and searching for appropriate
	// terminology capabilities instances.
	UseContext []*fhir.UsageContext `fhirpath:"useContext"`

	// Information about the
	// [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
	ValidateCode *TerminologyCapabilitiesValidateCode `fhirpath:"validateCode"`

	// The identifier that is used to identify this version of the terminology
	// capabilities when it is referenced in a specification, model, design or
	// instance. This is an arbitrary value managed by the terminology capabilities
	// author and is not expected to be globally unique. For example, it might be a
	// timestamp (e.g. yyyymmdd) if a managed version is not available. There is
	// also no expectation that versions can be placed in a lexicographical
	// sequence.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetClosure returns the value of the field Closure.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetClosure() *TerminologyCapabilitiesClosure {
	if tc == nil {
		return nil
	}
	return tc.Closure
}

// GetCodeSearch returns the value of the field CodeSearch.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetCodeSearch() *fhir.Code {
	if tc == nil {
		return nil
	}
	return tc.CodeSearch
}

// GetCodeSystem returns the value of the field CodeSystem.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetCodeSystem() []*TerminologyCapabilitiesCodeSystem {
	if tc == nil {
		return nil
	}
	return tc.CodeSystem
}

// GetContact returns the value of the field Contact.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetContact() []*fhir.ContactDetail {
	if tc == nil {
		return nil
	}
	return tc.Contact
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetContained() []fhir.Resource {
	if tc == nil {
		return nil
	}
	return tc.Contained
}

// GetCopyright returns the value of the field Copyright.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetCopyright() *fhir.Markdown {
	if tc == nil {
		return nil
	}
	return tc.Copyright
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetDate() *fhir.DateTime {
	if tc == nil {
		return nil
	}
	return tc.Date
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetDescription() *fhir.Markdown {
	if tc == nil {
		return nil
	}
	return tc.Description
}

// GetExpansion returns the value of the field Expansion.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetExpansion() *TerminologyCapabilitiesExpansion {
	if tc == nil {
		return nil
	}
	return tc.Expansion
}

// GetExperimental returns the value of the field Experimental.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetExperimental() *fhir.Boolean {
	if tc == nil {
		return nil
	}
	return tc.Experimental
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetExtension() []*fhir.Extension {
	if tc == nil {
		return nil
	}
	return tc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetID() string {
	if tc == nil {
		return ""
	}
	return tc.ID
}

// GetImplementation returns the value of the field Implementation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetImplementation() *TerminologyCapabilitiesImplementation {
	if tc == nil {
		return nil
	}
	return tc.Implementation
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetImplicitRules() *fhir.URI {
	if tc == nil {
		return nil
	}
	return tc.ImplicitRules
}

// GetJurisdiction returns the value of the field Jurisdiction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetJurisdiction() []*fhir.CodeableConcept {
	if tc == nil {
		return nil
	}
	return tc.Jurisdiction
}

// GetKind returns the value of the field Kind.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetKind() *fhir.Code {
	if tc == nil {
		return nil
	}
	return tc.Kind
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetLanguage() *fhir.Code {
	if tc == nil {
		return nil
	}
	return tc.Language
}

// GetLockedDate returns the value of the field LockedDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetLockedDate() *fhir.Boolean {
	if tc == nil {
		return nil
	}
	return tc.LockedDate
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetMeta() *fhir.Meta {
	if tc == nil {
		return nil
	}
	return tc.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetModifierExtension() []*fhir.Extension {
	if tc == nil {
		return nil
	}
	return tc.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetName() *fhir.String {
	if tc == nil {
		return nil
	}
	return tc.Name
}

// GetPublisher returns the value of the field Publisher.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetPublisher() *fhir.String {
	if tc == nil {
		return nil
	}
	return tc.Publisher
}

// GetPurpose returns the value of the field Purpose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetPurpose() *fhir.Markdown {
	if tc == nil {
		return nil
	}
	return tc.Purpose
}

// GetSoftware returns the value of the field Software.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetSoftware() *TerminologyCapabilitiesSoftware {
	if tc == nil {
		return nil
	}
	return tc.Software
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetStatus() *fhir.Code {
	if tc == nil {
		return nil
	}
	return tc.Status
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetText() *fhir.Narrative {
	if tc == nil {
		return nil
	}
	return tc.Text
}

// GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetTitle() *fhir.String {
	if tc == nil {
		return nil
	}
	return tc.Title
}

// GetTranslation returns the value of the field Translation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetTranslation() *TerminologyCapabilitiesTranslation {
	if tc == nil {
		return nil
	}
	return tc.Translation
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetURL() *fhir.URI {
	if tc == nil {
		return nil
	}
	return tc.URL
}

// GetUseContext returns the value of the field UseContext.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetUseContext() []*fhir.UsageContext {
	if tc == nil {
		return nil
	}
	return tc.UseContext
}

// GetValidateCode returns the value of the field ValidateCode.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetValidateCode() *TerminologyCapabilitiesValidateCode {
	if tc == nil {
		return nil
	}
	return tc.ValidateCode
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tc *TerminologyCapabilities) GetVersion() *fhir.String {
	if tc == nil {
		return nil
	}
	return tc.Version
}

// Information about the
// [ConceptMap/$closure](conceptmap-operation-closure.html) operation// Whether the $closure operation is supported.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesClosure struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// If cross-system closure is supported.
	Translation *fhir.Boolean `fhirpath:"translation"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcc *TerminologyCapabilitiesClosure) GetExtension() []*fhir.Extension {
	if tcc == nil {
		return nil
	}
	return tcc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcc *TerminologyCapabilitiesClosure) GetID() string {
	if tcc == nil {
		return ""
	}
	return tcc.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcc *TerminologyCapabilitiesClosure) GetModifierExtension() []*fhir.Extension {
	if tcc == nil {
		return nil
	}
	return tcc.ModifierExtension
}

// GetTranslation returns the value of the field Translation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcc *TerminologyCapabilitiesClosure) GetTranslation() *fhir.Boolean {
	if tcc == nil {
		return nil
	}
	return tcc.Translation
}

// A code system supported by the server// Identifies a code system that is supported by the server. If there is a no
// code system URL, then this declares the general assumptions a client can
// make about support for any CodeSystem resource.// The code system - identified by its system URL - may also be declared
// explicitly as a Code System Resource at /CodeSystem, but it might not be.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesCodeSystem struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// True if subsumption is supported for this version of the code system.
	Subsumption *fhir.Boolean `fhirpath:"subsumption"`

	// URI for the Code System.
	URI *fhir.Canonical `fhirpath:"uri"`

	// For the code system, a list of versions that are supported by the server.
	Version []*TerminologyCapabilitiesCodeSystemVersion `fhirpath:"version"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetExtension() []*fhir.Extension {
	if tccs == nil {
		return nil
	}
	return tccs.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetID() string {
	if tccs == nil {
		return ""
	}
	return tccs.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetModifierExtension() []*fhir.Extension {
	if tccs == nil {
		return nil
	}
	return tccs.ModifierExtension
}

// GetSubsumption returns the value of the field Subsumption.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetSubsumption() *fhir.Boolean {
	if tccs == nil {
		return nil
	}
	return tccs.Subsumption
}

// GetURI returns the value of the field URI.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetURI() *fhir.Canonical {
	if tccs == nil {
		return nil
	}
	return tccs.URI
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccs *TerminologyCapabilitiesCodeSystem) GetVersion() []*TerminologyCapabilitiesCodeSystemVersion {
	if tccs == nil {
		return nil
	}
	return tccs.Version
}

// Version of Code System supported// For the code system, a list of versions that are supported by the server.// Language translations might not be available for all codes.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesCodeSystemVersion struct {

	// For version-less code systems, there should be a single version with no
	// identifier.
	Code *fhir.String `fhirpath:"code"`

	// If the compositional grammar defined by the code system is supported.
	Compositional *fhir.Boolean `fhirpath:"compositional"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Filter Properties supported.
	Filter []*TerminologyCapabilitiesCodeSystemVersionFilter `fhirpath:"filter"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// If this is the default version for this code system.
	IsDefault *fhir.Boolean `fhirpath:"isDefault"`

	// Language Displays supported.
	Language []*fhir.Code `fhirpath:"language"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Properties supported for $lookup.
	Property []*fhir.Code `fhirpath:"property"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetCode() *fhir.String {
	if tccsv == nil {
		return nil
	}
	return tccsv.Code
}

// GetCompositional returns the value of the field Compositional.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetCompositional() *fhir.Boolean {
	if tccsv == nil {
		return nil
	}
	return tccsv.Compositional
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetExtension() []*fhir.Extension {
	if tccsv == nil {
		return nil
	}
	return tccsv.Extension
}

// GetFilter returns the value of the field Filter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetFilter() []*TerminologyCapabilitiesCodeSystemVersionFilter {
	if tccsv == nil {
		return nil
	}
	return tccsv.Filter
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetID() string {
	if tccsv == nil {
		return ""
	}
	return tccsv.ID
}

// GetIsDefault returns the value of the field IsDefault.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetIsDefault() *fhir.Boolean {
	if tccsv == nil {
		return nil
	}
	return tccsv.IsDefault
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetLanguage() []*fhir.Code {
	if tccsv == nil {
		return nil
	}
	return tccsv.Language
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetModifierExtension() []*fhir.Extension {
	if tccsv == nil {
		return nil
	}
	return tccsv.ModifierExtension
}

// GetProperty returns the value of the field Property.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsv *TerminologyCapabilitiesCodeSystemVersion) GetProperty() []*fhir.Code {
	if tccsv == nil {
		return nil
	}
	return tccsv.Property
}

// Filter Properties supported// Filter Properties supported.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesCodeSystemVersionFilter struct {

	// Code of the property supported.
	Code *fhir.Code `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Operations supported for the property.
	Op []*fhir.Code `fhirpath:"op"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) GetCode() *fhir.Code {
	if tccsvf == nil {
		return nil
	}
	return tccsvf.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) GetExtension() []*fhir.Extension {
	if tccsvf == nil {
		return nil
	}
	return tccsvf.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) GetID() string {
	if tccsvf == nil {
		return ""
	}
	return tccsvf.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) GetModifierExtension() []*fhir.Extension {
	if tccsvf == nil {
		return nil
	}
	return tccsvf.ModifierExtension
}

// GetOp returns the value of the field Op.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) GetOp() []*fhir.Code {
	if tccsvf == nil {
		return nil
	}
	return tccsvf.Op
}

// Information about the [ValueSet/$expand](valueset-operation-expand.html)
// operation// Information about the [ValueSet/$expand](valueset-operation-expand.html)
// operation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesExpansion struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Whether the server can return nested value sets.
	Hierarchical *fhir.Boolean `fhirpath:"hierarchical"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Allow request for incomplete expansions?
	Incomplete *fhir.Boolean `fhirpath:"incomplete"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Whether the server supports paging on expansion.
	Paging *fhir.Boolean `fhirpath:"paging"`

	// Supported expansion parameter.
	Parameter []*TerminologyCapabilitiesExpansionParameter `fhirpath:"parameter"`

	// Documentation about text searching works.
	TextFilter *fhir.Markdown `fhirpath:"textFilter"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetExtension() []*fhir.Extension {
	if tce == nil {
		return nil
	}
	return tce.Extension
}

// GetHierarchical returns the value of the field Hierarchical.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetHierarchical() *fhir.Boolean {
	if tce == nil {
		return nil
	}
	return tce.Hierarchical
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetID() string {
	if tce == nil {
		return ""
	}
	return tce.ID
}

// GetIncomplete returns the value of the field Incomplete.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetIncomplete() *fhir.Boolean {
	if tce == nil {
		return nil
	}
	return tce.Incomplete
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetModifierExtension() []*fhir.Extension {
	if tce == nil {
		return nil
	}
	return tce.ModifierExtension
}

// GetPaging returns the value of the field Paging.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetPaging() *fhir.Boolean {
	if tce == nil {
		return nil
	}
	return tce.Paging
}

// GetParameter returns the value of the field Parameter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetParameter() []*TerminologyCapabilitiesExpansionParameter {
	if tce == nil {
		return nil
	}
	return tce.Parameter
}

// GetTextFilter returns the value of the field TextFilter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tce *TerminologyCapabilitiesExpansion) GetTextFilter() *fhir.Markdown {
	if tce == nil {
		return nil
	}
	return tce.TextFilter
}

// Supported expansion parameter// Supported expansion parameter.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesExpansionParameter struct {

	// Description of support for parameter.
	Documentation *fhir.String `fhirpath:"documentation"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Expansion Parameter name.
	Name *fhir.Code `fhirpath:"name"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetDocumentation returns the value of the field Documentation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcep *TerminologyCapabilitiesExpansionParameter) GetDocumentation() *fhir.String {
	if tcep == nil {
		return nil
	}
	return tcep.Documentation
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcep *TerminologyCapabilitiesExpansionParameter) GetExtension() []*fhir.Extension {
	if tcep == nil {
		return nil
	}
	return tcep.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcep *TerminologyCapabilitiesExpansionParameter) GetID() string {
	if tcep == nil {
		return ""
	}
	return tcep.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcep *TerminologyCapabilitiesExpansionParameter) GetModifierExtension() []*fhir.Extension {
	if tcep == nil {
		return nil
	}
	return tcep.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcep *TerminologyCapabilitiesExpansionParameter) GetName() *fhir.Code {
	if tcep == nil {
		return nil
	}
	return tcep.Name
}

// If this describes a specific instance// Identifies a specific implementation instance that is described by the
// terminology capability statement - i.e. a particular installation, rather
// than the capabilities of a software program.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesImplementation struct {

	// Information about the specific installation that this terminology capability
	// statement relates to.
	Description *fhir.String `fhirpath:"description"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// An absolute base URL for the implementation.
	URL *fhir.URL `fhirpath:"url"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tci *TerminologyCapabilitiesImplementation) GetDescription() *fhir.String {
	if tci == nil {
		return nil
	}
	return tci.Description
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tci *TerminologyCapabilitiesImplementation) GetExtension() []*fhir.Extension {
	if tci == nil {
		return nil
	}
	return tci.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tci *TerminologyCapabilitiesImplementation) GetID() string {
	if tci == nil {
		return ""
	}
	return tci.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tci *TerminologyCapabilitiesImplementation) GetModifierExtension() []*fhir.Extension {
	if tci == nil {
		return nil
	}
	return tci.ModifierExtension
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tci *TerminologyCapabilitiesImplementation) GetURL() *fhir.URL {
	if tci == nil {
		return nil
	}
	return tci.URL
}

// Software that is covered by this terminology capability statement// Software that is covered by this terminology capability statement. It is
// used when the statement describes the capabilities of a particular software
// version, independent of an installation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesSoftware struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Name the software is known by.
	Name *fhir.String `fhirpath:"name"`

	// The version identifier for the software covered by this statement.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcs *TerminologyCapabilitiesSoftware) GetExtension() []*fhir.Extension {
	if tcs == nil {
		return nil
	}
	return tcs.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcs *TerminologyCapabilitiesSoftware) GetID() string {
	if tcs == nil {
		return ""
	}
	return tcs.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcs *TerminologyCapabilitiesSoftware) GetModifierExtension() []*fhir.Extension {
	if tcs == nil {
		return nil
	}
	return tcs.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcs *TerminologyCapabilitiesSoftware) GetName() *fhir.String {
	if tcs == nil {
		return nil
	}
	return tcs.Name
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcs *TerminologyCapabilitiesSoftware) GetVersion() *fhir.String {
	if tcs == nil {
		return nil
	}
	return tcs.Version
}

// Information about the
// [ConceptMap/$translate](conceptmap-operation-translate.html) operation// Information about the
// [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesTranslation struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Whether the client must identify the map.
	NeedsMap *fhir.Boolean `fhirpath:"needsMap"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tct *TerminologyCapabilitiesTranslation) GetExtension() []*fhir.Extension {
	if tct == nil {
		return nil
	}
	return tct.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tct *TerminologyCapabilitiesTranslation) GetID() string {
	if tct == nil {
		return ""
	}
	return tct.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tct *TerminologyCapabilitiesTranslation) GetModifierExtension() []*fhir.Extension {
	if tct == nil {
		return nil
	}
	return tct.ModifierExtension
}

// GetNeedsMap returns the value of the field NeedsMap.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tct *TerminologyCapabilitiesTranslation) GetNeedsMap() *fhir.Boolean {
	if tct == nil {
		return nil
	}
	return tct.NeedsMap
}

// Information about the
// [ValueSet/$validate-code](valueset-operation-validate-code.html) operation// Information about the
// [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-TerminologyCapabilities.json
type TerminologyCapabilitiesValidateCode struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Whether translations are validated.
	Translations *fhir.Boolean `fhirpath:"translations"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcvc *TerminologyCapabilitiesValidateCode) GetExtension() []*fhir.Extension {
	if tcvc == nil {
		return nil
	}
	return tcvc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcvc *TerminologyCapabilitiesValidateCode) GetID() string {
	if tcvc == nil {
		return ""
	}
	return tcvc.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcvc *TerminologyCapabilitiesValidateCode) GetModifierExtension() []*fhir.Extension {
	if tcvc == nil {
		return nil
	}
	return tcvc.ModifierExtension
}

// GetTranslations returns the value of the field Translations.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (tcvc *TerminologyCapabilitiesValidateCode) GetTranslations() *fhir.Boolean {
	if tcvc == nil {
		return nil
	}
	return tcvc.Translations
}

func (tc *TerminologyCapabilities) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tc *TerminologyCapabilities) UnmarshalJSON(data []byte) error {
	var raw struct {
		Closure      *TerminologyCapabilitiesClosure      `json:"closure"`
		CodeSearch   *fhir.Code                           `json:"codeSearch"`
		CodeSystem   []*TerminologyCapabilitiesCodeSystem `json:"codeSystem"`
		Contact      []*fhir.ContactDetail                `json:"contact"`
		Contained    []fhir.Resource                      `json:"contained"`
		Copyright    *fhir.Markdown                       `json:"copyright"`
		Date         *fhir.DateTime                       `json:"date"`
		Description  *fhir.Markdown                       `json:"description"`
		Expansion    *TerminologyCapabilitiesExpansion    `json:"expansion"`
		Experimental *fhir.Boolean                        `json:"experimental"`
		Extension    []*fhir.Extension                    `json:"extension"`

		ID                string                                 `json:"id"`
		Implementation    *TerminologyCapabilitiesImplementation `json:"implementation"`
		ImplicitRules     *fhir.URI                              `json:"implicitRules"`
		Jurisdiction      []*fhir.CodeableConcept                `json:"jurisdiction"`
		Kind              *fhir.Code                             `json:"kind"`
		Language          *fhir.Code                             `json:"language"`
		LockedDate        *fhir.Boolean                          `json:"lockedDate"`
		Meta              *fhir.Meta                             `json:"meta"`
		ModifierExtension []*fhir.Extension                      `json:"modifierExtension"`
		Name              *fhir.String                           `json:"name"`
		Publisher         *fhir.String                           `json:"publisher"`
		Purpose           *fhir.Markdown                         `json:"purpose"`
		Software          *TerminologyCapabilitiesSoftware       `json:"software"`
		Status            *fhir.Code                             `json:"status"`
		Text              *fhir.Narrative                        `json:"text"`
		Title             *fhir.String                           `json:"title"`
		Translation       *TerminologyCapabilitiesTranslation    `json:"translation"`
		URL               *fhir.URI                              `json:"url"`
		UseContext        []*fhir.UsageContext                   `json:"useContext"`
		ValidateCode      *TerminologyCapabilitiesValidateCode   `json:"validateCode"`
		Version           *fhir.String                           `json:"version"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tc.Closure = raw.Closure
	tc.CodeSearch = raw.CodeSearch
	tc.CodeSystem = raw.CodeSystem
	tc.Contact = raw.Contact
	tc.Contained = raw.Contained
	tc.Copyright = raw.Copyright
	tc.Date = raw.Date
	tc.Description = raw.Description
	tc.Expansion = raw.Expansion
	tc.Experimental = raw.Experimental
	tc.Extension = raw.Extension
	tc.ID = raw.ID
	tc.Implementation = raw.Implementation
	tc.ImplicitRules = raw.ImplicitRules
	tc.Jurisdiction = raw.Jurisdiction
	tc.Kind = raw.Kind
	tc.Language = raw.Language
	tc.LockedDate = raw.LockedDate
	tc.Meta = raw.Meta
	tc.ModifierExtension = raw.ModifierExtension
	tc.Name = raw.Name
	tc.Publisher = raw.Publisher
	tc.Purpose = raw.Purpose
	tc.Software = raw.Software
	tc.Status = raw.Status
	tc.Text = raw.Text
	tc.Title = raw.Title
	tc.Translation = raw.Translation
	tc.URL = raw.URL
	tc.UseContext = raw.UseContext
	tc.ValidateCode = raw.ValidateCode
	tc.Version = raw.Version
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilities)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilities)(nil)

func (tcc *TerminologyCapabilitiesClosure) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tcc *TerminologyCapabilitiesClosure) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Translation       *fhir.Boolean     `json:"translation"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tcc.Extension = raw.Extension
	tcc.ID = raw.ID
	tcc.ModifierExtension = raw.ModifierExtension
	tcc.Translation = raw.Translation
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesClosure)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesClosure)(nil)

func (tccs *TerminologyCapabilitiesCodeSystem) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tccs *TerminologyCapabilitiesCodeSystem) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string                                      `json:"id"`
		ModifierExtension []*fhir.Extension                           `json:"modifierExtension"`
		Subsumption       *fhir.Boolean                               `json:"subsumption"`
		URI               *fhir.Canonical                             `json:"uri"`
		Version           []*TerminologyCapabilitiesCodeSystemVersion `json:"version"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tccs.Extension = raw.Extension
	tccs.ID = raw.ID
	tccs.ModifierExtension = raw.ModifierExtension
	tccs.Subsumption = raw.Subsumption
	tccs.URI = raw.URI
	tccs.Version = raw.Version
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesCodeSystem)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesCodeSystem)(nil)

func (tccsv *TerminologyCapabilitiesCodeSystemVersion) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tccsv *TerminologyCapabilitiesCodeSystemVersion) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code          *fhir.String                                      `json:"code"`
		Compositional *fhir.Boolean                                     `json:"compositional"`
		Extension     []*fhir.Extension                                 `json:"extension"`
		Filter        []*TerminologyCapabilitiesCodeSystemVersionFilter `json:"filter"`

		ID                string            `json:"id"`
		IsDefault         *fhir.Boolean     `json:"isDefault"`
		Language          []*fhir.Code      `json:"language"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Property          []*fhir.Code      `json:"property"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tccsv.Code = raw.Code
	tccsv.Compositional = raw.Compositional
	tccsv.Extension = raw.Extension
	tccsv.Filter = raw.Filter
	tccsv.ID = raw.ID
	tccsv.IsDefault = raw.IsDefault
	tccsv.Language = raw.Language
	tccsv.ModifierExtension = raw.ModifierExtension
	tccsv.Property = raw.Property
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesCodeSystemVersion)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesCodeSystemVersion)(nil)

func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tccsvf *TerminologyCapabilitiesCodeSystemVersionFilter) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code      *fhir.Code        `json:"code"`
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Op                []*fhir.Code      `json:"op"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tccsvf.Code = raw.Code
	tccsvf.Extension = raw.Extension
	tccsvf.ID = raw.ID
	tccsvf.ModifierExtension = raw.ModifierExtension
	tccsvf.Op = raw.Op
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesCodeSystemVersionFilter)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesCodeSystemVersionFilter)(nil)

func (tce *TerminologyCapabilitiesExpansion) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tce *TerminologyCapabilitiesExpansion) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension    []*fhir.Extension `json:"extension"`
		Hierarchical *fhir.Boolean     `json:"hierarchical"`

		ID                string                                       `json:"id"`
		Incomplete        *fhir.Boolean                                `json:"incomplete"`
		ModifierExtension []*fhir.Extension                            `json:"modifierExtension"`
		Paging            *fhir.Boolean                                `json:"paging"`
		Parameter         []*TerminologyCapabilitiesExpansionParameter `json:"parameter"`
		TextFilter        *fhir.Markdown                               `json:"textFilter"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tce.Extension = raw.Extension
	tce.Hierarchical = raw.Hierarchical
	tce.ID = raw.ID
	tce.Incomplete = raw.Incomplete
	tce.ModifierExtension = raw.ModifierExtension
	tce.Paging = raw.Paging
	tce.Parameter = raw.Parameter
	tce.TextFilter = raw.TextFilter
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesExpansion)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesExpansion)(nil)

func (tcep *TerminologyCapabilitiesExpansionParameter) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tcep *TerminologyCapabilitiesExpansionParameter) UnmarshalJSON(data []byte) error {
	var raw struct {
		Documentation *fhir.String      `json:"documentation"`
		Extension     []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Name              *fhir.Code        `json:"name"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tcep.Documentation = raw.Documentation
	tcep.Extension = raw.Extension
	tcep.ID = raw.ID
	tcep.ModifierExtension = raw.ModifierExtension
	tcep.Name = raw.Name
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesExpansionParameter)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesExpansionParameter)(nil)

func (tci *TerminologyCapabilitiesImplementation) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tci *TerminologyCapabilitiesImplementation) UnmarshalJSON(data []byte) error {
	var raw struct {
		Description *fhir.String      `json:"description"`
		Extension   []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		URL               *fhir.URL         `json:"url"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tci.Description = raw.Description
	tci.Extension = raw.Extension
	tci.ID = raw.ID
	tci.ModifierExtension = raw.ModifierExtension
	tci.URL = raw.URL
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesImplementation)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesImplementation)(nil)

func (tcs *TerminologyCapabilitiesSoftware) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tcs *TerminologyCapabilitiesSoftware) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Name              *fhir.String      `json:"name"`
		Version           *fhir.String      `json:"version"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tcs.Extension = raw.Extension
	tcs.ID = raw.ID
	tcs.ModifierExtension = raw.ModifierExtension
	tcs.Name = raw.Name
	tcs.Version = raw.Version
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesSoftware)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesSoftware)(nil)

func (tct *TerminologyCapabilitiesTranslation) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tct *TerminologyCapabilitiesTranslation) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		NeedsMap          *fhir.Boolean     `json:"needsMap"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tct.Extension = raw.Extension
	tct.ID = raw.ID
	tct.ModifierExtension = raw.ModifierExtension
	tct.NeedsMap = raw.NeedsMap
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesTranslation)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesTranslation)(nil)

func (tcvc *TerminologyCapabilitiesValidateCode) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (tcvc *TerminologyCapabilitiesValidateCode) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Translations      *fhir.Boolean     `json:"translations"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	tcvc.Extension = raw.Extension
	tcvc.ID = raw.ID
	tcvc.ModifierExtension = raw.ModifierExtension
	tcvc.Translations = raw.Translations
	return nil
}

var _ json.Marshaler = (*TerminologyCapabilitiesValidateCode)(nil)
var _ json.Unmarshaler = (*TerminologyCapabilitiesValidateCode)(nil)
