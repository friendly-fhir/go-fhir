// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package substancereferenceinformation

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Todo.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/SubstanceReferenceInformation
//   - Source File: StructureDefinition-SubstanceReferenceInformation.json
type SubstanceReferenceInformation struct {

	// Todo.
	Classification []*SubstanceReferenceInformationClassification `fhirpath:"classification"`

	// Todo.
	Comment *fhir.String `fhirpath:"comment"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Todo.
	Gene []*SubstanceReferenceInformationGene `fhirpath:"gene"`

	// Todo.
	GeneElement []*SubstanceReferenceInformationGeneElement `fhirpath:"geneElement"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Todo.
	Target []*SubstanceReferenceInformationTarget `fhirpath:"target"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetClassification returns the value of the field Classification.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetClassification() []*SubstanceReferenceInformationClassification {
	if sri == nil {
		return nil
	}
	return sri.Classification
}

// GetComment returns the value of the field Comment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetComment() *fhir.String {
	if sri == nil {
		return nil
	}
	return sri.Comment
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetContained() []fhir.Resource {
	if sri == nil {
		return nil
	}
	return sri.Contained
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetExtension() []*fhir.Extension {
	if sri == nil {
		return nil
	}
	return sri.Extension
}

// GetGene returns the value of the field Gene.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetGene() []*SubstanceReferenceInformationGene {
	if sri == nil {
		return nil
	}
	return sri.Gene
}

// GetGeneElement returns the value of the field GeneElement.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetGeneElement() []*SubstanceReferenceInformationGeneElement {
	if sri == nil {
		return nil
	}
	return sri.GeneElement
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetID() string {
	if sri == nil {
		return ""
	}
	return sri.ID
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetImplicitRules() *fhir.URI {
	if sri == nil {
		return nil
	}
	return sri.ImplicitRules
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetLanguage() *fhir.Code {
	if sri == nil {
		return nil
	}
	return sri.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetMeta() *fhir.Meta {
	if sri == nil {
		return nil
	}
	return sri.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetModifierExtension() []*fhir.Extension {
	if sri == nil {
		return nil
	}
	return sri.ModifierExtension
}

// GetTarget returns the value of the field Target.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetTarget() []*SubstanceReferenceInformationTarget {
	if sri == nil {
		return nil
	}
	return sri.Target
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sri *SubstanceReferenceInformation) GetText() *fhir.Narrative {
	if sri == nil {
		return nil
	}
	return sri.Text
}

// Todo// Todo.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceReferenceInformation.json
type SubstanceReferenceInformationClassification struct {

	// Todo.
	Classification *fhir.CodeableConcept `fhirpath:"classification"`

	// Todo.
	Domain *fhir.CodeableConcept `fhirpath:"domain"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Todo.
	Source []*fhir.Reference `fhirpath:"source"`

	// Todo.
	Subtype []*fhir.CodeableConcept `fhirpath:"subtype"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetClassification returns the value of the field Classification.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetClassification() *fhir.CodeableConcept {
	if sric == nil {
		return nil
	}
	return sric.Classification
}

// GetDomain returns the value of the field Domain.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetDomain() *fhir.CodeableConcept {
	if sric == nil {
		return nil
	}
	return sric.Domain
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetExtension() []*fhir.Extension {
	if sric == nil {
		return nil
	}
	return sric.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetID() string {
	if sric == nil {
		return ""
	}
	return sric.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetModifierExtension() []*fhir.Extension {
	if sric == nil {
		return nil
	}
	return sric.ModifierExtension
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetSource() []*fhir.Reference {
	if sric == nil {
		return nil
	}
	return sric.Source
}

// GetSubtype returns the value of the field Subtype.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sric *SubstanceReferenceInformationClassification) GetSubtype() []*fhir.CodeableConcept {
	if sric == nil {
		return nil
	}
	return sric.Subtype
}

// Todo// Todo.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceReferenceInformation.json
type SubstanceReferenceInformationGene struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Todo.
	Gene *fhir.CodeableConcept `fhirpath:"gene"`

	// Todo.
	GeneSequenceOrigin *fhir.CodeableConcept `fhirpath:"geneSequenceOrigin"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Todo.
	Source []*fhir.Reference `fhirpath:"source"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetExtension() []*fhir.Extension {
	if srig == nil {
		return nil
	}
	return srig.Extension
}

// GetGene returns the value of the field Gene.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetGene() *fhir.CodeableConcept {
	if srig == nil {
		return nil
	}
	return srig.Gene
}

// GetGeneSequenceOrigin returns the value of the field GeneSequenceOrigin.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetGeneSequenceOrigin() *fhir.CodeableConcept {
	if srig == nil {
		return nil
	}
	return srig.GeneSequenceOrigin
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetID() string {
	if srig == nil {
		return ""
	}
	return srig.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetModifierExtension() []*fhir.Extension {
	if srig == nil {
		return nil
	}
	return srig.ModifierExtension
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srig *SubstanceReferenceInformationGene) GetSource() []*fhir.Reference {
	if srig == nil {
		return nil
	}
	return srig.Source
}

// Todo// Todo.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceReferenceInformation.json
type SubstanceReferenceInformationGeneElement struct {

	// Todo.
	Element *fhir.Identifier `fhirpath:"element"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Todo.
	Source []*fhir.Reference `fhirpath:"source"`

	// Todo.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetElement returns the value of the field Element.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetElement() *fhir.Identifier {
	if srige == nil {
		return nil
	}
	return srige.Element
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetExtension() []*fhir.Extension {
	if srige == nil {
		return nil
	}
	return srige.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetID() string {
	if srige == nil {
		return ""
	}
	return srige.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetModifierExtension() []*fhir.Extension {
	if srige == nil {
		return nil
	}
	return srige.ModifierExtension
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetSource() []*fhir.Reference {
	if srige == nil {
		return nil
	}
	return srige.Source
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srige *SubstanceReferenceInformationGeneElement) GetType() *fhir.CodeableConcept {
	if srige == nil {
		return nil
	}
	return srige.Type
}

// Todo// Todo.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceReferenceInformation.json
type SubstanceReferenceInformationTarget struct {

	// Todo.
	AmountType *fhir.CodeableConcept `fhirpath:"amountType"`

	// Todo.
	Amount fhir.Element `fhirpath:"amount"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Todo.
	Interaction *fhir.CodeableConcept `fhirpath:"interaction"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Todo.
	Organism *fhir.CodeableConcept `fhirpath:"organism"`

	// Todo.
	OrganismType *fhir.CodeableConcept `fhirpath:"organismType"`

	// Todo.
	Source []*fhir.Reference `fhirpath:"source"`

	// Todo.
	Target *fhir.Identifier `fhirpath:"target"`

	// Todo.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAmountType returns the value of the field AmountType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetAmountType() *fhir.CodeableConcept {
	if srit == nil {
		return nil
	}
	return srit.AmountType
}

// GetAmount returns the value of the field Amount.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetAmount() fhir.Element {
	if srit == nil {
		return nil
	}
	return srit.Amount
}

// GetAmountQuantity returns the value of the field Amount.
func (srit *SubstanceReferenceInformationTarget) GetAmountQuantity() *fhir.Quantity {
	if srit == nil {
		return nil
	}
	val, ok := srit.Amount.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetAmountRange returns the value of the field Amount.
func (srit *SubstanceReferenceInformationTarget) GetAmountRange() *fhir.Range {
	if srit == nil {
		return nil
	}
	val, ok := srit.Amount.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetAmountString returns the value of the field Amount.
func (srit *SubstanceReferenceInformationTarget) GetAmountString() *fhir.String {
	if srit == nil {
		return nil
	}
	val, ok := srit.Amount.(*fhir.String)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetExtension() []*fhir.Extension {
	if srit == nil {
		return nil
	}
	return srit.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetID() string {
	if srit == nil {
		return ""
	}
	return srit.ID
}

// GetInteraction returns the value of the field Interaction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetInteraction() *fhir.CodeableConcept {
	if srit == nil {
		return nil
	}
	return srit.Interaction
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetModifierExtension() []*fhir.Extension {
	if srit == nil {
		return nil
	}
	return srit.ModifierExtension
}

// GetOrganism returns the value of the field Organism.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetOrganism() *fhir.CodeableConcept {
	if srit == nil {
		return nil
	}
	return srit.Organism
}

// GetOrganismType returns the value of the field OrganismType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetOrganismType() *fhir.CodeableConcept {
	if srit == nil {
		return nil
	}
	return srit.OrganismType
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetSource() []*fhir.Reference {
	if srit == nil {
		return nil
	}
	return srit.Source
}

// GetTarget returns the value of the field Target.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetTarget() *fhir.Identifier {
	if srit == nil {
		return nil
	}
	return srit.Target
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (srit *SubstanceReferenceInformationTarget) GetType() *fhir.CodeableConcept {
	if srit == nil {
		return nil
	}
	return srit.Type
}

func (sri *SubstanceReferenceInformation) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sri *SubstanceReferenceInformation) UnmarshalJSON(data []byte) error {
	var raw struct {
		Classification []*SubstanceReferenceInformationClassification `json:"classification"`
		Comment        *fhir.String                                   `json:"comment"`
		Contained      []fhir.Resource                                `json:"contained"`
		Extension      []*fhir.Extension                              `json:"extension"`
		Gene           []*SubstanceReferenceInformationGene           `json:"gene"`
		GeneElement    []*SubstanceReferenceInformationGeneElement    `json:"geneElement"`

		ID                string                                 `json:"id"`
		ImplicitRules     *fhir.URI                              `json:"implicitRules"`
		Language          *fhir.Code                             `json:"language"`
		Meta              *fhir.Meta                             `json:"meta"`
		ModifierExtension []*fhir.Extension                      `json:"modifierExtension"`
		Target            []*SubstanceReferenceInformationTarget `json:"target"`
		Text              *fhir.Narrative                        `json:"text"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sri.Classification = raw.Classification
	sri.Comment = raw.Comment
	sri.Contained = raw.Contained
	sri.Extension = raw.Extension
	sri.Gene = raw.Gene
	sri.GeneElement = raw.GeneElement
	sri.ID = raw.ID
	sri.ImplicitRules = raw.ImplicitRules
	sri.Language = raw.Language
	sri.Meta = raw.Meta
	sri.ModifierExtension = raw.ModifierExtension
	sri.Target = raw.Target
	sri.Text = raw.Text
	return nil
}

var _ json.Marshaler = (*SubstanceReferenceInformation)(nil)
var _ json.Unmarshaler = (*SubstanceReferenceInformation)(nil)

func (sric *SubstanceReferenceInformationClassification) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sric *SubstanceReferenceInformationClassification) UnmarshalJSON(data []byte) error {
	var raw struct {
		Classification *fhir.CodeableConcept `json:"classification"`
		Domain         *fhir.CodeableConcept `json:"domain"`
		Extension      []*fhir.Extension     `json:"extension"`

		ID                string                  `json:"id"`
		ModifierExtension []*fhir.Extension       `json:"modifierExtension"`
		Source            []*fhir.Reference       `json:"source"`
		Subtype           []*fhir.CodeableConcept `json:"subtype"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sric.Classification = raw.Classification
	sric.Domain = raw.Domain
	sric.Extension = raw.Extension
	sric.ID = raw.ID
	sric.ModifierExtension = raw.ModifierExtension
	sric.Source = raw.Source
	sric.Subtype = raw.Subtype
	return nil
}

var _ json.Marshaler = (*SubstanceReferenceInformationClassification)(nil)
var _ json.Unmarshaler = (*SubstanceReferenceInformationClassification)(nil)

func (srig *SubstanceReferenceInformationGene) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (srig *SubstanceReferenceInformationGene) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension          []*fhir.Extension     `json:"extension"`
		Gene               *fhir.CodeableConcept `json:"gene"`
		GeneSequenceOrigin *fhir.CodeableConcept `json:"geneSequenceOrigin"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Source            []*fhir.Reference `json:"source"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	srig.Extension = raw.Extension
	srig.Gene = raw.Gene
	srig.GeneSequenceOrigin = raw.GeneSequenceOrigin
	srig.ID = raw.ID
	srig.ModifierExtension = raw.ModifierExtension
	srig.Source = raw.Source
	return nil
}

var _ json.Marshaler = (*SubstanceReferenceInformationGene)(nil)
var _ json.Unmarshaler = (*SubstanceReferenceInformationGene)(nil)

func (srige *SubstanceReferenceInformationGeneElement) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (srige *SubstanceReferenceInformationGeneElement) UnmarshalJSON(data []byte) error {
	var raw struct {
		Element   *fhir.Identifier  `json:"element"`
		Extension []*fhir.Extension `json:"extension"`

		ID                string                `json:"id"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Source            []*fhir.Reference     `json:"source"`
		Type              *fhir.CodeableConcept `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	srige.Element = raw.Element
	srige.Extension = raw.Extension
	srige.ID = raw.ID
	srige.ModifierExtension = raw.ModifierExtension
	srige.Source = raw.Source
	srige.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceReferenceInformationGeneElement)(nil)
var _ json.Unmarshaler = (*SubstanceReferenceInformationGeneElement)(nil)

func (srit *SubstanceReferenceInformationTarget) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (srit *SubstanceReferenceInformationTarget) UnmarshalJSON(data []byte) error {
	var raw struct {
		AmountType     *fhir.CodeableConcept `json:"amountType"`
		AmountQuantity *fhir.Quantity        `json:"amountQuantity"`
		AmountRange    *fhir.Range           `json:"amountRange"`
		AmountString   *fhir.String          `json:"amountString"`
		Extension      []*fhir.Extension     `json:"extension"`

		ID                string                `json:"id"`
		Interaction       *fhir.CodeableConcept `json:"interaction"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Organism          *fhir.CodeableConcept `json:"organism"`
		OrganismType      *fhir.CodeableConcept `json:"organismType"`
		Source            []*fhir.Reference     `json:"source"`
		Target            *fhir.Identifier      `json:"target"`
		Type              *fhir.CodeableConcept `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	srit.AmountType = raw.AmountType
	srit.Amount, err = validate.SelectOneOf[fhir.Element]("SubstanceReferenceInformation.target.amount",
		raw.AmountQuantity,
		raw.AmountRange,
		raw.AmountString)
	if err != nil {
		return err
	}
	srit.Extension = raw.Extension
	srit.ID = raw.ID
	srit.Interaction = raw.Interaction
	srit.ModifierExtension = raw.ModifierExtension
	srit.Organism = raw.Organism
	srit.OrganismType = raw.OrganismType
	srit.Source = raw.Source
	srit.Target = raw.Target
	srit.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceReferenceInformationTarget)(nil)
var _ json.Unmarshaler = (*SubstanceReferenceInformationTarget)(nil)
