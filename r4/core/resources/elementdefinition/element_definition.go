// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.
package elementdefinition

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Base StructureDefinition for ElementDefinition Type: Captures constraints on
// each element within the resource, profile, or extension.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/ElementDefinition
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinition struct {

	// Identifies additional names by which this element might also be known.
	Alias []*fhir.String `json:"alias"`

	// Information about the base definition of the element, provided to make it
	// unnecessary for tools to trace the deviation of the element through the
	// derived and related profiles. When the element definition is not the
	// original definition of an element - i.g. either in a constraint on another
	// type, or for elements from a super type in a snap shot - then the
	// information in provided in the element definition may be different to the
	// base definition. On the original definition of the element, it will be same.
	Base fhir.Element `json:"base"`

	// Binds to a value set if this element is coded (code, Coding,
	// CodeableConcept, Quantity), or the data types (string, uri).
	Binding fhir.Element `json:"binding"`

	// A code that has the same meaning as the element in a particular terminology.
	Code []*fhir.Coding `json:"code"`

	// Explanatory notes and implementation guidance about the data element,
	// including notes about how to use the data properly, exceptions to proper
	// use, etc. (Note: The text you are reading is specified in
	// ElementDefinition.comment).
	Comment *fhir.Markdown `json:"comment"`

	// A reference to an invariant that may make additional statements about the
	// cardinality or value in the instance.
	Condition []*fhir.Id `json:"condition"`

	// Formal constraints such as co-occurrence and other constraints that can be
	// computationally evaluated within the context of the instance.
	Constraint []fhir.Element `json:"constraint"`

	// Identifies an element defined elsewhere in the definition whose content
	// rules should be applied to the current element. ContentReferences bring
	// across all the rules that are in the ElementDefinition for the element,
	// including definitions, cardinality constraints, bindings, invariants etc.
	ContentReference *fhir.Uri `json:"contentReference"`

	// The value that should be used if there is no value stated in the instance
	// (e.g. 'if not otherwise specified, the abstract is false').
	DefaultValue fhir.Element `json:"defaultValue"`

	// Provides a complete explanation of the meaning of the data element for human
	// readability. For the case of elements derived from existing elements (e.g.
	// constraints), the definition SHALL be consistent with the base definition,
	// but convey the meaning of the element in the particular context of use of
	// the resource. (Note: The text you are reading is specified in
	// ElementDefinition.definition).
	Definition *fhir.Markdown `json:"definition"`

	// A sample value for this element demonstrating the type of information that
	// would typically be found in the element.
	Example []fhir.Element `json:"example"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Specifies a value that SHALL be exactly the value for this element in the
	// instance. For purposes of comparison, non-significant whitespace is ignored,
	// and all values must be an exact match (case and accent sensitive). Missing
	// elements/attributes must also be missing.
	Fixed fhir.Element `json:"fixed"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// If true, the value of this element affects the interpretation of the element
	// or resource that contains it, and the value of the element cannot be
	// ignored. Typically, this is used for status, negation and qualification
	// codes. The effect of this is that the element cannot be ignored by systems:
	// they SHALL either recognize the element and process it, and/or a
	// pre-determination has been made that it is not relevant to their particular
	// system.
	IsModifier *fhir.Boolean `json:"isModifier"`

	// Explains how that element affects the interpretation of the resource or
	// element that contains it.
	IsModifierReason *fhir.String `json:"isModifierReason"`

	// Whether the element should be included if a client requests a search with
	// the parameter _summary=true.
	IsSummary *fhir.Boolean `json:"isSummary"`

	// A single preferred label which is the text to display beside the element
	// indicating its meaning or to use to prompt for the element in a user display
	// or form.
	Label *fhir.String `json:"label"`

	// Identifies a concept from an external specification that roughly corresponds
	// to this element.
	Mapping []fhir.Element `json:"mapping"`

	// The maximum number of times this element is permitted to appear in the
	// instance.
	Max *fhir.String `json:"max"`

	// Indicates the maximum length in characters that is permitted to be present
	// in conformant instances and which is expected to be supported by conformant
	// consumers that support the element.
	MaxLength *fhir.Integer `json:"maxLength"`

	// The maximum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MaxValue fhir.Element `json:"maxValue"`

	// The Implicit meaning that is to be understood when this element is missing
	// (e.g. 'when this element is missing, the period is ongoing').
	MeaningWhenMissing *fhir.Markdown `json:"meaningWhenMissing"`

	// The minimum number of times this element SHALL appear in the instance.
	Min *fhir.UnsignedInt `json:"min"`

	// The minimum allowed value for the element. The value is inclusive. This is
	// allowed for the types date, dateTime, instant, time, decimal, integer, and
	// Quantity.
	MinValue fhir.Element `json:"minValue"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `json:"modifierExtension"`

	// If true, implementations that produce or consume resources SHALL provide
	// "support" for the element in some meaningful way. If false, the element may
	// be ignored and not supported. If false, whether to populate or use the data
	// element in any way is at the discretion of the implementation.
	MustSupport *fhir.Boolean `json:"mustSupport"`

	// If present, indicates that the order of the repeating element has meaning
	// and describes what that meaning is. If absent, it means that the order of
	// the element has no meaning.
	OrderMeaning *fhir.String `json:"orderMeaning"`

	// The path identifies the element and is expressed as a "."-separated list of
	// ancestor elements, beginning with the name of the resource or extension.
	Path *fhir.String `json:"path"`

	// Specifies a value that the value in the instance SHALL follow - that is, any
	// value in the pattern must be found in the instance. Other additional values
	// may be found too. This is effectively constraint by example.
	// When pattern[x] is used to constrain a primitive, it means that the value
	// provided in the pattern[x] must match the instance value exactly.
	// When pattern[x] is used to constrain an array, it means that each element
	// provided in the pattern[x] array must (recursively) match at least one
	// element from the instance array.
	// When pattern[x] is used to constrain a complex object, it means that each
	// property in the pattern must be present in the complex object, and its value
	// must recursively match -- i.e.,
	// 1. If primitive: it must match exactly the pattern value 2. If a complex
	// object: it must match (recursively) the pattern value 3. If an array: it
	// must match (recursively) the pattern value.
	Pattern fhir.Element `json:"pattern"`

	// Codes that define how this element is represented in instances, when the
	// deviation varies from the normal case.
	Representation []*fhir.Code `json:"representation"`

	// This element is for traceability of why the element was created and why the
	// constraints exist as they do. This may be used to point to source materials
	// or specifications that drove the structure of this element.
	Requirements *fhir.Markdown `json:"requirements"`

	// A concise description of what this element means (e.g. for use in
	// autogenerated summaries).
	Short *fhir.String `json:"short"`

	// If true, indicates that this slice definition is constraining a slice
	// definition with the same name in an inherited profile. If false, the slice
	// is not overriding any slice in an inherited profile. If missing, the slice
	// might or might not be overriding a slice in an inherited profile, depending
	// on the sliceName.
	SliceIsConstraining *fhir.Boolean `json:"sliceIsConstraining"`

	// The name of this element definition slice, when slicing is working. The name
	// must be a token with no dots or spaces. This is a unique name referring to a
	// specific set of constraints applied to this element, used to provide a name
	// to different slices of the same element.
	SliceName *fhir.String `json:"sliceName"`

	// Indicates that the element is sliced into a set of alternative definitions
	// (i.e. in a structure definition, there are multiple different constraints on
	// a single element in the base resource). Slicing can be used in any resource
	// that has cardinality ..* on the base resource, or any resource with a choice
	// of types. The set of slices is any elements that come after this in the
	// element sequence that have the same path, until a shorter path occurs (the
	// shorter path terminates the set).
	Slicing fhir.Element `json:"slicing"`

	// The data type or resource that the value of this element is permitted to be.
	Type []fhir.Element `json:"type"`

	isElementDefinition profileimpl.BaseElementDefinition
	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

func (v *ElementDefinition) GetDefaultValueBase64Binary() *fhir.Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueBoolean() *fhir.Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCanonical() *fhir.Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCode() *fhir.Code {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueId() *fhir.Id {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMarkdown() *fhir.Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueOid() *fhir.Oid {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValuePositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueString() *fhir.String {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUri() *fhir.Uri {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUrl() *fhir.Url {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUuid() *fhir.Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAddress() *fhir.Address {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAge() *fhir.Age {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAnnotation() *fhir.Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueAttachment() *fhir.Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCodeableConcept() *fhir.CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCoding() *fhir.Coding {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContactPoint() *fhir.ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueCount() *fhir.Count {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDistance() *fhir.Distance {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDuration() *fhir.Duration {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueHumanName() *fhir.HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueIdentifier() *fhir.Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMoney() *fhir.Money {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValuePeriod() *fhir.Period {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRange() *fhir.Range {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRatio() *fhir.Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueReference() *fhir.Reference {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueSampledData() *fhir.SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueSignature() *fhir.Signature {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTiming() *fhir.Timing {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContactDetail() *fhir.ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueContributor() *fhir.Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDataRequirement() *fhir.DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueExpression() *fhir.Expression {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueParameterDefinition() *fhir.ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueRelatedArtifact() *fhir.RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueTriggerDefinition() *fhir.TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueUsageContext() *fhir.UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueDosage() *fhir.Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetDefaultValueMeta() *fhir.Meta {
	if v == nil {
		return nil
	}
	result, ok := v.DefaultValue.(*fhir.Meta)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedBase64Binary() *fhir.Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedBoolean() *fhir.Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCanonical() *fhir.Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCode() *fhir.Code {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedId() *fhir.Id {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMarkdown() *fhir.Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedOid() *fhir.Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedPositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedString() *fhir.String {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUri() *fhir.Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUrl() *fhir.Url {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUuid() *fhir.Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAddress() *fhir.Address {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAge() *fhir.Age {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAnnotation() *fhir.Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedAttachment() *fhir.Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCodeableConcept() *fhir.CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCoding() *fhir.Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContactPoint() *fhir.ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedCount() *fhir.Count {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDistance() *fhir.Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDuration() *fhir.Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedHumanName() *fhir.HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedIdentifier() *fhir.Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMoney() *fhir.Money {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedPeriod() *fhir.Period {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRange() *fhir.Range {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRatio() *fhir.Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedReference() *fhir.Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedSampledData() *fhir.SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedSignature() *fhir.Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTiming() *fhir.Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContactDetail() *fhir.ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedContributor() *fhir.Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDataRequirement() *fhir.DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedExpression() *fhir.Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedParameterDefinition() *fhir.ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedRelatedArtifact() *fhir.RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedTriggerDefinition() *fhir.TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedUsageContext() *fhir.UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedDosage() *fhir.Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetFixedMeta() *fhir.Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Fixed.(*fhir.Meta)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValuePositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMaxValueQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.MaxValue.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValuePositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetMinValueQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.MinValue.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternBase64Binary() *fhir.Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternBoolean() *fhir.Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCanonical() *fhir.Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCode() *fhir.Code {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternId() *fhir.Id {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMarkdown() *fhir.Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternOid() *fhir.Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternPositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternString() *fhir.String {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUri() *fhir.Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUrl() *fhir.Url {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUuid() *fhir.Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAddress() *fhir.Address {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAge() *fhir.Age {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAnnotation() *fhir.Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternAttachment() *fhir.Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCodeableConcept() *fhir.CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCoding() *fhir.Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContactPoint() *fhir.ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternCount() *fhir.Count {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDistance() *fhir.Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDuration() *fhir.Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternHumanName() *fhir.HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternIdentifier() *fhir.Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMoney() *fhir.Money {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternPeriod() *fhir.Period {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRange() *fhir.Range {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRatio() *fhir.Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternReference() *fhir.Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternSampledData() *fhir.SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternSignature() *fhir.Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTiming() *fhir.Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContactDetail() *fhir.ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternContributor() *fhir.Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDataRequirement() *fhir.DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternExpression() *fhir.Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternParameterDefinition() *fhir.ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternRelatedArtifact() *fhir.RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternTriggerDefinition() *fhir.TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternUsageContext() *fhir.UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternDosage() *fhir.Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinition) GetPatternMeta() *fhir.Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Pattern.(*fhir.Meta)
	if ok {
		return result
	}
	return nil
}
func (e *ElementDefinition) GetAlias() []*fhir.String {
	if e == nil {
		return nil
	}
	return e.Alias
}

func (e *ElementDefinition) GetBase() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Base
}

func (e *ElementDefinition) GetBinding() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Binding
}

func (e *ElementDefinition) GetCode() []*fhir.Coding {
	if e == nil {
		return nil
	}
	return e.Code
}

func (e *ElementDefinition) GetComment() *fhir.Markdown {
	if e == nil {
		return nil
	}
	return e.Comment
}

func (e *ElementDefinition) GetCondition() []*fhir.Id {
	if e == nil {
		return nil
	}
	return e.Condition
}

func (e *ElementDefinition) GetConstraint() []fhir.Element {
	if e == nil {
		return nil
	}
	return e.Constraint
}

func (e *ElementDefinition) GetContentReference() *fhir.Uri {
	if e == nil {
		return nil
	}
	return e.ContentReference
}

func (e *ElementDefinition) GetDefaultValue() fhir.Element {
	if e == nil {
		return nil
	}
	return e.DefaultValue
}

func (e *ElementDefinition) GetDefinition() *fhir.Markdown {
	if e == nil {
		return nil
	}
	return e.Definition
}

func (e *ElementDefinition) GetExample() []fhir.Element {
	if e == nil {
		return nil
	}
	return e.Example
}

func (e *ElementDefinition) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinition) GetFixed() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Fixed
}

func (e *ElementDefinition) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinition) GetIsModifier() *fhir.Boolean {
	if e == nil {
		return nil
	}
	return e.IsModifier
}

func (e *ElementDefinition) GetIsModifierReason() *fhir.String {
	if e == nil {
		return nil
	}
	return e.IsModifierReason
}

func (e *ElementDefinition) GetIsSummary() *fhir.Boolean {
	if e == nil {
		return nil
	}
	return e.IsSummary
}

func (e *ElementDefinition) GetLabel() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *ElementDefinition) GetMapping() []fhir.Element {
	if e == nil {
		return nil
	}
	return e.Mapping
}

func (e *ElementDefinition) GetMax() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Max
}

func (e *ElementDefinition) GetMaxLength() *fhir.Integer {
	if e == nil {
		return nil
	}
	return e.MaxLength
}

func (e *ElementDefinition) GetMaxValue() fhir.Element {
	if e == nil {
		return nil
	}
	return e.MaxValue
}

func (e *ElementDefinition) GetMeaningWhenMissing() *fhir.Markdown {
	if e == nil {
		return nil
	}
	return e.MeaningWhenMissing
}

func (e *ElementDefinition) GetMin() *fhir.UnsignedInt {
	if e == nil {
		return nil
	}
	return e.Min
}

func (e *ElementDefinition) GetMinValue() fhir.Element {
	if e == nil {
		return nil
	}
	return e.MinValue
}

func (e *ElementDefinition) GetModifierExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.ModifierExtension
}

func (e *ElementDefinition) GetMustSupport() *fhir.Boolean {
	if e == nil {
		return nil
	}
	return e.MustSupport
}

func (e *ElementDefinition) GetOrderMeaning() *fhir.String {
	if e == nil {
		return nil
	}
	return e.OrderMeaning
}

func (e *ElementDefinition) GetPath() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Path
}

func (e *ElementDefinition) GetPattern() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Pattern
}

func (e *ElementDefinition) GetRepresentation() []*fhir.Code {
	if e == nil {
		return nil
	}
	return e.Representation
}

func (e *ElementDefinition) GetRequirements() *fhir.Markdown {
	if e == nil {
		return nil
	}
	return e.Requirements
}

func (e *ElementDefinition) GetShort() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Short
}

func (e *ElementDefinition) GetSliceIsConstraining() *fhir.Boolean {
	if e == nil {
		return nil
	}
	return e.SliceIsConstraining
}

func (e *ElementDefinition) GetSliceName() *fhir.String {
	if e == nil {
		return nil
	}
	return e.SliceName
}

func (e *ElementDefinition) GetSlicing() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Slicing
}

func (e *ElementDefinition) GetType() []fhir.Element {
	if e == nil {
		return nil
	}
	return e.Type
}

// Base definition information for tools// Information about the base definition of the element, provided to make it
// unnecessary for tools to trace the deviation of the element through the
// derived and related profiles. When the element definition is not the
// original definition of an element - i.g. either in a constraint on another
// type, or for elements from a super type in a snap shot - then the
// information in provided in the element definition may be different to the
// base definition. On the original definition of the element, it will be same.// The base information does not carry any information that could not be
// determined from the path and related profiles, but making this determination
// requires both that the related profiles are available, and that the
// algorithm to determine them be available. For tooling simplicity, the base
// information must always be populated in element definitions in snap shots,
// even if it is the same.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBase struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Maximum cardinality of the base element identified by the path.
	Max *fhir.String `json:"max"`

	// Minimum cardinality of the base element identified by the path.
	Min *fhir.UnsignedInt `json:"min"`

	// The Path that identifies the base element - this matches the
	// ElementDefinition.path for that element. Across FHIR, there is only one base
	// definition of any element - that is, an element definition on a
	// [StructureDefinition](structuredefinition.html#) without a
	// StructureDefinition.base.
	Path *fhir.String `json:"path"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionBase) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionBase) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionBase) GetMax() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Max
}

func (e *ElementDefinitionBase) GetMin() *fhir.UnsignedInt {
	if e == nil {
		return nil
	}
	return e.Min
}

func (e *ElementDefinitionBase) GetPath() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Path
}

// ValueSet details if this is coded// Binds to a value set if this element is coded (code, Coding,
// CodeableConcept, Quantity), or the data types (string, uri).// For a CodeableConcept, when no codes are allowed - only text, use a binding
// of strength "required" with a description explaining that no coded values
// are allowed and what sort of information to put in the "text" element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionBinding struct {

	// Describes the intended use of this particular set of codes.
	Description *fhir.String `json:"description"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Indicates the degree of conformance expectations associated with this
	// binding - that is, the degree to which the provided value set must be
	// adhered to in the instances.
	Strength *fhir.Code `json:"strength"`

	// Refers to the value set that identifies the set of codes the binding refers
	// to.
	ValueSet *fhir.Canonical `json:"valueSet"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionBinding) GetDescription() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *ElementDefinitionBinding) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionBinding) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionBinding) GetStrength() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Strength
}

func (e *ElementDefinitionBinding) GetValueSet() *fhir.Canonical {
	if e == nil {
		return nil
	}
	return e.ValueSet
}

// Condition that must evaluate to true// Formal constraints such as co-occurrence and other constraints that can be
// computationally evaluated within the context of the instance.// Constraints should be declared on the "context" element - the lowest element
// in the hierarchy that is common to all nodes referenced by the constraint.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionConstraint struct {

	// A [FHIRPath](fhirpath.html) expression of constraint that can be executed to
	// see if this constraint is met.
	Expression *fhir.String `json:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Text that can be used to describe the constraint in messages identifying
	// that the constraint has been violated.
	Human *fhir.String `json:"human"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Allows identification of which elements have their cardinalities impacted by
	// the constraint. Will not be referenced for constraints that do not affect
	// cardinality.
	Key *fhir.Id `json:"key"`

	// Description of why this constraint is necessary or appropriate.
	Requirements *fhir.String `json:"requirements"`

	// Identifies the impact constraint violation has on the conformance of the
	// instance.
	Severity *fhir.Code `json:"severity"`

	// A reference to the original source of the constraint, for traceability
	// purposes.
	Source *fhir.Canonical `json:"source"`

	// An XPath expression of constraint that can be executed to see if this
	// constraint is met.
	Xpath *fhir.String `json:"xpath"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionConstraint) GetExpression() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Expression
}

func (e *ElementDefinitionConstraint) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionConstraint) GetHuman() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Human
}

func (e *ElementDefinitionConstraint) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionConstraint) GetKey() *fhir.Id {
	if e == nil {
		return nil
	}
	return e.Key
}

func (e *ElementDefinitionConstraint) GetRequirements() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Requirements
}

func (e *ElementDefinitionConstraint) GetSeverity() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Severity
}

func (e *ElementDefinitionConstraint) GetSource() *fhir.Canonical {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *ElementDefinitionConstraint) GetXpath() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Xpath
}

// Example value (as defined for type)// A sample value for this element demonstrating the type of information that
// would typically be found in the element.// Examples will most commonly be present for data where it's not implicitly
// obvious from either the data type or value set what the values might be.
// (I.e. Example values for dates or quantities would generally be
// unnecessary.) If the example value is fully populated, the publication tool
// can generate an instance automatically.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionExample struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Describes the purpose of this example amoung the set of examples.
	Label *fhir.String `json:"label"`

	// The actual value for the element, which must be one of the types allowed for
	// this element.
	Value fhir.Element `json:"value"`

	profileimpl.BaseElement
}

func (v *ElementDefinitionExample) GetValueBase64Binary() *fhir.Base64Binary {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Base64Binary)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueBoolean() *fhir.Boolean {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Boolean)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCanonical() *fhir.Canonical {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Canonical)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCode() *fhir.Code {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Code)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDate() *fhir.Date {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Date)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDateTime() *fhir.DateTime {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.DateTime)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDecimal() *fhir.Decimal {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Decimal)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueId() *fhir.Id {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Id)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueInstant() *fhir.Instant {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Instant)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueInteger() *fhir.Integer {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Integer)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMarkdown() *fhir.Markdown {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Markdown)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueOid() *fhir.Oid {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Oid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValuePositiveInt() *fhir.PositiveInt {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.PositiveInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueString() *fhir.String {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.String)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTime() *fhir.Time {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Time)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUnsignedInt() *fhir.UnsignedInt {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.UnsignedInt)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUri() *fhir.Uri {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Uri)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUrl() *fhir.Url {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Url)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUuid() *fhir.Uuid {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Uuid)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAddress() *fhir.Address {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Address)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAge() *fhir.Age {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Age)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAnnotation() *fhir.Annotation {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Annotation)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueAttachment() *fhir.Attachment {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Attachment)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCodeableConcept() *fhir.CodeableConcept {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.CodeableConcept)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCoding() *fhir.Coding {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Coding)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContactPoint() *fhir.ContactPoint {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.ContactPoint)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueCount() *fhir.Count {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Count)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDistance() *fhir.Distance {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Distance)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDuration() *fhir.Duration {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Duration)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueHumanName() *fhir.HumanName {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.HumanName)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueIdentifier() *fhir.Identifier {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Identifier)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMoney() *fhir.Money {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Money)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValuePeriod() *fhir.Period {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Period)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueQuantity() *fhir.Quantity {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Quantity)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRange() *fhir.Range {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Range)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRatio() *fhir.Ratio {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Ratio)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueReference() *fhir.Reference {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Reference)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueSampledData() *fhir.SampledData {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.SampledData)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueSignature() *fhir.Signature {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Signature)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTiming() *fhir.Timing {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Timing)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContactDetail() *fhir.ContactDetail {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.ContactDetail)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueContributor() *fhir.Contributor {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Contributor)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDataRequirement() *fhir.DataRequirement {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.DataRequirement)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueExpression() *fhir.Expression {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Expression)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueParameterDefinition() *fhir.ParameterDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.ParameterDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueRelatedArtifact() *fhir.RelatedArtifact {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.RelatedArtifact)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueTriggerDefinition() *fhir.TriggerDefinition {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.TriggerDefinition)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueUsageContext() *fhir.UsageContext {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.UsageContext)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueDosage() *fhir.Dosage {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Dosage)
	if ok {
		return result
	}
	return nil
}
func (v *ElementDefinitionExample) GetValueMeta() *fhir.Meta {
	if v == nil {
		return nil
	}
	result, ok := v.Value.(*fhir.Meta)
	if ok {
		return result
	}
	return nil
}
func (e *ElementDefinitionExample) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionExample) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionExample) GetLabel() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Label
}

func (e *ElementDefinitionExample) GetValue() fhir.Element {
	if e == nil {
		return nil
	}
	return e.Value
}

// Map element to another set of definitions// Identifies a concept from an external specification that roughly corresponds
// to this element.// Mappings are not necessarily specific enough for safe translation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionMapping struct {

	// Comments that provide information about the mapping or its use.
	Comment *fhir.String `json:"comment"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// An internal reference to the definition of a mapping.
	Identity *fhir.Id `json:"identity"`

	// Identifies the computable language in which mapping.map is expressed.
	Language *fhir.Code `json:"language"`

	// Expresses what part of the target specification corresponds to this element.
	Map *fhir.String `json:"map"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionMapping) GetComment() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Comment
}

func (e *ElementDefinitionMapping) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionMapping) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionMapping) GetIdentity() *fhir.Id {
	if e == nil {
		return nil
	}
	return e.Identity
}

func (e *ElementDefinitionMapping) GetLanguage() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Language
}

func (e *ElementDefinitionMapping) GetMap() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Map
}

// This element is sliced - slices follow// Indicates that the element is sliced into a set of alternative definitions
// (i.e. in a structure definition, there are multiple different constraints on
// a single element in the base resource). Slicing can be used in any resource
// that has cardinality ..* on the base resource, or any resource with a choice
// of types. The set of slices is any elements that come after this in the
// element sequence that have the same path, until a shorter path occurs (the
// shorter path terminates the set).// The first element in the sequence, the one that carries the slicing, is the
// definition that applies to all the slices. This is based on the
// unconstrained element, but can apply any constraints as appropriate. This
// may include the common constraints on the children of the element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicing struct {

	// A human-readable text description of how the slicing works. If there is no
	// discriminator, this is required to be present to provide whatever
	// information is possible about how the slices can be differentiated.
	Description *fhir.String `json:"description"`

	// Designates which child elements are used to discriminate between the slices
	// when processing an instance. If one or more discriminators are provided, the
	// value of the child elements in the instance data SHALL completely
	// distinguish which slice the element in the resource matches based on the
	// allowed values for those elements in each of the slices.
	Discriminator []fhir.Element `json:"discriminator"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// If the matching elements have to occur in the same order as defined in the
	// profile.
	Ordered *fhir.Boolean `json:"ordered"`

	// Whether additional slices are allowed or not. When the slices are ordered,
	// profile authors can also say that additional slices are only allowed at the
	// end.
	Rules *fhir.Code `json:"rules"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionSlicing) GetDescription() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *ElementDefinitionSlicing) GetDiscriminator() []fhir.Element {
	if e == nil {
		return nil
	}
	return e.Discriminator
}

func (e *ElementDefinitionSlicing) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionSlicing) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionSlicing) GetOrdered() *fhir.Boolean {
	if e == nil {
		return nil
	}
	return e.Ordered
}

func (e *ElementDefinitionSlicing) GetRules() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Rules
}

// Element values that are used to distinguish the slices// Designates which child elements are used to discriminate between the slices
// when processing an instance. If one or more discriminators are provided, the
// value of the child elements in the instance data SHALL completely
// distinguish which slice the element in the resource matches based on the
// allowed values for those elements in each of the slices.// If there is no discriminator, the content is hard to process, so this should
// be avoided.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionSlicingDiscriminator struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// A FHIRPath expression, using [the simple subset of
	// FHIRPath](fhirpath.html#simple), that is used to identify the element on
	// which discrimination is based.
	Path *fhir.String `json:"path"`

	// How the element value is interpreted when discrimination is evaluated.
	Type *fhir.Code `json:"type"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionSlicingDiscriminator) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionSlicingDiscriminator) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionSlicingDiscriminator) GetPath() *fhir.String {
	if e == nil {
		return nil
	}
	return e.Path
}

func (e *ElementDefinitionSlicingDiscriminator) GetType() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Type
}

// Data type and Profile for this element// The data type or resource that the value of this element is permitted to be.// The Type of the element can be left blank in a differential constraint, in
// which case the type is inherited from the resource. Abstract types are not
// permitted to appear as a type when multiple types are listed. (I.e. Abstract
// types cannot be part of a choice).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ElementDefinition.json
type ElementDefinitionType struct {

	// If the type is a reference to another resource, how the resource is or can
	// be aggregated - is it a contained resource, or a reference, and if the
	// context is a bundle, is it included in the bundle.
	Aggregation []*fhir.Code `json:"aggregation"`

	// URL of Data type or Resource that is a(or the) type used for this element.
	// References are URLs that are relative to
	// http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to
	// http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only
	// allowed in logical models.
	Code *fhir.Uri `json:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `json:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	Id string `json:"id"`

	// Identifies a profile structure or implementation Guide that applies to the
	// datatype this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the type SHALL conform to at least one
	// profile defined in the implementation guide.
	Profile []*fhir.Canonical `json:"profile"`

	// Used when the type is "Reference" or "canonical", and identifies a profile
	// structure or implementation Guide that applies to the target of the
	// reference this element refers to. If any profiles are specified, then the
	// content must conform to at least one of them. The URL can be a local
	// reference - to a contained StructureDefinition, or a reference to another
	// StructureDefinition or Implementation Guide by a canonical URL. When an
	// implementation guide is specified, the target resource SHALL conform to at
	// least one profile defined in the implementation guide.
	TargetProfile []*fhir.Canonical `json:"targetProfile"`

	// Whether this reference needs to be version specific or version independent,
	// or whether either can be used.
	Versioning *fhir.Code `json:"versioning"`

	profileimpl.BaseElement
}

func (e *ElementDefinitionType) GetAggregation() []*fhir.Code {
	if e == nil {
		return nil
	}
	return e.Aggregation
}

func (e *ElementDefinitionType) GetCode() *fhir.Uri {
	if e == nil {
		return nil
	}
	return e.Code
}

func (e *ElementDefinitionType) GetExtension() []*fhir.Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

func (e *ElementDefinitionType) GetId() string {
	if e == nil {
		return ""
	}
	return e.Id
}

func (e *ElementDefinitionType) GetProfile() []*fhir.Canonical {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *ElementDefinitionType) GetTargetProfile() []*fhir.Canonical {
	if e == nil {
		return nil
	}
	return e.TargetProfile
}

func (e *ElementDefinitionType) GetVersioning() *fhir.Code {
	if e == nil {
		return nil
	}
	return e.Versioning
}
