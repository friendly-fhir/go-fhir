// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package contract

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Legally enforceable, formally recorded unilateral or bilateral directive
// i.e., a policy or agreement.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Contract
//   - Source File: StructureDefinition-Contract.json
type Contract struct {

	// Alternative representation of the title for this Contract definition,
	// derivative, or instance in any legal state., e.g., a domain specific
	// contract number related to legislation.
	Alias []*fhir.String `fhirpath:"alias"`

	// Relevant time or time-period when this Contract is applicable.
	Applies *fhir.Period `fhirpath:"applies"`

	// The individual or organization that authored the Contract definition,
	// derivative, or instance in any legal state.
	Author *fhir.Reference `fhirpath:"author"`

	// A formally or informally recognized grouping of people, principals,
	// organizations, or jurisdictions formed for the purpose of achieving some
	// form of collective action such as the promulgation, administration and
	// enforcement of contracts and policies.
	Authority []*fhir.Reference `fhirpath:"authority"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// Precusory content developed with a focus and intent of supporting the
	// formation a Contract instance, which may be associated with and
	// transformable into a Contract.
	ContentDefinition *ContractContentDefinition `fhirpath:"contentDefinition"`

	// The minimal content derived from the basal information source at a specific
	// stage in its lifecycle.
	ContentDerivative *fhir.CodeableConcept `fhirpath:"contentDerivative"`

	// Recognized governance framework or system operating with a circumscribed
	// scope in accordance with specified principles, policies, processes or
	// procedures for managing rights, actions, or behaviors of parties or
	// principals relative to resources.
	Domain []*fhir.Reference `fhirpath:"domain"`

	// Event resulting in discontinuation or termination of this Contract instance
	// by one or more parties to the contract.
	ExpirationType *fhir.CodeableConcept `fhirpath:"expirationType"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The "patient friendly language" versionof the Contract in whole or in parts.
	// "Patient friendly language" means the representation of the Contract and
	// Contract Provisions in a manner that is readily accessible and
	// understandable by a layperson in accordance with best practices for
	// communication styles that ensure that those agreeing to or signing the
	// Contract understand the roles, actions, obligations, responsibilities, and
	// implication of the agreement.
	Friendly []*ContractFriendly `fhirpath:"friendly"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Unique identifier for this Contract or a derivative that references a Source
	// Contract.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// The URL pointing to a FHIR-defined Contract Definition that is adhered to in
	// whole or part by this Contract.
	InstantiatesCanonical *fhir.Reference `fhirpath:"instantiatesCanonical"`

	// The URL pointing to an externally maintained definition that is adhered to
	// in whole or in part by this Contract.
	InstantiatesURI *fhir.URI `fhirpath:"instantiatesUri"`

	// When this Contract was issued.
	Issued *fhir.DateTime `fhirpath:"issued"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// List of Legal expressions or representations of this Contract.
	Legal []*ContractLegal `fhirpath:"legal"`

	// Legal states of the formation of a legal instrument, which is a formally
	// executed written document that can be formally attributed to its author,
	// records and formally expresses a legally enforceable act, process, or
	// contractual duty, obligation, or right, and therefore evidences that act,
	// process, or agreement.
	LegalState *fhir.CodeableConcept `fhirpath:"legalState"`

	// Legally binding Contract: This is the signed and legally recognized
	// representation of the Contract, which is considered the "source of truth"
	// and which would be the basis for legal action related to enforcement of this
	// Contract.
	LegallyBinding fhir.Element `fhirpath:"legallyBinding"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A natural language name identifying this Contract definition, derivative, or
	// instance in any legal state. Provides additional information about its
	// content. This name should be usable as an identifier for the module by
	// machine processing applications such as code generation.
	Name *fhir.String `fhirpath:"name"`

	// Links to Provenance records for past versions of this Contract definition,
	// derivative, or instance, which identify key state transitions or updates
	// that are likely to be relevant to a user looking at the current version of
	// the Contract. The Provence.entity indicates the target that was changed in
	// the update.
	// http://build.fhir.org/provenance-definitions.html#Provenance.entity.
	RelevantHistory []*fhir.Reference `fhirpath:"relevantHistory"`

	// List of Computable Policy Rule Language Representations of this Contract.
	Rule []*ContractRule `fhirpath:"rule"`

	// A selector of legal concerns for this Contract definition, derivative, or
	// instance in any legal state.
	Scope *fhir.CodeableConcept `fhirpath:"scope"`

	// Parties with legal standing in the Contract, including the principal
	// parties, the grantor(s) and grantee(s), which are any person or organization
	// bound by the contract, and any ancillary parties, which facilitate the
	// execution of the contract such as a notary or witness.
	Signer []*ContractSigner `fhirpath:"signer"`

	// Sites in which the contract is complied with, exercised, or in force.
	Site []*fhir.Reference `fhirpath:"site"`

	// The status of the resource instance.
	Status *fhir.Code `fhirpath:"status"`

	// Sub-category for the Contract that distinguishes the kinds of systems that
	// would be interested in the Contract within the context of the Contract's
	// scope.
	SubType []*fhir.CodeableConcept `fhirpath:"subType"`

	// The target entity impacted by or of interest to parties to the agreement.
	Subject []*fhir.Reference `fhirpath:"subject"`

	// An explanatory or alternate user-friendly title for this Contract
	// definition, derivative, or instance in any legal state.t giving additional
	// information about its content.
	Subtitle *fhir.String `fhirpath:"subtitle"`

	// Information that may be needed by/relevant to the performer in their
	// execution of this term action.
	SupportingInfo []*fhir.Reference `fhirpath:"supportingInfo"`

	// One or more Contract Provisions, which may be related and conveyed as a
	// group, and may contain nested groups.
	Term []*ContractTerm `fhirpath:"term"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// A short, descriptive, user-friendly title for this Contract definition,
	// derivative, or instance in any legal state.t giving additional information
	// about its content.
	Title *fhir.String `fhirpath:"title"`

	// Narrows the range of legal concerns to focus on the achievement of specific
	// contractual objectives.
	Topic fhir.Element `fhirpath:"topic"`

	// A high-level category for the legal instrument, whether constructed as a
	// Contract definition, derivative, or instance in any legal state. Provides
	// additional information about its content within the context of the
	// Contract's scope to distinguish the kinds of systems that would be
	// interested in the contract.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	// Canonical identifier for this contract, represented as a URI (globally
	// unique).
	URL *fhir.URI `fhirpath:"url"`

	// An edition identifier used for business purposes to label business
	// significant variants.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetAlias returns the value of the field Alias.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetAlias() []*fhir.String {
	if c == nil {
		return nil
	}
	return c.Alias
}

// GetApplies returns the value of the field Applies.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetApplies() *fhir.Period {
	if c == nil {
		return nil
	}
	return c.Applies
}

// GetAuthor returns the value of the field Author.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetAuthor() *fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Author
}

// GetAuthority returns the value of the field Authority.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetAuthority() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Authority
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetContained() []fhir.Resource {
	if c == nil {
		return nil
	}
	return c.Contained
}

// GetContentDefinition returns the value of the field ContentDefinition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetContentDefinition() *ContractContentDefinition {
	if c == nil {
		return nil
	}
	return c.ContentDefinition
}

// GetContentDerivative returns the value of the field ContentDerivative.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetContentDerivative() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.ContentDerivative
}

// GetDomain returns the value of the field Domain.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetDomain() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Domain
}

// GetExpirationType returns the value of the field ExpirationType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetExpirationType() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.ExpirationType
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetExtension() []*fhir.Extension {
	if c == nil {
		return nil
	}
	return c.Extension
}

// GetFriendly returns the value of the field Friendly.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetFriendly() []*ContractFriendly {
	if c == nil {
		return nil
	}
	return c.Friendly
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetIdentifier() []*fhir.Identifier {
	if c == nil {
		return nil
	}
	return c.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetImplicitRules() *fhir.URI {
	if c == nil {
		return nil
	}
	return c.ImplicitRules
}

// GetInstantiatesCanonical returns the value of the field InstantiatesCanonical.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetInstantiatesCanonical() *fhir.Reference {
	if c == nil {
		return nil
	}
	return c.InstantiatesCanonical
}

// GetInstantiatesURI returns the value of the field InstantiatesURI.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetInstantiatesURI() *fhir.URI {
	if c == nil {
		return nil
	}
	return c.InstantiatesURI
}

// GetIssued returns the value of the field Issued.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetIssued() *fhir.DateTime {
	if c == nil {
		return nil
	}
	return c.Issued
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetLanguage() *fhir.Code {
	if c == nil {
		return nil
	}
	return c.Language
}

// GetLegal returns the value of the field Legal.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetLegal() []*ContractLegal {
	if c == nil {
		return nil
	}
	return c.Legal
}

// GetLegalState returns the value of the field LegalState.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetLegalState() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.LegalState
}

// GetLegallyBinding returns the value of the field LegallyBinding.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetLegallyBinding() fhir.Element {
	if c == nil {
		return nil
	}
	return c.LegallyBinding
}

// GetLegallyBindingAttachment returns the value of the field LegallyBinding.
func (c *Contract) GetLegallyBindingAttachment() *fhir.Attachment {
	if c == nil {
		return nil
	}
	val, ok := c.LegallyBinding.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetLegallyBindingReference returns the value of the field LegallyBinding.
func (c *Contract) GetLegallyBindingReference() *fhir.Reference {
	if c == nil {
		return nil
	}
	val, ok := c.LegallyBinding.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetMeta() *fhir.Meta {
	if c == nil {
		return nil
	}
	return c.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetModifierExtension() []*fhir.Extension {
	if c == nil {
		return nil
	}
	return c.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetName() *fhir.String {
	if c == nil {
		return nil
	}
	return c.Name
}

// GetRelevantHistory returns the value of the field RelevantHistory.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetRelevantHistory() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.RelevantHistory
}

// GetRule returns the value of the field Rule.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetRule() []*ContractRule {
	if c == nil {
		return nil
	}
	return c.Rule
}

// GetScope returns the value of the field Scope.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetScope() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.Scope
}

// GetSigner returns the value of the field Signer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSigner() []*ContractSigner {
	if c == nil {
		return nil
	}
	return c.Signer
}

// GetSite returns the value of the field Site.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSite() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Site
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetStatus() *fhir.Code {
	if c == nil {
		return nil
	}
	return c.Status
}

// GetSubType returns the value of the field SubType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSubType() []*fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.SubType
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSubject() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.Subject
}

// GetSubtitle returns the value of the field Subtitle.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSubtitle() *fhir.String {
	if c == nil {
		return nil
	}
	return c.Subtitle
}

// GetSupportingInfo returns the value of the field SupportingInfo.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetSupportingInfo() []*fhir.Reference {
	if c == nil {
		return nil
	}
	return c.SupportingInfo
}

// GetTerm returns the value of the field Term.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetTerm() []*ContractTerm {
	if c == nil {
		return nil
	}
	return c.Term
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetText() *fhir.Narrative {
	if c == nil {
		return nil
	}
	return c.Text
}

// GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetTitle() *fhir.String {
	if c == nil {
		return nil
	}
	return c.Title
}

// GetTopic returns the value of the field Topic.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetTopic() fhir.Element {
	if c == nil {
		return nil
	}
	return c.Topic
}

// GetTopicCodeableConcept returns the value of the field Topic.
func (c *Contract) GetTopicCodeableConcept() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	val, ok := c.Topic.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetTopicReference returns the value of the field Topic.
func (c *Contract) GetTopicReference() *fhir.Reference {
	if c == nil {
		return nil
	}
	val, ok := c.Topic.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetType() *fhir.CodeableConcept {
	if c == nil {
		return nil
	}
	return c.Type
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetURL() *fhir.URI {
	if c == nil {
		return nil
	}
	return c.URL
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (c *Contract) GetVersion() *fhir.String {
	if c == nil {
		return nil
	}
	return c.Version
}

// Contract precursor content// Precusory content developed with a focus and intent of supporting the
// formation a Contract instance, which may be associated with and
// transformable into a Contract.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractContentDefinition struct {

	// A copyright statement relating to Contract precursor content. Copyright
	// statements are generally legal restrictions on the use and publishing of the
	// Contract precursor content.
	Copyright *fhir.Markdown `fhirpath:"copyright"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The date (and optionally time) when the contract was published. The date
	// must change when the business version changes and it must change if the
	// status code changes. In addition, it should change when the substantive
	// content of the contract changes.
	PublicationDate *fhir.DateTime `fhirpath:"publicationDate"`

	// amended | appended | cancelled | disputed | entered-in-error | executable |
	// executed | negotiable | offered | policy | rejected | renewed | revoked |
	// resolved | terminated.
	PublicationStatus *fhir.Code `fhirpath:"publicationStatus"`

	// The individual or organization that published the Contract precursor
	// content.
	Publisher *fhir.Reference `fhirpath:"publisher"`

	// Detailed Precusory content type.
	SubType *fhir.CodeableConcept `fhirpath:"subType"`

	// Precusory content structure and use, i.e., a boilerplate, template,
	// application for a contract such as an insurance policy or benefits under a
	// program, e.g., workers compensation.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCopyright returns the value of the field Copyright.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetCopyright() *fhir.Markdown {
	if ccd == nil {
		return nil
	}
	return ccd.Copyright
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetExtension() []*fhir.Extension {
	if ccd == nil {
		return nil
	}
	return ccd.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetID() string {
	if ccd == nil {
		return ""
	}
	return ccd.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetModifierExtension() []*fhir.Extension {
	if ccd == nil {
		return nil
	}
	return ccd.ModifierExtension
}

// GetPublicationDate returns the value of the field PublicationDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetPublicationDate() *fhir.DateTime {
	if ccd == nil {
		return nil
	}
	return ccd.PublicationDate
}

// GetPublicationStatus returns the value of the field PublicationStatus.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetPublicationStatus() *fhir.Code {
	if ccd == nil {
		return nil
	}
	return ccd.PublicationStatus
}

// GetPublisher returns the value of the field Publisher.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetPublisher() *fhir.Reference {
	if ccd == nil {
		return nil
	}
	return ccd.Publisher
}

// GetSubType returns the value of the field SubType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetSubType() *fhir.CodeableConcept {
	if ccd == nil {
		return nil
	}
	return ccd.SubType
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ccd *ContractContentDefinition) GetType() *fhir.CodeableConcept {
	if ccd == nil {
		return nil
	}
	return ccd.Type
}

// Contract Friendly Language// The "patient friendly language" versionof the Contract in whole or in parts.
// "Patient friendly language" means the representation of the Contract and
// Contract Provisions in a manner that is readily accessible and
// understandable by a layperson in accordance with best practices for
// communication styles that ensure that those agreeing to or signing the
// Contract understand the roles, actions, obligations, responsibilities, and
// implication of the agreement.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractFriendly struct {

	// Human readable rendering of this Contract in a format and representation
	// intended to enhance comprehension and ensure understandability.
	Content fhir.Element `fhirpath:"content"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetContent returns the value of the field Content.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cf *ContractFriendly) GetContent() fhir.Element {
	if cf == nil {
		return nil
	}
	return cf.Content
}

// GetContentAttachment returns the value of the field Content.
func (cf *ContractFriendly) GetContentAttachment() *fhir.Attachment {
	if cf == nil {
		return nil
	}
	val, ok := cf.Content.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetContentReference returns the value of the field Content.
func (cf *ContractFriendly) GetContentReference() *fhir.Reference {
	if cf == nil {
		return nil
	}
	val, ok := cf.Content.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cf *ContractFriendly) GetExtension() []*fhir.Extension {
	if cf == nil {
		return nil
	}
	return cf.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cf *ContractFriendly) GetID() string {
	if cf == nil {
		return ""
	}
	return cf.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cf *ContractFriendly) GetModifierExtension() []*fhir.Extension {
	if cf == nil {
		return nil
	}
	return cf.ModifierExtension
}

// Contract Legal Language// List of Legal expressions or representations of this Contract.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractLegal struct {

	// Contract legal text in human renderable form.
	Content fhir.Element `fhirpath:"content"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetContent returns the value of the field Content.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cl *ContractLegal) GetContent() fhir.Element {
	if cl == nil {
		return nil
	}
	return cl.Content
}

// GetContentAttachment returns the value of the field Content.
func (cl *ContractLegal) GetContentAttachment() *fhir.Attachment {
	if cl == nil {
		return nil
	}
	val, ok := cl.Content.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetContentReference returns the value of the field Content.
func (cl *ContractLegal) GetContentReference() *fhir.Reference {
	if cl == nil {
		return nil
	}
	val, ok := cl.Content.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cl *ContractLegal) GetExtension() []*fhir.Extension {
	if cl == nil {
		return nil
	}
	return cl.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cl *ContractLegal) GetID() string {
	if cl == nil {
		return ""
	}
	return cl.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cl *ContractLegal) GetModifierExtension() []*fhir.Extension {
	if cl == nil {
		return nil
	}
	return cl.ModifierExtension
}

// Computable Contract Language// List of Computable Policy Rule Language Representations of this Contract.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractRule struct {

	// Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL,
	// SecPal).
	Content fhir.Element `fhirpath:"content"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetContent returns the value of the field Content.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cr *ContractRule) GetContent() fhir.Element {
	if cr == nil {
		return nil
	}
	return cr.Content
}

// GetContentAttachment returns the value of the field Content.
func (cr *ContractRule) GetContentAttachment() *fhir.Attachment {
	if cr == nil {
		return nil
	}
	val, ok := cr.Content.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetContentReference returns the value of the field Content.
func (cr *ContractRule) GetContentReference() *fhir.Reference {
	if cr == nil {
		return nil
	}
	val, ok := cr.Content.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cr *ContractRule) GetExtension() []*fhir.Extension {
	if cr == nil {
		return nil
	}
	return cr.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cr *ContractRule) GetID() string {
	if cr == nil {
		return ""
	}
	return cr.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cr *ContractRule) GetModifierExtension() []*fhir.Extension {
	if cr == nil {
		return nil
	}
	return cr.ModifierExtension
}

// Contract Signatory// Parties with legal standing in the Contract, including the principal
// parties, the grantor(s) and grantee(s), which are any person or organization
// bound by the contract, and any ancillary parties, which facilitate the
// execution of the contract such as a notary or witness.// Signers who are principal parties to the contract are bound by the
// Contract.activity related to the Contract.topic, and the Contract.term(s),
// which either extend or restrict the overall action on the topic by, for
// example, stipulating specific policies or obligations constraining actions,
// action reason, or agents with respect to some or all of the topic. For
// example, specifying how policies or obligations shall constrain actions and
// action reasons permitted or denied on all or a subset of the Contract.topic
// (e.g., all or a portion of property being transferred by the contract),
// agents (e.g., who can resell, assign interests, or alter the property being
// transferred by the contract), actions, and action reasons; or with respect
// to Contract.terms, stipulating, extending, or limiting the Contract.period
// of applicability or valuation of items under consideration.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractSigner struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Party which is a signator to this Contract.
	Party *fhir.Reference `fhirpath:"party"`

	// Legally binding Contract DSIG signature contents in Base64.
	Signature []*fhir.Signature `fhirpath:"signature"`

	// Role of this Contract signer, e.g. notary, grantee.
	Type *fhir.Coding `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetExtension() []*fhir.Extension {
	if cs == nil {
		return nil
	}
	return cs.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetID() string {
	if cs == nil {
		return ""
	}
	return cs.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetModifierExtension() []*fhir.Extension {
	if cs == nil {
		return nil
	}
	return cs.ModifierExtension
}

// GetParty returns the value of the field Party.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetParty() *fhir.Reference {
	if cs == nil {
		return nil
	}
	return cs.Party
}

// GetSignature returns the value of the field Signature.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetSignature() []*fhir.Signature {
	if cs == nil {
		return nil
	}
	return cs.Signature
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cs *ContractSigner) GetType() *fhir.Coding {
	if cs == nil {
		return nil
	}
	return cs.Type
}

// Contract Term List// One or more Contract Provisions, which may be related and conveyed as a
// group, and may contain nested groups.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTerm struct {

	// An actor taking a role in an activity for which it can be assigned some
	// degree of responsibility for the activity taking place.
	Action []*ContractTermAction `fhirpath:"action"`

	// Relevant time or time-period when this Contract Provision is applicable.
	Applies *fhir.Period `fhirpath:"applies"`

	// Contract Term Asset List.
	Asset []*ContractTermAsset `fhirpath:"asset"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Unique identifier for this particular Contract Provision.
	Identifier *fhir.Identifier `fhirpath:"identifier"`

	// When this Contract Provision was issued.
	Issued *fhir.DateTime `fhirpath:"issued"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The matter of concern in the context of this provision of the agrement.
	Offer *ContractTermOffer `fhirpath:"offer"`

	// Security labels that protect the handling of information about the term and
	// its elements, which may be specifically identified..
	SecurityLabel []*ContractTermSecurityLabel `fhirpath:"securityLabel"`

	// A specialized legal clause or condition based on overarching contract type.
	SubType *fhir.CodeableConcept `fhirpath:"subType"`

	// Statement of a provision in a policy or a contract.
	Text *fhir.String `fhirpath:"text"`

	// The entity that the term applies to.
	Topic fhir.Element `fhirpath:"topic"`

	// A legal clause or condition contained within a contract that requires one or
	// both parties to perform a particular requirement by some specified time or
	// prevents one or both parties from performing a particular requirement by
	// some specified time.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAction returns the value of the field Action.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetAction() []*ContractTermAction {
	if ct == nil {
		return nil
	}
	return ct.Action
}

// GetApplies returns the value of the field Applies.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetApplies() *fhir.Period {
	if ct == nil {
		return nil
	}
	return ct.Applies
}

// GetAsset returns the value of the field Asset.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetAsset() []*ContractTermAsset {
	if ct == nil {
		return nil
	}
	return ct.Asset
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetExtension() []*fhir.Extension {
	if ct == nil {
		return nil
	}
	return ct.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetID() string {
	if ct == nil {
		return ""
	}
	return ct.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetIdentifier() *fhir.Identifier {
	if ct == nil {
		return nil
	}
	return ct.Identifier
}

// GetIssued returns the value of the field Issued.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetIssued() *fhir.DateTime {
	if ct == nil {
		return nil
	}
	return ct.Issued
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetModifierExtension() []*fhir.Extension {
	if ct == nil {
		return nil
	}
	return ct.ModifierExtension
}

// GetOffer returns the value of the field Offer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetOffer() *ContractTermOffer {
	if ct == nil {
		return nil
	}
	return ct.Offer
}

// GetSecurityLabel returns the value of the field SecurityLabel.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetSecurityLabel() []*ContractTermSecurityLabel {
	if ct == nil {
		return nil
	}
	return ct.SecurityLabel
}

// GetSubType returns the value of the field SubType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetSubType() *fhir.CodeableConcept {
	if ct == nil {
		return nil
	}
	return ct.SubType
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetText() *fhir.String {
	if ct == nil {
		return nil
	}
	return ct.Text
}

// GetTopic returns the value of the field Topic.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetTopic() fhir.Element {
	if ct == nil {
		return nil
	}
	return ct.Topic
}

// GetTopicCodeableConcept returns the value of the field Topic.
func (ct *ContractTerm) GetTopicCodeableConcept() *fhir.CodeableConcept {
	if ct == nil {
		return nil
	}
	val, ok := ct.Topic.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetTopicReference returns the value of the field Topic.
func (ct *ContractTerm) GetTopicReference() *fhir.Reference {
	if ct == nil {
		return nil
	}
	val, ok := ct.Topic.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ct *ContractTerm) GetType() *fhir.CodeableConcept {
	if ct == nil {
		return nil
	}
	return ct.Type
}

// Entity being ascribed responsibility// An actor taking a role in an activity for which it can be assigned some
// degree of responsibility for the activity taking place.// Several agents may be associated (i.e. has some responsibility for an
// activity) with an activity and vice-versa. For example, in cases of actions
// initiated by one user for other users, or in events that involve more than
// one user, hardware device, software, or system process. However, only one
// user may be the initiator/requestor for the event.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermAction struct {

	// Encounter or Episode with primary association to specified term activity.
	Context *fhir.Reference `fhirpath:"context"`

	// Id [identifier??] of the clause or question text related to the requester of
	// this action in the referenced form or QuestionnaireResponse.
	ContextLinkID []*fhir.String `fhirpath:"contextLinkId"`

	// True if the term prohibits the action.
	DoNotPerform *fhir.Boolean `fhirpath:"doNotPerform"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Reason or purpose for the action stipulated by this Contract Provision.
	Intent *fhir.CodeableConcept `fhirpath:"intent"`

	// Id [identifier??] of the clause or question text related to this action in
	// the referenced form or QuestionnaireResponse.
	LinkID []*fhir.String `fhirpath:"linkId"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Comments made about the term action made by the requester, performer,
	// subject or other participants.
	Note []*fhir.Annotation `fhirpath:"note"`

	// When action happens.
	Occurrence fhir.Element `fhirpath:"occurrence"`

	// Indicates who or what is being asked to perform (or not perform) the ction.
	Performer *fhir.Reference `fhirpath:"performer"`

	// Id [identifier??] of the clause or question text related to the reason type
	// or reference of this action in the referenced form or QuestionnaireResponse.
	PerformerLinkID []*fhir.String `fhirpath:"performerLinkId"`

	// The type of role or competency of an individual desired or required to
	// perform or not perform the action.
	PerformerRole *fhir.CodeableConcept `fhirpath:"performerRole"`

	// The type of individual that is desired or required to perform or not perform
	// the action.
	PerformerType []*fhir.CodeableConcept `fhirpath:"performerType"`

	// Describes why the action is to be performed or not performed in textual
	// form.
	Reason []*fhir.String `fhirpath:"reason"`

	// Rationale for the action to be performed or not performed. Describes why the
	// action is permitted or prohibited.
	ReasonCode []*fhir.CodeableConcept `fhirpath:"reasonCode"`

	// Id [identifier??] of the clause or question text related to the reason type
	// or reference of this action in the referenced form or QuestionnaireResponse.
	ReasonLinkID []*fhir.String `fhirpath:"reasonLinkId"`

	// Indicates another resource whose existence justifies permitting or not
	// permitting this action.
	ReasonReference []*fhir.Reference `fhirpath:"reasonReference"`

	// Who or what initiated the action and has responsibility for its activation.
	Requester []*fhir.Reference `fhirpath:"requester"`

	// Id [identifier??] of the clause or question text related to the requester of
	// this action in the referenced form or QuestionnaireResponse.
	RequesterLinkID []*fhir.String `fhirpath:"requesterLinkId"`

	// Security labels that protects the action.
	SecurityLabelNumber []*fhir.UnsignedInt `fhirpath:"securityLabelNumber"`

	// Current state of the term action.
	Status *fhir.CodeableConcept `fhirpath:"status"`

	// Entity of the action.
	Subject []*ContractTermActionSubject `fhirpath:"subject"`

	// Activity or service obligation to be done or not done, performed or not
	// performed, effectuated or not by this Contract term.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetContext returns the value of the field Context.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetContext() *fhir.Reference {
	if cta == nil {
		return nil
	}
	return cta.Context
}

// GetContextLinkID returns the value of the field ContextLinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetContextLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.ContextLinkID
}

// GetDoNotPerform returns the value of the field DoNotPerform.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetDoNotPerform() *fhir.Boolean {
	if cta == nil {
		return nil
	}
	return cta.DoNotPerform
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetExtension() []*fhir.Extension {
	if cta == nil {
		return nil
	}
	return cta.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetID() string {
	if cta == nil {
		return ""
	}
	return cta.ID
}

// GetIntent returns the value of the field Intent.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetIntent() *fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Intent
}

// GetLinkID returns the value of the field LinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.LinkID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetModifierExtension() []*fhir.Extension {
	if cta == nil {
		return nil
	}
	return cta.ModifierExtension
}

// GetNote returns the value of the field Note.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetNote() []*fhir.Annotation {
	if cta == nil {
		return nil
	}
	return cta.Note
}

// GetOccurrence returns the value of the field Occurrence.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetOccurrence() fhir.Element {
	if cta == nil {
		return nil
	}
	return cta.Occurrence
}

// GetOccurrenceDateTime returns the value of the field Occurrence.
func (cta *ContractTermAction) GetOccurrenceDateTime() *fhir.DateTime {
	if cta == nil {
		return nil
	}
	val, ok := cta.Occurrence.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetOccurrencePeriod returns the value of the field Occurrence.
func (cta *ContractTermAction) GetOccurrencePeriod() *fhir.Period {
	if cta == nil {
		return nil
	}
	val, ok := cta.Occurrence.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// GetOccurrenceTiming returns the value of the field Occurrence.
func (cta *ContractTermAction) GetOccurrenceTiming() *fhir.Timing {
	if cta == nil {
		return nil
	}
	val, ok := cta.Occurrence.(*fhir.Timing)
	if !ok {
		return nil
	}
	return val
} // GetPerformer returns the value of the field Performer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetPerformer() *fhir.Reference {
	if cta == nil {
		return nil
	}
	return cta.Performer
}

// GetPerformerLinkID returns the value of the field PerformerLinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetPerformerLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.PerformerLinkID
}

// GetPerformerRole returns the value of the field PerformerRole.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetPerformerRole() *fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.PerformerRole
}

// GetPerformerType returns the value of the field PerformerType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetPerformerType() []*fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.PerformerType
}

// GetReason returns the value of the field Reason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetReason() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.Reason
}

// GetReasonCode returns the value of the field ReasonCode.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetReasonCode() []*fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.ReasonCode
}

// GetReasonLinkID returns the value of the field ReasonLinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetReasonLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.ReasonLinkID
}

// GetReasonReference returns the value of the field ReasonReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetReasonReference() []*fhir.Reference {
	if cta == nil {
		return nil
	}
	return cta.ReasonReference
}

// GetRequester returns the value of the field Requester.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetRequester() []*fhir.Reference {
	if cta == nil {
		return nil
	}
	return cta.Requester
}

// GetRequesterLinkID returns the value of the field RequesterLinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetRequesterLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.RequesterLinkID
}

// GetSecurityLabelNumber returns the value of the field SecurityLabelNumber.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetSecurityLabelNumber() []*fhir.UnsignedInt {
	if cta == nil {
		return nil
	}
	return cta.SecurityLabelNumber
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetStatus() *fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Status
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetSubject() []*ContractTermActionSubject {
	if cta == nil {
		return nil
	}
	return cta.Subject
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAction) GetType() *fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Type
}

// Entity of the action// Entity of the action.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermActionSubject struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The entity the action is performed or not performed on or for.
	Reference []*fhir.Reference `fhirpath:"reference"`

	// Role type of agent assigned roles in this Contract.
	Role *fhir.CodeableConcept `fhirpath:"role"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctas *ContractTermActionSubject) GetExtension() []*fhir.Extension {
	if ctas == nil {
		return nil
	}
	return ctas.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctas *ContractTermActionSubject) GetID() string {
	if ctas == nil {
		return ""
	}
	return ctas.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctas *ContractTermActionSubject) GetModifierExtension() []*fhir.Extension {
	if ctas == nil {
		return nil
	}
	return ctas.ModifierExtension
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctas *ContractTermActionSubject) GetReference() []*fhir.Reference {
	if ctas == nil {
		return nil
	}
	return ctas.Reference
}

// GetRole returns the value of the field Role.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctas *ContractTermActionSubject) GetRole() *fhir.CodeableConcept {
	if ctas == nil {
		return nil
	}
	return ctas.Role
}

// Contract Term Asset List// Contract Term Asset List.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermAsset struct {

	// Description of the quality and completeness of the asset that imay be a
	// factor in its valuation.
	Condition *fhir.String `fhirpath:"condition"`

	// Circumstance of the asset.
	Context []*ContractTermAssetContext `fhirpath:"context"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Id [identifier??] of the clause or question text about the asset in the
	// referenced form or QuestionnaireResponse.
	LinkID []*fhir.String `fhirpath:"linkId"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Asset relevant contractual time period.
	Period []*fhir.Period `fhirpath:"period"`

	// Type of Asset availability for use or ownership.
	PeriodType []*fhir.CodeableConcept `fhirpath:"periodType"`

	// Specifies the applicability of the term to an asset resource instance, and
	// instances it refers to orinstances that refer to it, and/or are owned by the
	// offeree.
	Relationship *fhir.Coding `fhirpath:"relationship"`

	// Differentiates the kind of the asset .
	Scope *fhir.CodeableConcept `fhirpath:"scope"`

	// Security labels that protects the asset.
	SecurityLabelNumber []*fhir.UnsignedInt `fhirpath:"securityLabelNumber"`

	// May be a subtype or part of an offered asset.
	Subtype []*fhir.CodeableConcept `fhirpath:"subtype"`

	// Clause or question text (Prose Object) concerning the asset in a linked
	// form, such as a QuestionnaireResponse used in the formation of the contract.
	Text *fhir.String `fhirpath:"text"`

	// Target entity type about which the term may be concerned.
	Type []*fhir.CodeableConcept `fhirpath:"type"`

	// Associated entities.
	TypeReference []*fhir.Reference `fhirpath:"typeReference"`

	// Time period of asset use.
	UsePeriod []*fhir.Period `fhirpath:"usePeriod"`

	// Contract Valued Item List.
	ValuedItem []*ContractTermAssetValuedItem `fhirpath:"valuedItem"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCondition returns the value of the field Condition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetCondition() *fhir.String {
	if cta == nil {
		return nil
	}
	return cta.Condition
}

// GetContext returns the value of the field Context.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetContext() []*ContractTermAssetContext {
	if cta == nil {
		return nil
	}
	return cta.Context
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetExtension() []*fhir.Extension {
	if cta == nil {
		return nil
	}
	return cta.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetID() string {
	if cta == nil {
		return ""
	}
	return cta.ID
}

// GetLinkID returns the value of the field LinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetLinkID() []*fhir.String {
	if cta == nil {
		return nil
	}
	return cta.LinkID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetModifierExtension() []*fhir.Extension {
	if cta == nil {
		return nil
	}
	return cta.ModifierExtension
}

// GetPeriod returns the value of the field Period.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetPeriod() []*fhir.Period {
	if cta == nil {
		return nil
	}
	return cta.Period
}

// GetPeriodType returns the value of the field PeriodType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetPeriodType() []*fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.PeriodType
}

// GetRelationship returns the value of the field Relationship.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetRelationship() *fhir.Coding {
	if cta == nil {
		return nil
	}
	return cta.Relationship
}

// GetScope returns the value of the field Scope.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetScope() *fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Scope
}

// GetSecurityLabelNumber returns the value of the field SecurityLabelNumber.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetSecurityLabelNumber() []*fhir.UnsignedInt {
	if cta == nil {
		return nil
	}
	return cta.SecurityLabelNumber
}

// GetSubtype returns the value of the field Subtype.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetSubtype() []*fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Subtype
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetText() *fhir.String {
	if cta == nil {
		return nil
	}
	return cta.Text
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetType() []*fhir.CodeableConcept {
	if cta == nil {
		return nil
	}
	return cta.Type
}

// GetTypeReference returns the value of the field TypeReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetTypeReference() []*fhir.Reference {
	if cta == nil {
		return nil
	}
	return cta.TypeReference
}

// GetUsePeriod returns the value of the field UsePeriod.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetUsePeriod() []*fhir.Period {
	if cta == nil {
		return nil
	}
	return cta.UsePeriod
}

// GetValuedItem returns the value of the field ValuedItem.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cta *ContractTermAsset) GetValuedItem() []*ContractTermAssetValuedItem {
	if cta == nil {
		return nil
	}
	return cta.ValuedItem
}

// Circumstance of the asset// Circumstance of the asset.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermAssetContext struct {

	// Coded representation of the context generally or of the Referenced entity,
	// such as the asset holder type or location.
	Code []*fhir.CodeableConcept `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Asset context reference may include the creator, custodian, or owning Person
	// or Organization (e.g., bank, repository), location held, e.g., building,
	// jurisdiction.
	Reference *fhir.Reference `fhirpath:"reference"`

	// Context description.
	Text *fhir.String `fhirpath:"text"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetCode() []*fhir.CodeableConcept {
	if ctac == nil {
		return nil
	}
	return ctac.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetExtension() []*fhir.Extension {
	if ctac == nil {
		return nil
	}
	return ctac.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetID() string {
	if ctac == nil {
		return ""
	}
	return ctac.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetModifierExtension() []*fhir.Extension {
	if ctac == nil {
		return nil
	}
	return ctac.ModifierExtension
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetReference() *fhir.Reference {
	if ctac == nil {
		return nil
	}
	return ctac.Reference
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctac *ContractTermAssetContext) GetText() *fhir.String {
	if ctac == nil {
		return nil
	}
	return ctac.Text
}

// Contract Valued Item List// Contract Valued Item List.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermAssetValuedItem struct {

	// Indicates the time during which this Contract ValuedItem information is
	// effective.
	EffectiveTime *fhir.DateTime `fhirpath:"effectiveTime"`

	// Specific type of Contract Valued Item that may be priced.
	Entity fhir.Element `fhirpath:"entity"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// A real number that represents a multiplier used in determining the overall
	// value of the Contract Valued Item delivered. The concept of a Factor allows
	// for a discount or surcharge multiplier to be applied to a monetary amount.
	Factor *fhir.Decimal `fhirpath:"factor"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Identifies a Contract Valued Item instance.
	Identifier *fhir.Identifier `fhirpath:"identifier"`

	// Id of the clause or question text related to the context of this valuedItem
	// in the referenced form or QuestionnaireResponse.
	LinkID []*fhir.String `fhirpath:"linkId"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Expresses the product of the Contract Valued Item unitQuantity and the
	// unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per
	// Point) * factor Number * points = net Amount. Quantity, factor and points
	// are assumed to be 1 if not supplied.
	Net *fhir.Money `fhirpath:"net"`

	// Terms of valuation.
	Payment *fhir.String `fhirpath:"payment"`

	// When payment is due.
	PaymentDate *fhir.DateTime `fhirpath:"paymentDate"`

	// An amount that expresses the weighting (based on difficulty, cost and/or
	// resource intensiveness) associated with the Contract Valued Item delivered.
	// The concept of Points allows for assignment of point values for a Contract
	// Valued Item, such that a monetary amount can be assigned to each point.
	Points *fhir.Decimal `fhirpath:"points"`

	// Specifies the units by which the Contract Valued Item is measured or
	// counted, and quantifies the countable or measurable Contract Valued Item
	// instances.
	Quantity *fhir.Quantity `fhirpath:"quantity"`

	// Who will receive payment.
	Recipient *fhir.Reference `fhirpath:"recipient"`

	// Who will make payment.
	Responsible *fhir.Reference `fhirpath:"responsible"`

	// A set of security labels that define which terms are controlled by this
	// condition.
	SecurityLabelNumber []*fhir.UnsignedInt `fhirpath:"securityLabelNumber"`

	// A Contract Valued Item unit valuation measure.
	UnitPrice *fhir.Money `fhirpath:"unitPrice"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetEffectiveTime returns the value of the field EffectiveTime.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetEffectiveTime() *fhir.DateTime {
	if ctavi == nil {
		return nil
	}
	return ctavi.EffectiveTime
}

// GetEntity returns the value of the field Entity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetEntity() fhir.Element {
	if ctavi == nil {
		return nil
	}
	return ctavi.Entity
}

// GetEntityCodeableConcept returns the value of the field Entity.
func (ctavi *ContractTermAssetValuedItem) GetEntityCodeableConcept() *fhir.CodeableConcept {
	if ctavi == nil {
		return nil
	}
	val, ok := ctavi.Entity.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetEntityReference returns the value of the field Entity.
func (ctavi *ContractTermAssetValuedItem) GetEntityReference() *fhir.Reference {
	if ctavi == nil {
		return nil
	}
	val, ok := ctavi.Entity.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetExtension() []*fhir.Extension {
	if ctavi == nil {
		return nil
	}
	return ctavi.Extension
}

// GetFactor returns the value of the field Factor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetFactor() *fhir.Decimal {
	if ctavi == nil {
		return nil
	}
	return ctavi.Factor
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetID() string {
	if ctavi == nil {
		return ""
	}
	return ctavi.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetIdentifier() *fhir.Identifier {
	if ctavi == nil {
		return nil
	}
	return ctavi.Identifier
}

// GetLinkID returns the value of the field LinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetLinkID() []*fhir.String {
	if ctavi == nil {
		return nil
	}
	return ctavi.LinkID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetModifierExtension() []*fhir.Extension {
	if ctavi == nil {
		return nil
	}
	return ctavi.ModifierExtension
}

// GetNet returns the value of the field Net.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetNet() *fhir.Money {
	if ctavi == nil {
		return nil
	}
	return ctavi.Net
}

// GetPayment returns the value of the field Payment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetPayment() *fhir.String {
	if ctavi == nil {
		return nil
	}
	return ctavi.Payment
}

// GetPaymentDate returns the value of the field PaymentDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetPaymentDate() *fhir.DateTime {
	if ctavi == nil {
		return nil
	}
	return ctavi.PaymentDate
}

// GetPoints returns the value of the field Points.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetPoints() *fhir.Decimal {
	if ctavi == nil {
		return nil
	}
	return ctavi.Points
}

// GetQuantity returns the value of the field Quantity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetQuantity() *fhir.Quantity {
	if ctavi == nil {
		return nil
	}
	return ctavi.Quantity
}

// GetRecipient returns the value of the field Recipient.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetRecipient() *fhir.Reference {
	if ctavi == nil {
		return nil
	}
	return ctavi.Recipient
}

// GetResponsible returns the value of the field Responsible.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetResponsible() *fhir.Reference {
	if ctavi == nil {
		return nil
	}
	return ctavi.Responsible
}

// GetSecurityLabelNumber returns the value of the field SecurityLabelNumber.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetSecurityLabelNumber() []*fhir.UnsignedInt {
	if ctavi == nil {
		return nil
	}
	return ctavi.SecurityLabelNumber
}

// GetUnitPrice returns the value of the field UnitPrice.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctavi *ContractTermAssetValuedItem) GetUnitPrice() *fhir.Money {
	if ctavi == nil {
		return nil
	}
	return ctavi.UnitPrice
}

// Context of the Contract term// The matter of concern in the context of this provision of the agrement.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermOffer struct {

	// Response to offer text.
	Answer []*ContractTermOfferAnswer `fhirpath:"answer"`

	// Type of choice made by accepting party with respect to an offer made by an
	// offeror/ grantee.
	Decision *fhir.CodeableConcept `fhirpath:"decision"`

	// How the decision about a Contract was conveyed.
	DecisionMode []*fhir.CodeableConcept `fhirpath:"decisionMode"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Unique identifier for this particular Contract Provision.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// The id of the clause or question text of the offer in the referenced
	// questionnaire/response.
	LinkID []*fhir.String `fhirpath:"linkId"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Offer Recipient.
	Party []*ContractTermOfferParty `fhirpath:"party"`

	// Security labels that protects the offer.
	SecurityLabelNumber []*fhir.UnsignedInt `fhirpath:"securityLabelNumber"`

	// Human readable form of this Contract Offer.
	Text *fhir.String `fhirpath:"text"`

	// The owner of an asset has the residual control rights over the asset: the
	// right to decide all usages of the asset in any way not inconsistent with a
	// prior contract, custom, or law (Hart, 1995, p. 30).
	Topic *fhir.Reference `fhirpath:"topic"`

	// Type of Contract Provision such as specific requirements, purposes for
	// actions, obligations, prohibitions, e.g. life time maximum benefit.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAnswer returns the value of the field Answer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetAnswer() []*ContractTermOfferAnswer {
	if cto == nil {
		return nil
	}
	return cto.Answer
}

// GetDecision returns the value of the field Decision.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetDecision() *fhir.CodeableConcept {
	if cto == nil {
		return nil
	}
	return cto.Decision
}

// GetDecisionMode returns the value of the field DecisionMode.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetDecisionMode() []*fhir.CodeableConcept {
	if cto == nil {
		return nil
	}
	return cto.DecisionMode
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetExtension() []*fhir.Extension {
	if cto == nil {
		return nil
	}
	return cto.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetID() string {
	if cto == nil {
		return ""
	}
	return cto.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetIdentifier() []*fhir.Identifier {
	if cto == nil {
		return nil
	}
	return cto.Identifier
}

// GetLinkID returns the value of the field LinkID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetLinkID() []*fhir.String {
	if cto == nil {
		return nil
	}
	return cto.LinkID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetModifierExtension() []*fhir.Extension {
	if cto == nil {
		return nil
	}
	return cto.ModifierExtension
}

// GetParty returns the value of the field Party.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetParty() []*ContractTermOfferParty {
	if cto == nil {
		return nil
	}
	return cto.Party
}

// GetSecurityLabelNumber returns the value of the field SecurityLabelNumber.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetSecurityLabelNumber() []*fhir.UnsignedInt {
	if cto == nil {
		return nil
	}
	return cto.SecurityLabelNumber
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetText() *fhir.String {
	if cto == nil {
		return nil
	}
	return cto.Text
}

// GetTopic returns the value of the field Topic.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetTopic() *fhir.Reference {
	if cto == nil {
		return nil
	}
	return cto.Topic
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cto *ContractTermOffer) GetType() *fhir.CodeableConcept {
	if cto == nil {
		return nil
	}
	return cto.Type
}

// Response to offer text// Response to offer text.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermOfferAnswer struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Response to an offer clause or question text, which enables selection of
	// values to be agreed to, e.g., the period of participation, the date of
	// occupancy of a rental, warrently duration, or whether biospecimen may be
	// used for further research.
	Value fhir.Element `fhirpath:"value"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctoa *ContractTermOfferAnswer) GetExtension() []*fhir.Extension {
	if ctoa == nil {
		return nil
	}
	return ctoa.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctoa *ContractTermOfferAnswer) GetID() string {
	if ctoa == nil {
		return ""
	}
	return ctoa.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctoa *ContractTermOfferAnswer) GetModifierExtension() []*fhir.Extension {
	if ctoa == nil {
		return nil
	}
	return ctoa.ModifierExtension
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctoa *ContractTermOfferAnswer) GetValue() fhir.Element {
	if ctoa == nil {
		return nil
	}
	return ctoa.Value
}

// GetValueBoolean returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueBoolean() *fhir.Boolean {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetValueDecimal returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueDecimal() *fhir.Decimal {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Decimal)
	if !ok {
		return nil
	}
	return val
}

// GetValueInteger returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueInteger() *fhir.Integer {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Integer)
	if !ok {
		return nil
	}
	return val
}

// GetValueDate returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueDate() *fhir.Date {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Date)
	if !ok {
		return nil
	}
	return val
}

// GetValueDateTime returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueDateTime() *fhir.DateTime {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetValueTime returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueTime() *fhir.Time {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Time)
	if !ok {
		return nil
	}
	return val
}

// GetValueString returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueString() *fhir.String {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.String)
	if !ok {
		return nil
	}
	return val
}

// GetValueURI returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueURI() *fhir.URI {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.URI)
	if !ok {
		return nil
	}
	return val
}

// GetValueAttachment returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueAttachment() *fhir.Attachment {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Attachment)
	if !ok {
		return nil
	}
	return val
}

// GetValueCoding returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueCoding() *fhir.Coding {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Coding)
	if !ok {
		return nil
	}
	return val
}

// GetValueQuantity returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueQuantity() *fhir.Quantity {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetValueReference returns the value of the field Value.
func (ctoa *ContractTermOfferAnswer) GetValueReference() *fhir.Reference {
	if ctoa == nil {
		return nil
	}
	val, ok := ctoa.Value.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
}

// Offer Recipient// Offer Recipient.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermOfferParty struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Participant in the offer.
	Reference []*fhir.Reference `fhirpath:"reference"`

	// How the party participates in the offer.
	Role *fhir.CodeableConcept `fhirpath:"role"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctop *ContractTermOfferParty) GetExtension() []*fhir.Extension {
	if ctop == nil {
		return nil
	}
	return ctop.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctop *ContractTermOfferParty) GetID() string {
	if ctop == nil {
		return ""
	}
	return ctop.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctop *ContractTermOfferParty) GetModifierExtension() []*fhir.Extension {
	if ctop == nil {
		return nil
	}
	return ctop.ModifierExtension
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctop *ContractTermOfferParty) GetReference() []*fhir.Reference {
	if ctop == nil {
		return nil
	}
	return ctop.Reference
}

// GetRole returns the value of the field Role.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctop *ContractTermOfferParty) GetRole() *fhir.CodeableConcept {
	if ctop == nil {
		return nil
	}
	return ctop.Role
}

// Protection for the Term// Security labels that protect the handling of information about the term and
// its elements, which may be specifically identified..
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Contract.json
type ContractTermSecurityLabel struct {

	// Security label privacy tag that species the applicable privacy and security
	// policies governing this term and/or term elements.
	Category []*fhir.Coding `fhirpath:"category"`

	// Security label privacy tag that species the level of confidentiality
	// protection required for this term and/or term elements.
	Classification *fhir.Coding `fhirpath:"classification"`

	// Security label privacy tag that species the manner in which term and/or term
	// elements are to be protected.
	Control []*fhir.Coding `fhirpath:"control"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Number used to link this term or term element to the applicable Security
	// Label.
	Number []*fhir.UnsignedInt `fhirpath:"number"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetCategory() []*fhir.Coding {
	if ctsl == nil {
		return nil
	}
	return ctsl.Category
}

// GetClassification returns the value of the field Classification.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetClassification() *fhir.Coding {
	if ctsl == nil {
		return nil
	}
	return ctsl.Classification
}

// GetControl returns the value of the field Control.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetControl() []*fhir.Coding {
	if ctsl == nil {
		return nil
	}
	return ctsl.Control
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetExtension() []*fhir.Extension {
	if ctsl == nil {
		return nil
	}
	return ctsl.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetID() string {
	if ctsl == nil {
		return ""
	}
	return ctsl.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetModifierExtension() []*fhir.Extension {
	if ctsl == nil {
		return nil
	}
	return ctsl.ModifierExtension
}

// GetNumber returns the value of the field Number.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ctsl *ContractTermSecurityLabel) GetNumber() []*fhir.UnsignedInt {
	if ctsl == nil {
		return nil
	}
	return ctsl.Number
}
