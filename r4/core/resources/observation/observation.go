// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package observation

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// Measurements and simple assertions made about a patient, device or other
// subject.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Observation
//   - Source File: StructureDefinition-Observation.json
type Observation struct {

	// A plan, proposal or order that is fulfilled in whole or in part by this
	// event. For example, a MedicationRequest may require a patient to have
	// laboratory test performed before it is dispensed.
	BasedOn []*fhir.Reference `fhirpath:"basedOn"`

	// Indicates the site on the subject's body where the observation was made
	// (i.e. the target site).
	BodySite *fhir.CodeableConcept `fhirpath:"bodySite"`

	// A code that classifies the general type of observation being made.
	Category []*fhir.CodeableConcept `fhirpath:"category"`

	// Describes what was observed. Sometimes this is called the observation
	// "name".
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// Some observations have multiple component observations. These component
	// observations are expressed as separate code value pairs that share the same
	// attributes. Examples include systolic and diastolic component observations
	// for blood pressure measurement and multiple component observations for
	// genetics observations.
	Component []*ObservationComponent `fhirpath:"component"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// Provides a reason why the expected value in the element Observation.value[x]
	// is missing.
	DataAbsentReason *fhir.CodeableConcept `fhirpath:"dataAbsentReason"`

	// The target resource that represents a measurement from which this
	// observation value is derived. For example, a calculated anion gap or a fetal
	// measurement based on an ultrasound image.
	DerivedFrom []*fhir.Reference `fhirpath:"derivedFrom"`

	// The device used to generate the observation data.
	Device *fhir.Reference `fhirpath:"device"`

	// The time or time-period the observed value is asserted as being true. For
	// biological subjects - e.g. human patients - this is usually called the
	// "physiologically relevant time". This is usually either the time of the
	// procedure or of specimen collection, but very often the source of the
	// date/time is not known, only the date/time itself.
	Effective fhir.Element `fhirpath:"effective"`

	// The healthcare event (e.g. a patient and healthcare provider interaction)
	// during which this observation is made.
	Encounter *fhir.Reference `fhirpath:"encounter"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The actual focus of an observation when it is not the patient of record
	// representing something or someone associated with the patient such as a
	// spouse, parent, fetus, or donor. For example, fetus observations in a
	// mother's record. The focus of an observation could also be an existing
	// condition, an intervention, the subject's diet, another observation of the
	// subject, or a body structure such as tumor or implanted device. An example
	// use case would be using the Observation resource to capture whether the
	// mother is trained to change her child's tracheostomy tube. In this example,
	// the child is the patient of record and the mother is the focus.
	Focus []*fhir.Reference `fhirpath:"focus"`

	// This observation is a group observation (e.g. a battery, a panel of tests, a
	// set of vital sign measurements) that includes the target as a member of the
	// group.
	HasMember []*fhir.Reference `fhirpath:"hasMember"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// A unique identifier assigned to this observation.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// A categorical assessment of an observation value. For example, high, low,
	// normal.
	Interpretation []*fhir.CodeableConcept `fhirpath:"interpretation"`

	// The date and time this version of the observation was made available to
	// providers, typically after the results have been reviewed and verified.
	Issued *fhir.Instant `fhirpath:"issued"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// Indicates the mechanism used to perform the observation.
	Method *fhir.CodeableConcept `fhirpath:"method"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Comments about the observation or the results.
	Note []*fhir.Annotation `fhirpath:"note"`

	// A larger event of which this particular Observation is a component or step.
	// For example, an observation as part of a procedure.
	PartOf []*fhir.Reference `fhirpath:"partOf"`

	// Who was responsible for asserting the observed value as "true".
	Performer []*fhir.Reference `fhirpath:"performer"`

	// Guidance on how to interpret the value by comparison to a normal or
	// recommended range. Multiple reference ranges are interpreted as an "OR". In
	// other words, to represent two distinct target populations, two
	// `referenceRange` elements would be used.
	ReferenceRange []*ObservationReferenceRange `fhirpath:"referenceRange"`

	// The specimen that was used when this observation was made.
	Specimen *fhir.Reference `fhirpath:"specimen"`

	// The status of the result value.
	Status *fhir.Code `fhirpath:"status"`

	// The patient, or group of patients, location, or device this observation is
	// about and into whose record the observation is placed. If the actual focus
	// of the observation is different from the subject (or a sample of, part, or
	// region of the subject), the `focus` element or the `code` itself specifies
	// the actual focus of the observation.
	Subject *fhir.Reference `fhirpath:"subject"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	Value fhir.Element `fhirpath:"value"`

	profileimpl.BaseObservation
	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetBasedOn returns the value of the field BasedOn.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetBasedOn() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.BasedOn
}

// GetBodySite returns the value of the field BodySite.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetBodySite() *fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.BodySite
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetCategory() []*fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.Category
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetCode() *fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.Code
}

// GetComponent returns the value of the field Component.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetComponent() []*ObservationComponent {
	if o == nil {
		return nil
	}
	return o.Component
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetContained() []fhir.Resource {
	if o == nil {
		return nil
	}
	return o.Contained
}

// GetDataAbsentReason returns the value of the field DataAbsentReason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetDataAbsentReason() *fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.DataAbsentReason
}

// GetDerivedFrom returns the value of the field DerivedFrom.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetDerivedFrom() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.DerivedFrom
}

// GetDevice returns the value of the field Device.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetDevice() *fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Device
}

// GetEffective returns the value of the field Effective.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetEffective() fhir.Element {
	if o == nil {
		return nil
	}
	return o.Effective
}

// GetEffectiveDateTime returns the value of the field Effective.
func (o *Observation) GetEffectiveDateTime() *fhir.DateTime {
	if o == nil {
		return nil
	}
	val, ok := o.Effective.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetEffectivePeriod returns the value of the field Effective.
func (o *Observation) GetEffectivePeriod() *fhir.Period {
	if o == nil {
		return nil
	}
	val, ok := o.Effective.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// GetEffectiveTiming returns the value of the field Effective.
func (o *Observation) GetEffectiveTiming() *fhir.Timing {
	if o == nil {
		return nil
	}
	val, ok := o.Effective.(*fhir.Timing)
	if !ok {
		return nil
	}
	return val
}

// GetEffectiveInstant returns the value of the field Effective.
func (o *Observation) GetEffectiveInstant() *fhir.Instant {
	if o == nil {
		return nil
	}
	val, ok := o.Effective.(*fhir.Instant)
	if !ok {
		return nil
	}
	return val
} // GetEncounter returns the value of the field Encounter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetEncounter() *fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Encounter
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetExtension() []*fhir.Extension {
	if o == nil {
		return nil
	}
	return o.Extension
}

// GetFocus returns the value of the field Focus.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetFocus() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Focus
}

// GetHasMember returns the value of the field HasMember.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetHasMember() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.HasMember
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetIdentifier() []*fhir.Identifier {
	if o == nil {
		return nil
	}
	return o.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetImplicitRules() *fhir.URI {
	if o == nil {
		return nil
	}
	return o.ImplicitRules
}

// GetInterpretation returns the value of the field Interpretation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetInterpretation() []*fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.Interpretation
}

// GetIssued returns the value of the field Issued.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetIssued() *fhir.Instant {
	if o == nil {
		return nil
	}
	return o.Issued
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetLanguage() *fhir.Code {
	if o == nil {
		return nil
	}
	return o.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetMeta() *fhir.Meta {
	if o == nil {
		return nil
	}
	return o.Meta
}

// GetMethod returns the value of the field Method.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetMethod() *fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	return o.Method
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetModifierExtension() []*fhir.Extension {
	if o == nil {
		return nil
	}
	return o.ModifierExtension
}

// GetNote returns the value of the field Note.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetNote() []*fhir.Annotation {
	if o == nil {
		return nil
	}
	return o.Note
}

// GetPartOf returns the value of the field PartOf.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetPartOf() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.PartOf
}

// GetPerformer returns the value of the field Performer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetPerformer() []*fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Performer
}

// GetReferenceRange returns the value of the field ReferenceRange.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetReferenceRange() []*ObservationReferenceRange {
	if o == nil {
		return nil
	}
	return o.ReferenceRange
}

// GetSpecimen returns the value of the field Specimen.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetSpecimen() *fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Specimen
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetStatus() *fhir.Code {
	if o == nil {
		return nil
	}
	return o.Status
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetSubject() *fhir.Reference {
	if o == nil {
		return nil
	}
	return o.Subject
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetText() *fhir.Narrative {
	if o == nil {
		return nil
	}
	return o.Text
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (o *Observation) GetValue() fhir.Element {
	if o == nil {
		return nil
	}
	return o.Value
}

// GetValueQuantity returns the value of the field Value.
func (o *Observation) GetValueQuantity() *fhir.Quantity {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetValueCodeableConcept returns the value of the field Value.
func (o *Observation) GetValueCodeableConcept() *fhir.CodeableConcept {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetValueString returns the value of the field Value.
func (o *Observation) GetValueString() *fhir.String {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.String)
	if !ok {
		return nil
	}
	return val
}

// GetValueBoolean returns the value of the field Value.
func (o *Observation) GetValueBoolean() *fhir.Boolean {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetValueInteger returns the value of the field Value.
func (o *Observation) GetValueInteger() *fhir.Integer {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Integer)
	if !ok {
		return nil
	}
	return val
}

// GetValueRange returns the value of the field Value.
func (o *Observation) GetValueRange() *fhir.Range {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetValueRatio returns the value of the field Value.
func (o *Observation) GetValueRatio() *fhir.Ratio {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetValueSampledData returns the value of the field Value.
func (o *Observation) GetValueSampledData() *fhir.SampledData {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetValueTime returns the value of the field Value.
func (o *Observation) GetValueTime() *fhir.Time {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Time)
	if !ok {
		return nil
	}
	return val
}

// GetValueDateTime returns the value of the field Value.
func (o *Observation) GetValueDateTime() *fhir.DateTime {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetValuePeriod returns the value of the field Value.
func (o *Observation) GetValuePeriod() *fhir.Period {
	if o == nil {
		return nil
	}
	val, ok := o.Value.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// Component results// Some observations have multiple component observations. These component
// observations are expressed as separate code value pairs that share the same
// attributes. Examples include systolic and diastolic component observations
// for blood pressure measurement and multiple component observations for
// genetics observations.// For a discussion on the ways Observations can be assembled in groups
// together see [Notes](observation.html#notes) below.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Observation.json
type ObservationComponent struct {

	// Describes what was observed. Sometimes this is called the observation
	// "code".
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// Provides a reason why the expected value in the element
	// Observation.component.value[x] is missing.
	DataAbsentReason *fhir.CodeableConcept `fhirpath:"dataAbsentReason"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// A categorical assessment of an observation value. For example, high, low,
	// normal.
	Interpretation []*fhir.CodeableConcept `fhirpath:"interpretation"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The information determined as a result of making the observation, if the
	// information has a simple value.
	Value fhir.Element `fhirpath:"value"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetCode() *fhir.CodeableConcept {
	if oc == nil {
		return nil
	}
	return oc.Code
}

// GetDataAbsentReason returns the value of the field DataAbsentReason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetDataAbsentReason() *fhir.CodeableConcept {
	if oc == nil {
		return nil
	}
	return oc.DataAbsentReason
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetExtension() []*fhir.Extension {
	if oc == nil {
		return nil
	}
	return oc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetID() string {
	if oc == nil {
		return ""
	}
	return oc.ID
}

// GetInterpretation returns the value of the field Interpretation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetInterpretation() []*fhir.CodeableConcept {
	if oc == nil {
		return nil
	}
	return oc.Interpretation
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetModifierExtension() []*fhir.Extension {
	if oc == nil {
		return nil
	}
	return oc.ModifierExtension
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (oc *ObservationComponent) GetValue() fhir.Element {
	if oc == nil {
		return nil
	}
	return oc.Value
}

// GetValueQuantity returns the value of the field Value.
func (oc *ObservationComponent) GetValueQuantity() *fhir.Quantity {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetValueCodeableConcept returns the value of the field Value.
func (oc *ObservationComponent) GetValueCodeableConcept() *fhir.CodeableConcept {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetValueString returns the value of the field Value.
func (oc *ObservationComponent) GetValueString() *fhir.String {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.String)
	if !ok {
		return nil
	}
	return val
}

// GetValueBoolean returns the value of the field Value.
func (oc *ObservationComponent) GetValueBoolean() *fhir.Boolean {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Boolean)
	if !ok {
		return nil
	}
	return val
}

// GetValueInteger returns the value of the field Value.
func (oc *ObservationComponent) GetValueInteger() *fhir.Integer {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Integer)
	if !ok {
		return nil
	}
	return val
}

// GetValueRange returns the value of the field Value.
func (oc *ObservationComponent) GetValueRange() *fhir.Range {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetValueRatio returns the value of the field Value.
func (oc *ObservationComponent) GetValueRatio() *fhir.Ratio {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetValueSampledData returns the value of the field Value.
func (oc *ObservationComponent) GetValueSampledData() *fhir.SampledData {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.SampledData)
	if !ok {
		return nil
	}
	return val
}

// GetValueTime returns the value of the field Value.
func (oc *ObservationComponent) GetValueTime() *fhir.Time {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Time)
	if !ok {
		return nil
	}
	return val
}

// GetValueDateTime returns the value of the field Value.
func (oc *ObservationComponent) GetValueDateTime() *fhir.DateTime {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetValuePeriod returns the value of the field Value.
func (oc *ObservationComponent) GetValuePeriod() *fhir.Period {
	if oc == nil {
		return nil
	}
	val, ok := oc.Value.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// Provides guide for interpretation// Guidance on how to interpret the value by comparison to a normal or
// recommended range. Multiple reference ranges are interpreted as an "OR". In
// other words, to represent two distinct target populations, two
// `referenceRange` elements would be used.// Most observations only have one generic reference range. Systems MAY choose
// to restrict to only supplying the relevant reference range based on
// knowledge about the patient (e.g., specific to the patient's age, gender,
// weight and other factors), but this might not be possible or appropriate.
// Whenever more than one reference range is supplied, the differences between
// them SHOULD be provided in the reference range and/or age properties.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Observation.json
type ObservationReferenceRange struct {

	// The age at which this reference range is applicable. This is a neonatal age
	// (e.g. number of weeks at term) if the meaning says so.
	Age *fhir.Range `fhirpath:"age"`

	// Codes to indicate the target population this reference range applies to. For
	// example, a reference range may be based on the normal population or a
	// particular sex or race. Multiple `appliesTo` are interpreted as an "AND" of
	// the target populations. For example, to represent a target population of
	// African American females, both a code of female and a code for African
	// American would be used.
	AppliesTo []*fhir.CodeableConcept `fhirpath:"appliesTo"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The value of the high bound of the reference range. The high bound of the
	// reference range endpoint is inclusive of the value (e.g. reference range is
	// >=5 - <=9). If the high bound is omitted, it is assumed to be meaningless
	// (e.g. reference range is >= 2.3).
	High *fhir.Quantity `fhirpath:"high"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The value of the low bound of the reference range. The low bound of the
	// reference range endpoint is inclusive of the value (e.g. reference range is
	// >=5 - <=9). If the low bound is omitted, it is assumed to be meaningless
	// (e.g. reference range is <=2.3).
	Low *fhir.Quantity `fhirpath:"low"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Text based reference range in an observation which may be used when a
	// quantitative range is not appropriate for an observation. An example would
	// be a reference value of "Negative" or a list or table of "normals".
	Text *fhir.String `fhirpath:"text"`

	// Codes to indicate the what part of the targeted reference population it
	// applies to. For example, the normal or therapeutic range.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAge returns the value of the field Age.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetAge() *fhir.Range {
	if orr == nil {
		return nil
	}
	return orr.Age
}

// GetAppliesTo returns the value of the field AppliesTo.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetAppliesTo() []*fhir.CodeableConcept {
	if orr == nil {
		return nil
	}
	return orr.AppliesTo
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetExtension() []*fhir.Extension {
	if orr == nil {
		return nil
	}
	return orr.Extension
}

// GetHigh returns the value of the field High.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetHigh() *fhir.Quantity {
	if orr == nil {
		return nil
	}
	return orr.High
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetID() string {
	if orr == nil {
		return ""
	}
	return orr.ID
}

// GetLow returns the value of the field Low.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetLow() *fhir.Quantity {
	if orr == nil {
		return nil
	}
	return orr.Low
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetModifierExtension() []*fhir.Extension {
	if orr == nil {
		return nil
	}
	return orr.ModifierExtension
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetText() *fhir.String {
	if orr == nil {
		return nil
	}
	return orr.Text
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (orr *ObservationReferenceRange) GetType() *fhir.CodeableConcept {
	if orr == nil {
		return nil
	}
	return orr.Type
}
