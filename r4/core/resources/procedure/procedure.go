// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package procedure

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// An action that is or was performed on or for a patient. This can be a
// physical intervention like an operation, or less invasive like long term
// services, counseling, or hypnotherapy.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Procedure
//   - Source File: StructureDefinition-Procedure.json
type Procedure struct {

	// Individual who is making the procedure statement.
	Asserter *fhir.Reference `fhirpath:"asserter"`

	// A reference to a resource that contains details of the request for this
	// procedure.
	BasedOn []*fhir.Reference `fhirpath:"basedOn"`

	// Detailed and structured anatomical location information. Multiple locations
	// are allowed - e.g. multiple punch biopsies of a lesion.
	BodySite []*fhir.CodeableConcept `fhirpath:"bodySite"`

	// A code that classifies the procedure for searching, sorting and display
	// purposes (e.g. "Surgical Procedure").
	Category *fhir.CodeableConcept `fhirpath:"category"`

	// The specific procedure that is performed. Use text if the exact nature of
	// the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// Any complications that occurred during the procedure, or in the immediate
	// post-performance period. These are generally tracked separately from the
	// notes, which will typically describe the procedure itself rather than any
	// 'post procedure' issues.
	Complication []*fhir.CodeableConcept `fhirpath:"complication"`

	// Any complications that occurred during the procedure, or in the immediate
	// post-performance period.
	ComplicationDetail []*fhir.Reference `fhirpath:"complicationDetail"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// The Encounter during which this Procedure was created or performed or to
	// which the creation of this record is tightly associated.
	Encounter *fhir.Reference `fhirpath:"encounter"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// A device that is implanted, removed or otherwise manipulated (calibration,
	// battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a
	// focal portion of the Procedure.
	FocalDevice []*ProcedureFocalDevice `fhirpath:"focalDevice"`

	// If the procedure required specific follow up - e.g. removal of sutures. The
	// follow up may be represented as a simple note or could potentially be more
	// complex, in which case the CarePlan resource can be used.
	FollowUp []*fhir.CodeableConcept `fhirpath:"followUp"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Business identifiers assigned to this procedure by the performer or other
	// systems which remain constant as the resource is updated and is propagated
	// from server to server.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// The URL pointing to a FHIR-defined protocol, guideline, order set or other
	// definition that is adhered to in whole or in part by this Procedure.
	InstantiatesCanonical []*fhir.Canonical `fhirpath:"instantiatesCanonical"`

	// The URL pointing to an externally maintained protocol, guideline, order set
	// or other definition that is adhered to in whole or in part by this
	// Procedure.
	InstantiatesURI []*fhir.URI `fhirpath:"instantiatesUri"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The location where the procedure actually happened. E.g. a newborn at home,
	// a tracheostomy at a restaurant.
	Location *fhir.Reference `fhirpath:"location"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Any other notes and comments about the procedure.
	Note []*fhir.Annotation `fhirpath:"note"`

	// The outcome of the procedure - did it resolve the reasons for the procedure
	// being performed?
	Outcome *fhir.CodeableConcept `fhirpath:"outcome"`

	// A larger event of which this particular procedure is a component or step.
	PartOf []*fhir.Reference `fhirpath:"partOf"`

	// Estimated or actual date, date-time, period, or age when the procedure was
	// performed. Allows a period to support complex procedures that span more than
	// one date, and also allows for the length of the procedure to be captured.
	Performed fhir.Element `fhirpath:"performed"`

	// Limited to "real" people rather than equipment.
	Performer []*ProcedurePerformer `fhirpath:"performer"`

	// The coded reason why the procedure was performed. This may be a coded entity
	// of some type, or may simply be present as text.
	ReasonCode []*fhir.CodeableConcept `fhirpath:"reasonCode"`

	// The justification of why the procedure was performed.
	ReasonReference []*fhir.Reference `fhirpath:"reasonReference"`

	// Individual who recorded the record and takes responsibility for its content.
	Recorder *fhir.Reference `fhirpath:"recorder"`

	// This could be a histology result, pathology report, surgical report, etc.
	Report []*fhir.Reference `fhirpath:"report"`

	// A code specifying the state of the procedure. Generally, this will be the
	// in-progress or completed state.
	Status *fhir.Code `fhirpath:"status"`

	// Captures the reason for the current state of the procedure.
	StatusReason *fhir.CodeableConcept `fhirpath:"statusReason"`

	// The person, animal or group on which the procedure was performed.
	Subject *fhir.Reference `fhirpath:"subject"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// Identifies coded items that were used as part of the procedure.
	UsedCode []*fhir.CodeableConcept `fhirpath:"usedCode"`

	// Identifies medications, devices and any other substance used as part of the
	// procedure.
	UsedReference []*fhir.Reference `fhirpath:"usedReference"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetAsserter returns the value of the field Asserter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetAsserter() *fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Asserter
}

// GetBasedOn returns the value of the field BasedOn.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetBasedOn() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.BasedOn
}

// GetBodySite returns the value of the field BodySite.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetBodySite() []*fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.BodySite
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetCategory() *fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.Category
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetCode() *fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.Code
}

// GetComplication returns the value of the field Complication.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetComplication() []*fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.Complication
}

// GetComplicationDetail returns the value of the field ComplicationDetail.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetComplicationDetail() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.ComplicationDetail
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetContained() []fhir.Resource {
	if p == nil {
		return nil
	}
	return p.Contained
}

// GetEncounter returns the value of the field Encounter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetEncounter() *fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Encounter
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetExtension() []*fhir.Extension {
	if p == nil {
		return nil
	}
	return p.Extension
}

// GetFocalDevice returns the value of the field FocalDevice.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetFocalDevice() []*ProcedureFocalDevice {
	if p == nil {
		return nil
	}
	return p.FocalDevice
}

// GetFollowUp returns the value of the field FollowUp.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetFollowUp() []*fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.FollowUp
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetID() string {
	if p == nil {
		return ""
	}
	return p.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetIdentifier() []*fhir.Identifier {
	if p == nil {
		return nil
	}
	return p.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetImplicitRules() *fhir.URI {
	if p == nil {
		return nil
	}
	return p.ImplicitRules
}

// GetInstantiatesCanonical returns the value of the field InstantiatesCanonical.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetInstantiatesCanonical() []*fhir.Canonical {
	if p == nil {
		return nil
	}
	return p.InstantiatesCanonical
}

// GetInstantiatesURI returns the value of the field InstantiatesURI.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetInstantiatesURI() []*fhir.URI {
	if p == nil {
		return nil
	}
	return p.InstantiatesURI
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetLanguage() *fhir.Code {
	if p == nil {
		return nil
	}
	return p.Language
}

// GetLocation returns the value of the field Location.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetLocation() *fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Location
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetMeta() *fhir.Meta {
	if p == nil {
		return nil
	}
	return p.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetModifierExtension() []*fhir.Extension {
	if p == nil {
		return nil
	}
	return p.ModifierExtension
}

// GetNote returns the value of the field Note.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetNote() []*fhir.Annotation {
	if p == nil {
		return nil
	}
	return p.Note
}

// GetOutcome returns the value of the field Outcome.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetOutcome() *fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.Outcome
}

// GetPartOf returns the value of the field PartOf.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetPartOf() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.PartOf
}

// GetPerformed returns the value of the field Performed.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetPerformed() fhir.Element {
	if p == nil {
		return nil
	}
	return p.Performed
}

// GetPerformedDateTime returns the value of the field Performed.
func (p *Procedure) GetPerformedDateTime() *fhir.DateTime {
	if p == nil {
		return nil
	}
	val, ok := p.Performed.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetPerformedPeriod returns the value of the field Performed.
func (p *Procedure) GetPerformedPeriod() *fhir.Period {
	if p == nil {
		return nil
	}
	val, ok := p.Performed.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// GetPerformedString returns the value of the field Performed.
func (p *Procedure) GetPerformedString() *fhir.String {
	if p == nil {
		return nil
	}
	val, ok := p.Performed.(*fhir.String)
	if !ok {
		return nil
	}
	return val
}

// GetPerformedAge returns the value of the field Performed.
func (p *Procedure) GetPerformedAge() *fhir.Age {
	if p == nil {
		return nil
	}
	val, ok := p.Performed.(*fhir.Age)
	if !ok {
		return nil
	}
	return val
}

// GetPerformedRange returns the value of the field Performed.
func (p *Procedure) GetPerformedRange() *fhir.Range {
	if p == nil {
		return nil
	}
	val, ok := p.Performed.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
} // GetPerformer returns the value of the field Performer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetPerformer() []*ProcedurePerformer {
	if p == nil {
		return nil
	}
	return p.Performer
}

// GetReasonCode returns the value of the field ReasonCode.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetReasonCode() []*fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.ReasonCode
}

// GetReasonReference returns the value of the field ReasonReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetReasonReference() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.ReasonReference
}

// GetRecorder returns the value of the field Recorder.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetRecorder() *fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Recorder
}

// GetReport returns the value of the field Report.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetReport() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Report
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetStatus() *fhir.Code {
	if p == nil {
		return nil
	}
	return p.Status
}

// GetStatusReason returns the value of the field StatusReason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetStatusReason() *fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.StatusReason
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetSubject() *fhir.Reference {
	if p == nil {
		return nil
	}
	return p.Subject
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetText() *fhir.Narrative {
	if p == nil {
		return nil
	}
	return p.Text
}

// GetUsedCode returns the value of the field UsedCode.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetUsedCode() []*fhir.CodeableConcept {
	if p == nil {
		return nil
	}
	return p.UsedCode
}

// GetUsedReference returns the value of the field UsedReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (p *Procedure) GetUsedReference() []*fhir.Reference {
	if p == nil {
		return nil
	}
	return p.UsedReference
}

// Manipulated, implanted, or removed device// A device that is implanted, removed or otherwise manipulated (calibration,
// battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a
// focal portion of the Procedure.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Procedure.json
type ProcedureFocalDevice struct {

	// The kind of change that happened to the device during the procedure.
	Action *fhir.CodeableConcept `fhirpath:"action"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The device that was manipulated (changed) during the procedure.
	Manipulated *fhir.Reference `fhirpath:"manipulated"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAction returns the value of the field Action.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pfd *ProcedureFocalDevice) GetAction() *fhir.CodeableConcept {
	if pfd == nil {
		return nil
	}
	return pfd.Action
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pfd *ProcedureFocalDevice) GetExtension() []*fhir.Extension {
	if pfd == nil {
		return nil
	}
	return pfd.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pfd *ProcedureFocalDevice) GetID() string {
	if pfd == nil {
		return ""
	}
	return pfd.ID
}

// GetManipulated returns the value of the field Manipulated.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pfd *ProcedureFocalDevice) GetManipulated() *fhir.Reference {
	if pfd == nil {
		return nil
	}
	return pfd.Manipulated
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pfd *ProcedureFocalDevice) GetModifierExtension() []*fhir.Extension {
	if pfd == nil {
		return nil
	}
	return pfd.ModifierExtension
}

// The people who performed the procedure// Limited to "real" people rather than equipment.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-Procedure.json
type ProcedurePerformer struct {

	// The practitioner who was involved in the procedure.
	Actor *fhir.Reference `fhirpath:"actor"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Distinguishes the type of involvement of the performer in the procedure. For
	// example, surgeon, anaesthetist, endoscopist.
	Function *fhir.CodeableConcept `fhirpath:"function"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The organization the device or practitioner was acting on behalf of.
	OnBehalfOf *fhir.Reference `fhirpath:"onBehalfOf"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetActor returns the value of the field Actor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetActor() *fhir.Reference {
	if pp == nil {
		return nil
	}
	return pp.Actor
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetExtension() []*fhir.Extension {
	if pp == nil {
		return nil
	}
	return pp.Extension
}

// GetFunction returns the value of the field Function.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetFunction() *fhir.CodeableConcept {
	if pp == nil {
		return nil
	}
	return pp.Function
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetID() string {
	if pp == nil {
		return ""
	}
	return pp.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetModifierExtension() []*fhir.Extension {
	if pp == nil {
		return nil
	}
	return pp.ModifierExtension
}

// GetOnBehalfOf returns the value of the field OnBehalfOf.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pp *ProcedurePerformer) GetOnBehalfOf() *fhir.Reference {
	if pp == nil {
		return nil
	}
	return pp.OnBehalfOf
}

func (p *Procedure) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (p *Procedure) UnmarshalJSON(data []byte) error {
	var raw struct {
		Asserter           *fhir.Reference         `json:"asserter"`
		BasedOn            []*fhir.Reference       `json:"basedOn"`
		BodySite           []*fhir.CodeableConcept `json:"bodySite"`
		Category           *fhir.CodeableConcept   `json:"category"`
		Code               *fhir.CodeableConcept   `json:"code"`
		Complication       []*fhir.CodeableConcept `json:"complication"`
		ComplicationDetail []*fhir.Reference       `json:"complicationDetail"`
		Contained          []fhir.Resource         `json:"contained"`
		Encounter          *fhir.Reference         `json:"encounter"`
		Extension          []*fhir.Extension       `json:"extension"`
		FocalDevice        []*ProcedureFocalDevice `json:"focalDevice"`
		FollowUp           []*fhir.CodeableConcept `json:"followUp"`

		ID                    string                  `json:"id"`
		Identifier            []*fhir.Identifier      `json:"identifier"`
		ImplicitRules         *fhir.URI               `json:"implicitRules"`
		InstantiatesCanonical []*fhir.Canonical       `json:"instantiatesCanonical"`
		InstantiatesURI       []*fhir.URI             `json:"instantiatesUri"`
		Language              *fhir.Code              `json:"language"`
		Location              *fhir.Reference         `json:"location"`
		Meta                  *fhir.Meta              `json:"meta"`
		ModifierExtension     []*fhir.Extension       `json:"modifierExtension"`
		Note                  []*fhir.Annotation      `json:"note"`
		Outcome               *fhir.CodeableConcept   `json:"outcome"`
		PartOf                []*fhir.Reference       `json:"partOf"`
		PerformedDateTime     *fhir.DateTime          `json:"performedDateTime"`
		PerformedPeriod       *fhir.Period            `json:"performedPeriod"`
		PerformedString       *fhir.String            `json:"performedString"`
		PerformedAge          *fhir.Age               `json:"performedAge"`
		PerformedRange        *fhir.Range             `json:"performedRange"`
		Performer             []*ProcedurePerformer   `json:"performer"`
		ReasonCode            []*fhir.CodeableConcept `json:"reasonCode"`
		ReasonReference       []*fhir.Reference       `json:"reasonReference"`
		Recorder              *fhir.Reference         `json:"recorder"`
		Report                []*fhir.Reference       `json:"report"`
		Status                *fhir.Code              `json:"status"`
		StatusReason          *fhir.CodeableConcept   `json:"statusReason"`
		Subject               *fhir.Reference         `json:"subject"`
		Text                  *fhir.Narrative         `json:"text"`
		UsedCode              []*fhir.CodeableConcept `json:"usedCode"`
		UsedReference         []*fhir.Reference       `json:"usedReference"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	p.Asserter = raw.Asserter
	p.BasedOn = raw.BasedOn
	p.BodySite = raw.BodySite
	p.Category = raw.Category
	p.Code = raw.Code
	p.Complication = raw.Complication
	p.ComplicationDetail = raw.ComplicationDetail
	p.Contained = raw.Contained
	p.Encounter = raw.Encounter
	p.Extension = raw.Extension
	p.FocalDevice = raw.FocalDevice
	p.FollowUp = raw.FollowUp
	p.ID = raw.ID
	p.Identifier = raw.Identifier
	p.ImplicitRules = raw.ImplicitRules
	p.InstantiatesCanonical = raw.InstantiatesCanonical
	p.InstantiatesURI = raw.InstantiatesURI
	p.Language = raw.Language
	p.Location = raw.Location
	p.Meta = raw.Meta
	p.ModifierExtension = raw.ModifierExtension
	p.Note = raw.Note
	p.Outcome = raw.Outcome
	p.PartOf = raw.PartOf
	p.Performed, err = validate.SelectOneOf[fhir.Element]("Procedure.performed",
		raw.PerformedDateTime,
		raw.PerformedPeriod,
		raw.PerformedString,
		raw.PerformedAge,
		raw.PerformedRange)
	if err != nil {
		return err
	}
	p.Performer = raw.Performer
	p.ReasonCode = raw.ReasonCode
	p.ReasonReference = raw.ReasonReference
	p.Recorder = raw.Recorder
	p.Report = raw.Report
	p.Status = raw.Status
	p.StatusReason = raw.StatusReason
	p.Subject = raw.Subject
	p.Text = raw.Text
	p.UsedCode = raw.UsedCode
	p.UsedReference = raw.UsedReference
	return nil
}

var _ json.Marshaler = (*Procedure)(nil)
var _ json.Unmarshaler = (*Procedure)(nil)

func (pfd *ProcedureFocalDevice) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (pfd *ProcedureFocalDevice) UnmarshalJSON(data []byte) error {
	var raw struct {
		Action    *fhir.CodeableConcept `json:"action"`
		Extension []*fhir.Extension     `json:"extension"`

		ID                string            `json:"id"`
		Manipulated       *fhir.Reference   `json:"manipulated"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	pfd.Action = raw.Action
	pfd.Extension = raw.Extension
	pfd.ID = raw.ID
	pfd.Manipulated = raw.Manipulated
	pfd.ModifierExtension = raw.ModifierExtension
	return nil
}

var _ json.Marshaler = (*ProcedureFocalDevice)(nil)
var _ json.Unmarshaler = (*ProcedureFocalDevice)(nil)

func (pp *ProcedurePerformer) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (pp *ProcedurePerformer) UnmarshalJSON(data []byte) error {
	var raw struct {
		Actor     *fhir.Reference       `json:"actor"`
		Extension []*fhir.Extension     `json:"extension"`
		Function  *fhir.CodeableConcept `json:"function"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		OnBehalfOf        *fhir.Reference   `json:"onBehalfOf"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	pp.Actor = raw.Actor
	pp.Extension = raw.Extension
	pp.Function = raw.Function
	pp.ID = raw.ID
	pp.ModifierExtension = raw.ModifierExtension
	pp.OnBehalfOf = raw.OnBehalfOf
	return nil
}

var _ json.Marshaler = (*ProcedurePerformer)(nil)
var _ json.Unmarshaler = (*ProcedurePerformer)(nil)
