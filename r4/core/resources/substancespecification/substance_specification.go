// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package substancespecification

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// The detailed description of a substance, typically at a level beyond what is
// used for prescribing.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/SubstanceSpecification
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecification struct {

	// Codes associated with the substance.
	Code []*SubstanceSpecificationCode `fhirpath:"code"`

	// Textual comment about this record of a substance.
	Comment *fhir.String `fhirpath:"comment"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// Textual description of the substance.
	Description *fhir.String `fhirpath:"description"`

	// If the substance applies to only human or veterinary use.
	Domain *fhir.CodeableConcept `fhirpath:"domain"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Identifier by which this substance is known.
	Identifier *fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Moiety, for structural modifications.
	Moiety []*SubstanceSpecificationMoiety `fhirpath:"moiety"`

	// Names applicable to this substance.
	Name []*SubstanceSpecificationName `fhirpath:"name"`

	// Data items specific to nucleic acids.
	NucleicAcid *fhir.Reference `fhirpath:"nucleicAcid"`

	// Data items specific to polymers.
	Polymer *fhir.Reference `fhirpath:"polymer"`

	// General specifications for this substance, including how it is related to
	// other substances.
	Property []*SubstanceSpecificationProperty `fhirpath:"property"`

	// Data items specific to proteins.
	Protein *fhir.Reference `fhirpath:"protein"`

	// General information detailing this substance.
	ReferenceInformation *fhir.Reference `fhirpath:"referenceInformation"`

	// A link between this substance and another, with details of the relationship.
	Relationship []*SubstanceSpecificationRelationship `fhirpath:"relationship"`

	// Supporting literature.
	Source []*fhir.Reference `fhirpath:"source"`

	// Material or taxonomic/anatomical source for the substance.
	SourceMaterial *fhir.Reference `fhirpath:"sourceMaterial"`

	// Status of substance within the catalogue e.g. approved.
	Status *fhir.CodeableConcept `fhirpath:"status"`

	// Structural information.
	Structure *SubstanceSpecificationStructure `fhirpath:"structure"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// High level categorization, e.g. polymer or nucleic acid.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetCode() []*SubstanceSpecificationCode {
	if ss == nil {
		return nil
	}
	return ss.Code
}

// GetComment returns the value of the field Comment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetComment() *fhir.String {
	if ss == nil {
		return nil
	}
	return ss.Comment
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetContained() []fhir.Resource {
	if ss == nil {
		return nil
	}
	return ss.Contained
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetDescription() *fhir.String {
	if ss == nil {
		return nil
	}
	return ss.Description
}

// GetDomain returns the value of the field Domain.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetDomain() *fhir.CodeableConcept {
	if ss == nil {
		return nil
	}
	return ss.Domain
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetExtension() []*fhir.Extension {
	if ss == nil {
		return nil
	}
	return ss.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetID() string {
	if ss == nil {
		return ""
	}
	return ss.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetIdentifier() *fhir.Identifier {
	if ss == nil {
		return nil
	}
	return ss.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetImplicitRules() *fhir.URI {
	if ss == nil {
		return nil
	}
	return ss.ImplicitRules
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetLanguage() *fhir.Code {
	if ss == nil {
		return nil
	}
	return ss.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetMeta() *fhir.Meta {
	if ss == nil {
		return nil
	}
	return ss.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetModifierExtension() []*fhir.Extension {
	if ss == nil {
		return nil
	}
	return ss.ModifierExtension
}

// GetMoiety returns the value of the field Moiety.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetMoiety() []*SubstanceSpecificationMoiety {
	if ss == nil {
		return nil
	}
	return ss.Moiety
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetName() []*SubstanceSpecificationName {
	if ss == nil {
		return nil
	}
	return ss.Name
}

// GetNucleicAcid returns the value of the field NucleicAcid.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetNucleicAcid() *fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.NucleicAcid
}

// GetPolymer returns the value of the field Polymer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetPolymer() *fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.Polymer
}

// GetProperty returns the value of the field Property.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetProperty() []*SubstanceSpecificationProperty {
	if ss == nil {
		return nil
	}
	return ss.Property
}

// GetProtein returns the value of the field Protein.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetProtein() *fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.Protein
}

// GetReferenceInformation returns the value of the field ReferenceInformation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetReferenceInformation() *fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.ReferenceInformation
}

// GetRelationship returns the value of the field Relationship.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetRelationship() []*SubstanceSpecificationRelationship {
	if ss == nil {
		return nil
	}
	return ss.Relationship
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetSource() []*fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.Source
}

// GetSourceMaterial returns the value of the field SourceMaterial.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetSourceMaterial() *fhir.Reference {
	if ss == nil {
		return nil
	}
	return ss.SourceMaterial
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetStatus() *fhir.CodeableConcept {
	if ss == nil {
		return nil
	}
	return ss.Status
}

// GetStructure returns the value of the field Structure.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetStructure() *SubstanceSpecificationStructure {
	if ss == nil {
		return nil
	}
	return ss.Structure
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetText() *fhir.Narrative {
	if ss == nil {
		return nil
	}
	return ss.Text
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ss *SubstanceSpecification) GetType() *fhir.CodeableConcept {
	if ss == nil {
		return nil
	}
	return ss.Type
}

// Codes associated with the substance// Codes associated with the substance.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationCode struct {

	// The specific code.
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// Any comment can be provided in this field, if necessary.
	Comment *fhir.String `fhirpath:"comment"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Supporting literature.
	Source []*fhir.Reference `fhirpath:"source"`

	// Status of the code assignment.
	Status *fhir.CodeableConcept `fhirpath:"status"`

	// The date at which the code status is changed as part of the terminology
	// maintenance.
	StatusDate *fhir.DateTime `fhirpath:"statusDate"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetCode() *fhir.CodeableConcept {
	if ssc == nil {
		return nil
	}
	return ssc.Code
}

// GetComment returns the value of the field Comment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetComment() *fhir.String {
	if ssc == nil {
		return nil
	}
	return ssc.Comment
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetExtension() []*fhir.Extension {
	if ssc == nil {
		return nil
	}
	return ssc.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetID() string {
	if ssc == nil {
		return ""
	}
	return ssc.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetModifierExtension() []*fhir.Extension {
	if ssc == nil {
		return nil
	}
	return ssc.ModifierExtension
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetSource() []*fhir.Reference {
	if ssc == nil {
		return nil
	}
	return ssc.Source
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetStatus() *fhir.CodeableConcept {
	if ssc == nil {
		return nil
	}
	return ssc.Status
}

// GetStatusDate returns the value of the field StatusDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssc *SubstanceSpecificationCode) GetStatusDate() *fhir.DateTime {
	if ssc == nil {
		return nil
	}
	return ssc.StatusDate
}

// Moiety, for structural modifications// Moiety, for structural modifications.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationMoiety struct {

	// Quantitative value for this moiety.
	Amount fhir.Element `fhirpath:"amount"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Identifier by which this moiety substance is known.
	Identifier *fhir.Identifier `fhirpath:"identifier"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Molecular formula.
	MolecularFormula *fhir.String `fhirpath:"molecularFormula"`

	// Textual name for this moiety substance.
	Name *fhir.String `fhirpath:"name"`

	// Optical activity type.
	OpticalActivity *fhir.CodeableConcept `fhirpath:"opticalActivity"`

	// Role that the moiety is playing.
	Role *fhir.CodeableConcept `fhirpath:"role"`

	// Stereochemistry type.
	Stereochemistry *fhir.CodeableConcept `fhirpath:"stereochemistry"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAmount returns the value of the field Amount.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetAmount() fhir.Element {
	if ssm == nil {
		return nil
	}
	return ssm.Amount
}

// GetAmountQuantity returns the value of the field Amount.
func (ssm *SubstanceSpecificationMoiety) GetAmountQuantity() *fhir.Quantity {
	if ssm == nil {
		return nil
	}
	val, ok := ssm.Amount.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetAmountString returns the value of the field Amount.
func (ssm *SubstanceSpecificationMoiety) GetAmountString() *fhir.String {
	if ssm == nil {
		return nil
	}
	val, ok := ssm.Amount.(*fhir.String)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetExtension() []*fhir.Extension {
	if ssm == nil {
		return nil
	}
	return ssm.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetID() string {
	if ssm == nil {
		return ""
	}
	return ssm.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetIdentifier() *fhir.Identifier {
	if ssm == nil {
		return nil
	}
	return ssm.Identifier
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetModifierExtension() []*fhir.Extension {
	if ssm == nil {
		return nil
	}
	return ssm.ModifierExtension
}

// GetMolecularFormula returns the value of the field MolecularFormula.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetMolecularFormula() *fhir.String {
	if ssm == nil {
		return nil
	}
	return ssm.MolecularFormula
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetName() *fhir.String {
	if ssm == nil {
		return nil
	}
	return ssm.Name
}

// GetOpticalActivity returns the value of the field OpticalActivity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetOpticalActivity() *fhir.CodeableConcept {
	if ssm == nil {
		return nil
	}
	return ssm.OpticalActivity
}

// GetRole returns the value of the field Role.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetRole() *fhir.CodeableConcept {
	if ssm == nil {
		return nil
	}
	return ssm.Role
}

// GetStereochemistry returns the value of the field Stereochemistry.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssm *SubstanceSpecificationMoiety) GetStereochemistry() *fhir.CodeableConcept {
	if ssm == nil {
		return nil
	}
	return ssm.Stereochemistry
}

// Names applicable to this substance// Names applicable to this substance.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationName struct {

	// The use context of this name for example if there is a different name a drug
	// active ingredient as opposed to a food colour additive.
	Domain []*fhir.CodeableConcept `fhirpath:"domain"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The jurisdiction where this name applies.
	Jurisdiction []*fhir.CodeableConcept `fhirpath:"jurisdiction"`

	// Language of the name.
	Language []*fhir.CodeableConcept `fhirpath:"language"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The actual name.
	Name *fhir.String `fhirpath:"name"`

	// Details of the official nature of this name.
	Official []*SubstanceSpecificationNameOfficial `fhirpath:"official"`

	// If this is the preferred name for this substance.
	Preferred *fhir.Boolean `fhirpath:"preferred"`

	// Supporting literature.
	Source []*fhir.Reference `fhirpath:"source"`

	// The status of the name.
	Status *fhir.CodeableConcept `fhirpath:"status"`

	// Name type.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetDomain returns the value of the field Domain.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetDomain() []*fhir.CodeableConcept {
	if ssn == nil {
		return nil
	}
	return ssn.Domain
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetExtension() []*fhir.Extension {
	if ssn == nil {
		return nil
	}
	return ssn.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetID() string {
	if ssn == nil {
		return ""
	}
	return ssn.ID
}

// GetJurisdiction returns the value of the field Jurisdiction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetJurisdiction() []*fhir.CodeableConcept {
	if ssn == nil {
		return nil
	}
	return ssn.Jurisdiction
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetLanguage() []*fhir.CodeableConcept {
	if ssn == nil {
		return nil
	}
	return ssn.Language
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetModifierExtension() []*fhir.Extension {
	if ssn == nil {
		return nil
	}
	return ssn.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetName() *fhir.String {
	if ssn == nil {
		return nil
	}
	return ssn.Name
}

// GetOfficial returns the value of the field Official.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetOfficial() []*SubstanceSpecificationNameOfficial {
	if ssn == nil {
		return nil
	}
	return ssn.Official
}

// GetPreferred returns the value of the field Preferred.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetPreferred() *fhir.Boolean {
	if ssn == nil {
		return nil
	}
	return ssn.Preferred
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetSource() []*fhir.Reference {
	if ssn == nil {
		return nil
	}
	return ssn.Source
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetStatus() *fhir.CodeableConcept {
	if ssn == nil {
		return nil
	}
	return ssn.Status
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssn *SubstanceSpecificationName) GetType() *fhir.CodeableConcept {
	if ssn == nil {
		return nil
	}
	return ssn.Type
}

// Details of the official nature of this name// Details of the official nature of this name.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationNameOfficial struct {

	// Which authority uses this official name.
	Authority *fhir.CodeableConcept `fhirpath:"authority"`

	// Date of official name change.
	Date *fhir.DateTime `fhirpath:"date"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The status of the official name.
	Status *fhir.CodeableConcept `fhirpath:"status"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAuthority returns the value of the field Authority.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetAuthority() *fhir.CodeableConcept {
	if ssno == nil {
		return nil
	}
	return ssno.Authority
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetDate() *fhir.DateTime {
	if ssno == nil {
		return nil
	}
	return ssno.Date
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetExtension() []*fhir.Extension {
	if ssno == nil {
		return nil
	}
	return ssno.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetID() string {
	if ssno == nil {
		return ""
	}
	return ssno.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetModifierExtension() []*fhir.Extension {
	if ssno == nil {
		return nil
	}
	return ssno.ModifierExtension
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssno *SubstanceSpecificationNameOfficial) GetStatus() *fhir.CodeableConcept {
	if ssno == nil {
		return nil
	}
	return ssno.Status
}

// General specifications for this substance, including how it is related to
// other substances// General specifications for this substance, including how it is related to
// other substances.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationProperty struct {

	// Quantitative value for this property.
	Amount fhir.Element `fhirpath:"amount"`

	// A category for this property, e.g. Physical, Chemical, Enzymatic.
	Category *fhir.CodeableConcept `fhirpath:"category"`

	// Property type e.g. viscosity, pH, isoelectric point.
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// A substance upon which a defining property depends (e.g. for solubility: in
	// water, in alcohol).
	DefiningSubstance fhir.Element `fhirpath:"definingSubstance"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Parameters that were used in the measurement of a property (e.g. for
	// viscosity: measured at 20C with a pH of 7.1).
	Parameters *fhir.String `fhirpath:"parameters"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAmount returns the value of the field Amount.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetAmount() fhir.Element {
	if ssp == nil {
		return nil
	}
	return ssp.Amount
}

// GetAmountQuantity returns the value of the field Amount.
func (ssp *SubstanceSpecificationProperty) GetAmountQuantity() *fhir.Quantity {
	if ssp == nil {
		return nil
	}
	val, ok := ssp.Amount.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetAmountString returns the value of the field Amount.
func (ssp *SubstanceSpecificationProperty) GetAmountString() *fhir.String {
	if ssp == nil {
		return nil
	}
	val, ok := ssp.Amount.(*fhir.String)
	if !ok {
		return nil
	}
	return val
} // GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetCategory() *fhir.CodeableConcept {
	if ssp == nil {
		return nil
	}
	return ssp.Category
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetCode() *fhir.CodeableConcept {
	if ssp == nil {
		return nil
	}
	return ssp.Code
}

// GetDefiningSubstance returns the value of the field DefiningSubstance.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetDefiningSubstance() fhir.Element {
	if ssp == nil {
		return nil
	}
	return ssp.DefiningSubstance
}

// GetDefiningSubstanceReference returns the value of the field DefiningSubstance.
func (ssp *SubstanceSpecificationProperty) GetDefiningSubstanceReference() *fhir.Reference {
	if ssp == nil {
		return nil
	}
	val, ok := ssp.DefiningSubstance.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
}

// GetDefiningSubstanceCodeableConcept returns the value of the field DefiningSubstance.
func (ssp *SubstanceSpecificationProperty) GetDefiningSubstanceCodeableConcept() *fhir.CodeableConcept {
	if ssp == nil {
		return nil
	}
	val, ok := ssp.DefiningSubstance.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetExtension() []*fhir.Extension {
	if ssp == nil {
		return nil
	}
	return ssp.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetID() string {
	if ssp == nil {
		return ""
	}
	return ssp.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetModifierExtension() []*fhir.Extension {
	if ssp == nil {
		return nil
	}
	return ssp.ModifierExtension
}

// GetParameters returns the value of the field Parameters.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssp *SubstanceSpecificationProperty) GetParameters() *fhir.String {
	if ssp == nil {
		return nil
	}
	return ssp.Parameters
}

// A link between this substance and another, with details of the relationship// A link between this substance and another, with details of the relationship.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationRelationship struct {

	// For use when the numeric.
	AmountRatioLowLimit *fhir.Ratio `fhirpath:"amountRatioLowLimit"`

	// An operator for the amount, for example "average", "approximately", "less
	// than".
	AmountType *fhir.CodeableConcept `fhirpath:"amountType"`

	// A numeric factor for the relationship, for instance to express that the salt
	// of a substance has some percentage of the active substance in relation to
	// some other.
	Amount fhir.Element `fhirpath:"amount"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// For example where an enzyme strongly bonds with a particular substance, this
	// is a defining relationship for that enzyme, out of several possible
	// substance relationships.
	IsDefining *fhir.Boolean `fhirpath:"isDefining"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// For example "salt to parent", "active moiety", "starting material".
	Relationship *fhir.CodeableConcept `fhirpath:"relationship"`

	// Supporting literature.
	Source []*fhir.Reference `fhirpath:"source"`

	// A pointer to another substance, as a resource or just a representational
	// code.
	Substance fhir.Element `fhirpath:"substance"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAmountRatioLowLimit returns the value of the field AmountRatioLowLimit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetAmountRatioLowLimit() *fhir.Ratio {
	if ssr == nil {
		return nil
	}
	return ssr.AmountRatioLowLimit
}

// GetAmountType returns the value of the field AmountType.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetAmountType() *fhir.CodeableConcept {
	if ssr == nil {
		return nil
	}
	return ssr.AmountType
}

// GetAmount returns the value of the field Amount.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetAmount() fhir.Element {
	if ssr == nil {
		return nil
	}
	return ssr.Amount
}

// GetAmountQuantity returns the value of the field Amount.
func (ssr *SubstanceSpecificationRelationship) GetAmountQuantity() *fhir.Quantity {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Amount.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetAmountRange returns the value of the field Amount.
func (ssr *SubstanceSpecificationRelationship) GetAmountRange() *fhir.Range {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Amount.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetAmountRatio returns the value of the field Amount.
func (ssr *SubstanceSpecificationRelationship) GetAmountRatio() *fhir.Ratio {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Amount.(*fhir.Ratio)
	if !ok {
		return nil
	}
	return val
}

// GetAmountString returns the value of the field Amount.
func (ssr *SubstanceSpecificationRelationship) GetAmountString() *fhir.String {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Amount.(*fhir.String)
	if !ok {
		return nil
	}
	return val
} // GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetExtension() []*fhir.Extension {
	if ssr == nil {
		return nil
	}
	return ssr.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetID() string {
	if ssr == nil {
		return ""
	}
	return ssr.ID
}

// GetIsDefining returns the value of the field IsDefining.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetIsDefining() *fhir.Boolean {
	if ssr == nil {
		return nil
	}
	return ssr.IsDefining
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetModifierExtension() []*fhir.Extension {
	if ssr == nil {
		return nil
	}
	return ssr.ModifierExtension
}

// GetRelationship returns the value of the field Relationship.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetRelationship() *fhir.CodeableConcept {
	if ssr == nil {
		return nil
	}
	return ssr.Relationship
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetSource() []*fhir.Reference {
	if ssr == nil {
		return nil
	}
	return ssr.Source
}

// GetSubstance returns the value of the field Substance.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ssr *SubstanceSpecificationRelationship) GetSubstance() fhir.Element {
	if ssr == nil {
		return nil
	}
	return ssr.Substance
}

// GetSubstanceReference returns the value of the field Substance.
func (ssr *SubstanceSpecificationRelationship) GetSubstanceReference() *fhir.Reference {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Substance.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
}

// GetSubstanceCodeableConcept returns the value of the field Substance.
func (ssr *SubstanceSpecificationRelationship) GetSubstanceCodeableConcept() *fhir.CodeableConcept {
	if ssr == nil {
		return nil
	}
	val, ok := ssr.Substance.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// Structural information// Structural information.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationStructure struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Applicable for single substances that contain a radionuclide or a
	// non-natural isotopic ratio.
	Isotope []*SubstanceSpecificationStructureIsotope `fhirpath:"isotope"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Molecular formula.
	MolecularFormula *fhir.String `fhirpath:"molecularFormula"`

	// Specified per moiety according to the Hill system, i.e. first C, then H,
	// then alphabetical, each moiety separated by a dot.
	MolecularFormulaByMoiety *fhir.String `fhirpath:"molecularFormulaByMoiety"`

	// Optical activity type.
	OpticalActivity *fhir.CodeableConcept `fhirpath:"opticalActivity"`

	// Molecular structural representation.
	Representation []*SubstanceSpecificationStructureRepresentation `fhirpath:"representation"`

	// Supporting literature.
	Source []*fhir.Reference `fhirpath:"source"`

	// Stereochemistry type.
	Stereochemistry *fhir.CodeableConcept `fhirpath:"stereochemistry"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetExtension() []*fhir.Extension {
	if sss == nil {
		return nil
	}
	return sss.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetID() string {
	if sss == nil {
		return ""
	}
	return sss.ID
}

// GetIsotope returns the value of the field Isotope.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetIsotope() []*SubstanceSpecificationStructureIsotope {
	if sss == nil {
		return nil
	}
	return sss.Isotope
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetModifierExtension() []*fhir.Extension {
	if sss == nil {
		return nil
	}
	return sss.ModifierExtension
}

// GetMolecularFormula returns the value of the field MolecularFormula.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetMolecularFormula() *fhir.String {
	if sss == nil {
		return nil
	}
	return sss.MolecularFormula
}

// GetMolecularFormulaByMoiety returns the value of the field MolecularFormulaByMoiety.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetMolecularFormulaByMoiety() *fhir.String {
	if sss == nil {
		return nil
	}
	return sss.MolecularFormulaByMoiety
}

// GetOpticalActivity returns the value of the field OpticalActivity.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetOpticalActivity() *fhir.CodeableConcept {
	if sss == nil {
		return nil
	}
	return sss.OpticalActivity
}

// GetRepresentation returns the value of the field Representation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetRepresentation() []*SubstanceSpecificationStructureRepresentation {
	if sss == nil {
		return nil
	}
	return sss.Representation
}

// GetSource returns the value of the field Source.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetSource() []*fhir.Reference {
	if sss == nil {
		return nil
	}
	return sss.Source
}

// GetStereochemistry returns the value of the field Stereochemistry.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sss *SubstanceSpecificationStructure) GetStereochemistry() *fhir.CodeableConcept {
	if sss == nil {
		return nil
	}
	return sss.Stereochemistry
}

// Applicable for single substances that contain a radionuclide or a
// non-natural isotopic ratio// Applicable for single substances that contain a radionuclide or a
// non-natural isotopic ratio.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationStructureIsotope struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Half life - for a non-natural nuclide.
	HalfLife *fhir.Quantity `fhirpath:"halfLife"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Substance identifier for each non-natural or radioisotope.
	Identifier *fhir.Identifier `fhirpath:"identifier"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The molecular weight or weight range (for proteins, polymers or nucleic
	// acids).
	MolecularWeight *SubstanceSpecificationStructureIsotopeMolecularWeight `fhirpath:"molecularWeight"`

	// Substance name for each non-natural or radioisotope.
	Name *fhir.CodeableConcept `fhirpath:"name"`

	// The type of isotopic substitution present in a single substance.
	Substitution *fhir.CodeableConcept `fhirpath:"substitution"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetExtension() []*fhir.Extension {
	if sssi == nil {
		return nil
	}
	return sssi.Extension
}

// GetHalfLife returns the value of the field HalfLife.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetHalfLife() *fhir.Quantity {
	if sssi == nil {
		return nil
	}
	return sssi.HalfLife
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetID() string {
	if sssi == nil {
		return ""
	}
	return sssi.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetIdentifier() *fhir.Identifier {
	if sssi == nil {
		return nil
	}
	return sssi.Identifier
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetModifierExtension() []*fhir.Extension {
	if sssi == nil {
		return nil
	}
	return sssi.ModifierExtension
}

// GetMolecularWeight returns the value of the field MolecularWeight.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetMolecularWeight() *SubstanceSpecificationStructureIsotopeMolecularWeight {
	if sssi == nil {
		return nil
	}
	return sssi.MolecularWeight
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetName() *fhir.CodeableConcept {
	if sssi == nil {
		return nil
	}
	return sssi.Name
}

// GetSubstitution returns the value of the field Substitution.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssi *SubstanceSpecificationStructureIsotope) GetSubstitution() *fhir.CodeableConcept {
	if sssi == nil {
		return nil
	}
	return sssi.Substitution
}

// The molecular weight or weight range (for proteins, polymers or nucleic
// acids)// The molecular weight or weight range (for proteins, polymers or nucleic
// acids).
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationStructureIsotopeMolecularWeight struct {

	// Used to capture quantitative values for a variety of elements. If only
	// limits are given, the arithmetic mean would be the average. If only a single
	// definite value for a given element is given, it would be captured in this
	// field.
	Amount *fhir.Quantity `fhirpath:"amount"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The method by which the molecular weight was determined.
	Method *fhir.CodeableConcept `fhirpath:"method"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Type of molecular weight such as exact, average (also known as. number
	// average), weight average.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAmount returns the value of the field Amount.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetAmount() *fhir.Quantity {
	if sssimw == nil {
		return nil
	}
	return sssimw.Amount
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetExtension() []*fhir.Extension {
	if sssimw == nil {
		return nil
	}
	return sssimw.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetID() string {
	if sssimw == nil {
		return ""
	}
	return sssimw.ID
}

// GetMethod returns the value of the field Method.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetMethod() *fhir.CodeableConcept {
	if sssimw == nil {
		return nil
	}
	return sssimw.Method
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetModifierExtension() []*fhir.Extension {
	if sssimw == nil {
		return nil
	}
	return sssimw.ModifierExtension
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) GetType() *fhir.CodeableConcept {
	if sssimw == nil {
		return nil
	}
	return sssimw.Type
}

// Molecular structural representation// Molecular structural representation.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-SubstanceSpecification.json
type SubstanceSpecificationStructureRepresentation struct {

	// An attached file with the structural representation.
	Attachment *fhir.Attachment `fhirpath:"attachment"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The structural representation as text string in a format e.g. InChI, SMILES,
	// MOLFILE, CDX.
	Representation *fhir.String `fhirpath:"representation"`

	// The type of structure (e.g. Full, Partial, Representative).
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAttachment returns the value of the field Attachment.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetAttachment() *fhir.Attachment {
	if sssr == nil {
		return nil
	}
	return sssr.Attachment
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetExtension() []*fhir.Extension {
	if sssr == nil {
		return nil
	}
	return sssr.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetID() string {
	if sssr == nil {
		return ""
	}
	return sssr.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetModifierExtension() []*fhir.Extension {
	if sssr == nil {
		return nil
	}
	return sssr.ModifierExtension
}

// GetRepresentation returns the value of the field Representation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetRepresentation() *fhir.String {
	if sssr == nil {
		return nil
	}
	return sssr.Representation
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sssr *SubstanceSpecificationStructureRepresentation) GetType() *fhir.CodeableConcept {
	if sssr == nil {
		return nil
	}
	return sssr.Type
}

func (ss *SubstanceSpecification) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ss *SubstanceSpecification) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code        []*SubstanceSpecificationCode `json:"code"`
		Comment     *fhir.String                  `json:"comment"`
		Contained   []fhir.Resource               `json:"contained"`
		Description *fhir.String                  `json:"description"`
		Domain      *fhir.CodeableConcept         `json:"domain"`
		Extension   []*fhir.Extension             `json:"extension"`

		ID                   string                                `json:"id"`
		Identifier           *fhir.Identifier                      `json:"identifier"`
		ImplicitRules        *fhir.URI                             `json:"implicitRules"`
		Language             *fhir.Code                            `json:"language"`
		Meta                 *fhir.Meta                            `json:"meta"`
		ModifierExtension    []*fhir.Extension                     `json:"modifierExtension"`
		Moiety               []*SubstanceSpecificationMoiety       `json:"moiety"`
		Name                 []*SubstanceSpecificationName         `json:"name"`
		NucleicAcid          *fhir.Reference                       `json:"nucleicAcid"`
		Polymer              *fhir.Reference                       `json:"polymer"`
		Property             []*SubstanceSpecificationProperty     `json:"property"`
		Protein              *fhir.Reference                       `json:"protein"`
		ReferenceInformation *fhir.Reference                       `json:"referenceInformation"`
		Relationship         []*SubstanceSpecificationRelationship `json:"relationship"`
		Source               []*fhir.Reference                     `json:"source"`
		SourceMaterial       *fhir.Reference                       `json:"sourceMaterial"`
		Status               *fhir.CodeableConcept                 `json:"status"`
		Structure            *SubstanceSpecificationStructure      `json:"structure"`
		Text                 *fhir.Narrative                       `json:"text"`
		Type                 *fhir.CodeableConcept                 `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ss.Code = raw.Code
	ss.Comment = raw.Comment
	ss.Contained = raw.Contained
	ss.Description = raw.Description
	ss.Domain = raw.Domain
	ss.Extension = raw.Extension
	ss.ID = raw.ID
	ss.Identifier = raw.Identifier
	ss.ImplicitRules = raw.ImplicitRules
	ss.Language = raw.Language
	ss.Meta = raw.Meta
	ss.ModifierExtension = raw.ModifierExtension
	ss.Moiety = raw.Moiety
	ss.Name = raw.Name
	ss.NucleicAcid = raw.NucleicAcid
	ss.Polymer = raw.Polymer
	ss.Property = raw.Property
	ss.Protein = raw.Protein
	ss.ReferenceInformation = raw.ReferenceInformation
	ss.Relationship = raw.Relationship
	ss.Source = raw.Source
	ss.SourceMaterial = raw.SourceMaterial
	ss.Status = raw.Status
	ss.Structure = raw.Structure
	ss.Text = raw.Text
	ss.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceSpecification)(nil)
var _ json.Unmarshaler = (*SubstanceSpecification)(nil)

func (ssc *SubstanceSpecificationCode) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssc *SubstanceSpecificationCode) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code      *fhir.CodeableConcept `json:"code"`
		Comment   *fhir.String          `json:"comment"`
		Extension []*fhir.Extension     `json:"extension"`

		ID                string                `json:"id"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Source            []*fhir.Reference     `json:"source"`
		Status            *fhir.CodeableConcept `json:"status"`
		StatusDate        *fhir.DateTime        `json:"statusDate"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssc.Code = raw.Code
	ssc.Comment = raw.Comment
	ssc.Extension = raw.Extension
	ssc.ID = raw.ID
	ssc.ModifierExtension = raw.ModifierExtension
	ssc.Source = raw.Source
	ssc.Status = raw.Status
	ssc.StatusDate = raw.StatusDate
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationCode)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationCode)(nil)

func (ssm *SubstanceSpecificationMoiety) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssm *SubstanceSpecificationMoiety) UnmarshalJSON(data []byte) error {
	var raw struct {
		AmountQuantity *fhir.Quantity    `json:"amountQuantity"`
		AmountString   *fhir.String      `json:"amountString"`
		Extension      []*fhir.Extension `json:"extension"`

		ID                string                `json:"id"`
		Identifier        *fhir.Identifier      `json:"identifier"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		MolecularFormula  *fhir.String          `json:"molecularFormula"`
		Name              *fhir.String          `json:"name"`
		OpticalActivity   *fhir.CodeableConcept `json:"opticalActivity"`
		Role              *fhir.CodeableConcept `json:"role"`
		Stereochemistry   *fhir.CodeableConcept `json:"stereochemistry"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssm.Amount, err = validate.SelectOneOf[fhir.Element]("SubstanceSpecification.moiety.amount",
		raw.AmountQuantity,
		raw.AmountString)
	if err != nil {
		return err
	}
	ssm.Extension = raw.Extension
	ssm.ID = raw.ID
	ssm.Identifier = raw.Identifier
	ssm.ModifierExtension = raw.ModifierExtension
	ssm.MolecularFormula = raw.MolecularFormula
	ssm.Name = raw.Name
	ssm.OpticalActivity = raw.OpticalActivity
	ssm.Role = raw.Role
	ssm.Stereochemistry = raw.Stereochemistry
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationMoiety)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationMoiety)(nil)

func (ssn *SubstanceSpecificationName) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssn *SubstanceSpecificationName) UnmarshalJSON(data []byte) error {
	var raw struct {
		Domain    []*fhir.CodeableConcept `json:"domain"`
		Extension []*fhir.Extension       `json:"extension"`

		ID                string                                `json:"id"`
		Jurisdiction      []*fhir.CodeableConcept               `json:"jurisdiction"`
		Language          []*fhir.CodeableConcept               `json:"language"`
		ModifierExtension []*fhir.Extension                     `json:"modifierExtension"`
		Name              *fhir.String                          `json:"name"`
		Official          []*SubstanceSpecificationNameOfficial `json:"official"`
		Preferred         *fhir.Boolean                         `json:"preferred"`
		Source            []*fhir.Reference                     `json:"source"`
		Status            *fhir.CodeableConcept                 `json:"status"`
		Type              *fhir.CodeableConcept                 `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssn.Domain = raw.Domain
	ssn.Extension = raw.Extension
	ssn.ID = raw.ID
	ssn.Jurisdiction = raw.Jurisdiction
	ssn.Language = raw.Language
	ssn.ModifierExtension = raw.ModifierExtension
	ssn.Name = raw.Name
	ssn.Official = raw.Official
	ssn.Preferred = raw.Preferred
	ssn.Source = raw.Source
	ssn.Status = raw.Status
	ssn.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationName)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationName)(nil)

func (ssno *SubstanceSpecificationNameOfficial) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssno *SubstanceSpecificationNameOfficial) UnmarshalJSON(data []byte) error {
	var raw struct {
		Authority *fhir.CodeableConcept `json:"authority"`
		Date      *fhir.DateTime        `json:"date"`
		Extension []*fhir.Extension     `json:"extension"`

		ID                string                `json:"id"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Status            *fhir.CodeableConcept `json:"status"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssno.Authority = raw.Authority
	ssno.Date = raw.Date
	ssno.Extension = raw.Extension
	ssno.ID = raw.ID
	ssno.ModifierExtension = raw.ModifierExtension
	ssno.Status = raw.Status
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationNameOfficial)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationNameOfficial)(nil)

func (ssp *SubstanceSpecificationProperty) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssp *SubstanceSpecificationProperty) UnmarshalJSON(data []byte) error {
	var raw struct {
		AmountQuantity                   *fhir.Quantity        `json:"amountQuantity"`
		AmountString                     *fhir.String          `json:"amountString"`
		Category                         *fhir.CodeableConcept `json:"category"`
		Code                             *fhir.CodeableConcept `json:"code"`
		DefiningSubstanceReference       *fhir.Reference       `json:"definingSubstanceReference"`
		DefiningSubstanceCodeableConcept *fhir.CodeableConcept `json:"definingSubstanceCodeableConcept"`
		Extension                        []*fhir.Extension     `json:"extension"`

		ID                string            `json:"id"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Parameters        *fhir.String      `json:"parameters"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssp.Amount, err = validate.SelectOneOf[fhir.Element]("SubstanceSpecification.property.amount",
		raw.AmountQuantity,
		raw.AmountString)
	if err != nil {
		return err
	}
	ssp.Category = raw.Category
	ssp.Code = raw.Code
	ssp.DefiningSubstance, err = validate.SelectOneOf[fhir.Element]("SubstanceSpecification.property.definingSubstance",
		raw.DefiningSubstanceReference,
		raw.DefiningSubstanceCodeableConcept)
	if err != nil {
		return err
	}
	ssp.Extension = raw.Extension
	ssp.ID = raw.ID
	ssp.ModifierExtension = raw.ModifierExtension
	ssp.Parameters = raw.Parameters
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationProperty)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationProperty)(nil)

func (ssr *SubstanceSpecificationRelationship) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ssr *SubstanceSpecificationRelationship) UnmarshalJSON(data []byte) error {
	var raw struct {
		AmountRatioLowLimit *fhir.Ratio           `json:"amountRatioLowLimit"`
		AmountType          *fhir.CodeableConcept `json:"amountType"`
		AmountQuantity      *fhir.Quantity        `json:"amountQuantity"`
		AmountRange         *fhir.Range           `json:"amountRange"`
		AmountRatio         *fhir.Ratio           `json:"amountRatio"`
		AmountString        *fhir.String          `json:"amountString"`
		Extension           []*fhir.Extension     `json:"extension"`

		ID                       string                `json:"id"`
		IsDefining               *fhir.Boolean         `json:"isDefining"`
		ModifierExtension        []*fhir.Extension     `json:"modifierExtension"`
		Relationship             *fhir.CodeableConcept `json:"relationship"`
		Source                   []*fhir.Reference     `json:"source"`
		SubstanceReference       *fhir.Reference       `json:"substanceReference"`
		SubstanceCodeableConcept *fhir.CodeableConcept `json:"substanceCodeableConcept"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ssr.AmountRatioLowLimit = raw.AmountRatioLowLimit
	ssr.AmountType = raw.AmountType
	ssr.Amount, err = validate.SelectOneOf[fhir.Element]("SubstanceSpecification.relationship.amount",
		raw.AmountQuantity,
		raw.AmountRange,
		raw.AmountRatio,
		raw.AmountString)
	if err != nil {
		return err
	}
	ssr.Extension = raw.Extension
	ssr.ID = raw.ID
	ssr.IsDefining = raw.IsDefining
	ssr.ModifierExtension = raw.ModifierExtension
	ssr.Relationship = raw.Relationship
	ssr.Source = raw.Source
	ssr.Substance, err = validate.SelectOneOf[fhir.Element]("SubstanceSpecification.relationship.substance",
		raw.SubstanceReference,
		raw.SubstanceCodeableConcept)
	if err != nil {
		return err
	}
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationRelationship)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationRelationship)(nil)

func (sss *SubstanceSpecificationStructure) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sss *SubstanceSpecificationStructure) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                       string                                           `json:"id"`
		Isotope                  []*SubstanceSpecificationStructureIsotope        `json:"isotope"`
		ModifierExtension        []*fhir.Extension                                `json:"modifierExtension"`
		MolecularFormula         *fhir.String                                     `json:"molecularFormula"`
		MolecularFormulaByMoiety *fhir.String                                     `json:"molecularFormulaByMoiety"`
		OpticalActivity          *fhir.CodeableConcept                            `json:"opticalActivity"`
		Representation           []*SubstanceSpecificationStructureRepresentation `json:"representation"`
		Source                   []*fhir.Reference                                `json:"source"`
		Stereochemistry          *fhir.CodeableConcept                            `json:"stereochemistry"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sss.Extension = raw.Extension
	sss.ID = raw.ID
	sss.Isotope = raw.Isotope
	sss.ModifierExtension = raw.ModifierExtension
	sss.MolecularFormula = raw.MolecularFormula
	sss.MolecularFormulaByMoiety = raw.MolecularFormulaByMoiety
	sss.OpticalActivity = raw.OpticalActivity
	sss.Representation = raw.Representation
	sss.Source = raw.Source
	sss.Stereochemistry = raw.Stereochemistry
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationStructure)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationStructure)(nil)

func (sssi *SubstanceSpecificationStructureIsotope) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sssi *SubstanceSpecificationStructureIsotope) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`
		HalfLife  *fhir.Quantity    `json:"halfLife"`

		ID                string                                                 `json:"id"`
		Identifier        *fhir.Identifier                                       `json:"identifier"`
		ModifierExtension []*fhir.Extension                                      `json:"modifierExtension"`
		MolecularWeight   *SubstanceSpecificationStructureIsotopeMolecularWeight `json:"molecularWeight"`
		Name              *fhir.CodeableConcept                                  `json:"name"`
		Substitution      *fhir.CodeableConcept                                  `json:"substitution"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sssi.Extension = raw.Extension
	sssi.HalfLife = raw.HalfLife
	sssi.ID = raw.ID
	sssi.Identifier = raw.Identifier
	sssi.ModifierExtension = raw.ModifierExtension
	sssi.MolecularWeight = raw.MolecularWeight
	sssi.Name = raw.Name
	sssi.Substitution = raw.Substitution
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationStructureIsotope)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationStructureIsotope)(nil)

func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sssimw *SubstanceSpecificationStructureIsotopeMolecularWeight) UnmarshalJSON(data []byte) error {
	var raw struct {
		Amount    *fhir.Quantity    `json:"amount"`
		Extension []*fhir.Extension `json:"extension"`

		ID                string                `json:"id"`
		Method            *fhir.CodeableConcept `json:"method"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Type              *fhir.CodeableConcept `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sssimw.Amount = raw.Amount
	sssimw.Extension = raw.Extension
	sssimw.ID = raw.ID
	sssimw.Method = raw.Method
	sssimw.ModifierExtension = raw.ModifierExtension
	sssimw.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationStructureIsotopeMolecularWeight)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationStructureIsotopeMolecularWeight)(nil)

func (sssr *SubstanceSpecificationStructureRepresentation) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sssr *SubstanceSpecificationStructureRepresentation) UnmarshalJSON(data []byte) error {
	var raw struct {
		Attachment *fhir.Attachment  `json:"attachment"`
		Extension  []*fhir.Extension `json:"extension"`

		ID                string                `json:"id"`
		ModifierExtension []*fhir.Extension     `json:"modifierExtension"`
		Representation    *fhir.String          `json:"representation"`
		Type              *fhir.CodeableConcept `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sssr.Attachment = raw.Attachment
	sssr.Extension = raw.Extension
	sssr.ID = raw.ID
	sssr.ModifierExtension = raw.ModifierExtension
	sssr.Representation = raw.Representation
	sssr.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*SubstanceSpecificationStructureRepresentation)(nil)
var _ json.Unmarshaler = (*SubstanceSpecificationStructureRepresentation)(nil)
