// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package clinicalimpression

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// A record of a clinical assessment performed to determine what problem(s) may
// affect the patient and before planning the treatments or management
// strategies that are best to manage a patient's condition. Assessments are
// often 1:1 with a clinical consultation / encounter, but this varies greatly
// depending on the clinical workflow. This resource is called
// "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion
// with the recording of assessment tools such as Apgar score.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/ClinicalImpression
//   - Source File: StructureDefinition-ClinicalImpression.json
type ClinicalImpression struct {

	// The clinician performing the assessment.
	Assessor *fhir.Reference `fhirpath:"assessor"`

	// Categorizes the type of clinical assessment performed.
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// Indicates when the documentation of the assessment was complete.
	Date *fhir.DateTime `fhirpath:"date"`

	// A summary of the context and/or cause of the assessment - why / where it was
	// performed, and what patient events/status prompted it.
	Description *fhir.String `fhirpath:"description"`

	// The point in time or period over which the subject was assessed.
	Effective fhir.Element `fhirpath:"effective"`

	// The Encounter during which this ClinicalImpression was created or to which
	// the creation of this record is tightly associated.
	Encounter *fhir.Reference `fhirpath:"encounter"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Specific findings or diagnoses that were considered likely or relevant to
	// ongoing treatment.
	Finding []*ClinicalImpressionFinding `fhirpath:"finding"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// Business identifiers assigned to this clinical impression by the performer
	// or other systems which remain constant as the resource is updated and
	// propagates from server to server.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// One or more sets of investigations (signs, symptoms, etc.). The actual
	// grouping of investigations varies greatly depending on the type and context
	// of the assessment. These investigations may include data generated during
	// the assessment process, or data previously generated and recorded that is
	// pertinent to the outcomes.
	Investigation []*ClinicalImpressionInvestigation `fhirpath:"investigation"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Commentary about the impression, typically recorded after the impression
	// itself was made, though supplemental notes by the original author could also
	// appear.
	Note []*fhir.Annotation `fhirpath:"note"`

	// A reference to the last assessment that was conducted on this patient.
	// Assessments are often/usually ongoing in nature; a care provider
	// (practitioner or team) will make new assessments on an ongoing basis as new
	// data arises or the patient's conditions changes.
	Previous *fhir.Reference `fhirpath:"previous"`

	// A list of the relevant problems/conditions for a patient.
	Problem []*fhir.Reference `fhirpath:"problem"`

	// Estimate of likely outcome.
	PrognosisCodeableConcept []*fhir.CodeableConcept `fhirpath:"prognosisCodeableConcept"`

	// RiskAssessment expressing likely outcome.
	PrognosisReference []*fhir.Reference `fhirpath:"prognosisReference"`

	// Reference to a specific published clinical protocol that was followed during
	// this assessment, and/or that provides evidence in support of the diagnosis.
	Protocol []*fhir.URI `fhirpath:"protocol"`

	// Identifies the workflow status of the assessment.
	Status *fhir.Code `fhirpath:"status"`

	// Captures the reason for the current state of the ClinicalImpression.
	StatusReason *fhir.CodeableConcept `fhirpath:"statusReason"`

	// The patient or group of individuals assessed as part of this record.
	Subject *fhir.Reference `fhirpath:"subject"`

	// A text summary of the investigations and the diagnosis.
	Summary *fhir.String `fhirpath:"summary"`

	// Information supporting the clinical impression.
	SupportingInfo []*fhir.Reference `fhirpath:"supportingInfo"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetAssessor returns the value of the field Assessor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetAssessor() *fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.Assessor
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetCode() *fhir.CodeableConcept {
	if ci == nil {
		return nil
	}
	return ci.Code
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetContained() []fhir.Resource {
	if ci == nil {
		return nil
	}
	return ci.Contained
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetDate() *fhir.DateTime {
	if ci == nil {
		return nil
	}
	return ci.Date
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetDescription() *fhir.String {
	if ci == nil {
		return nil
	}
	return ci.Description
}

// GetEffective returns the value of the field Effective.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetEffective() fhir.Element {
	if ci == nil {
		return nil
	}
	return ci.Effective
}

// GetEffectiveDateTime returns the value of the field Effective.
func (ci *ClinicalImpression) GetEffectiveDateTime() *fhir.DateTime {
	if ci == nil {
		return nil
	}
	val, ok := ci.Effective.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetEffectivePeriod returns the value of the field Effective.
func (ci *ClinicalImpression) GetEffectivePeriod() *fhir.Period {
	if ci == nil {
		return nil
	}
	val, ok := ci.Effective.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
} // GetEncounter returns the value of the field Encounter.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetEncounter() *fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.Encounter
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetExtension() []*fhir.Extension {
	if ci == nil {
		return nil
	}
	return ci.Extension
}

// GetFinding returns the value of the field Finding.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetFinding() []*ClinicalImpressionFinding {
	if ci == nil {
		return nil
	}
	return ci.Finding
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetID() string {
	if ci == nil {
		return ""
	}
	return ci.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetIdentifier() []*fhir.Identifier {
	if ci == nil {
		return nil
	}
	return ci.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetImplicitRules() *fhir.URI {
	if ci == nil {
		return nil
	}
	return ci.ImplicitRules
}

// GetInvestigation returns the value of the field Investigation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetInvestigation() []*ClinicalImpressionInvestigation {
	if ci == nil {
		return nil
	}
	return ci.Investigation
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetLanguage() *fhir.Code {
	if ci == nil {
		return nil
	}
	return ci.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetMeta() *fhir.Meta {
	if ci == nil {
		return nil
	}
	return ci.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetModifierExtension() []*fhir.Extension {
	if ci == nil {
		return nil
	}
	return ci.ModifierExtension
}

// GetNote returns the value of the field Note.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetNote() []*fhir.Annotation {
	if ci == nil {
		return nil
	}
	return ci.Note
}

// GetPrevious returns the value of the field Previous.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetPrevious() *fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.Previous
}

// GetProblem returns the value of the field Problem.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetProblem() []*fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.Problem
}

// GetPrognosisCodeableConcept returns the value of the field PrognosisCodeableConcept.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetPrognosisCodeableConcept() []*fhir.CodeableConcept {
	if ci == nil {
		return nil
	}
	return ci.PrognosisCodeableConcept
}

// GetPrognosisReference returns the value of the field PrognosisReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetPrognosisReference() []*fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.PrognosisReference
}

// GetProtocol returns the value of the field Protocol.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetProtocol() []*fhir.URI {
	if ci == nil {
		return nil
	}
	return ci.Protocol
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetStatus() *fhir.Code {
	if ci == nil {
		return nil
	}
	return ci.Status
}

// GetStatusReason returns the value of the field StatusReason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetStatusReason() *fhir.CodeableConcept {
	if ci == nil {
		return nil
	}
	return ci.StatusReason
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetSubject() *fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.Subject
}

// GetSummary returns the value of the field Summary.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetSummary() *fhir.String {
	if ci == nil {
		return nil
	}
	return ci.Summary
}

// GetSupportingInfo returns the value of the field SupportingInfo.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetSupportingInfo() []*fhir.Reference {
	if ci == nil {
		return nil
	}
	return ci.SupportingInfo
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (ci *ClinicalImpression) GetText() *fhir.Narrative {
	if ci == nil {
		return nil
	}
	return ci.Text
}

// Possible or likely findings and diagnoses// Specific findings or diagnoses that were considered likely or relevant to
// ongoing treatment.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ClinicalImpression.json
type ClinicalImpressionFinding struct {

	// Which investigations support finding or diagnosis.
	Basis *fhir.String `fhirpath:"basis"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Specific text or code for finding or diagnosis, which may include ruled-out
	// or resolved conditions.
	ItemCodeableConcept *fhir.CodeableConcept `fhirpath:"itemCodeableConcept"`

	// Specific reference for finding or diagnosis, which may include ruled-out or
	// resolved conditions.
	ItemReference *fhir.Reference `fhirpath:"itemReference"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetBasis returns the value of the field Basis.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetBasis() *fhir.String {
	if cif == nil {
		return nil
	}
	return cif.Basis
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetExtension() []*fhir.Extension {
	if cif == nil {
		return nil
	}
	return cif.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetID() string {
	if cif == nil {
		return ""
	}
	return cif.ID
}

// GetItemCodeableConcept returns the value of the field ItemCodeableConcept.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetItemCodeableConcept() *fhir.CodeableConcept {
	if cif == nil {
		return nil
	}
	return cif.ItemCodeableConcept
}

// GetItemReference returns the value of the field ItemReference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetItemReference() *fhir.Reference {
	if cif == nil {
		return nil
	}
	return cif.ItemReference
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cif *ClinicalImpressionFinding) GetModifierExtension() []*fhir.Extension {
	if cif == nil {
		return nil
	}
	return cif.ModifierExtension
}

// One or more sets of investigations (signs, symptoms, etc.)// One or more sets of investigations (signs, symptoms, etc.). The actual
// grouping of investigations varies greatly depending on the type and context
// of the assessment. These investigations may include data generated during
// the assessment process, or data previously generated and recorded that is
// pertinent to the outcomes.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-ClinicalImpression.json
type ClinicalImpressionInvestigation struct {

	// A name/code for the group ("set") of investigations. Typically, this will be
	// something like "signs", "symptoms", "clinical", "diagnostic", but the list
	// is not constrained, and others such groups such as
	// (exposure|family|travel|nutritional) history may be used.
	Code *fhir.CodeableConcept `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// A record of a specific investigation that was undertaken.
	Item []*fhir.Reference `fhirpath:"item"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cii *ClinicalImpressionInvestigation) GetCode() *fhir.CodeableConcept {
	if cii == nil {
		return nil
	}
	return cii.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cii *ClinicalImpressionInvestigation) GetExtension() []*fhir.Extension {
	if cii == nil {
		return nil
	}
	return cii.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cii *ClinicalImpressionInvestigation) GetID() string {
	if cii == nil {
		return ""
	}
	return cii.ID
}

// GetItem returns the value of the field Item.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cii *ClinicalImpressionInvestigation) GetItem() []*fhir.Reference {
	if cii == nil {
		return nil
	}
	return cii.Item
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (cii *ClinicalImpressionInvestigation) GetModifierExtension() []*fhir.Extension {
	if cii == nil {
		return nil
	}
	return cii.ModifierExtension
}

func (ci *ClinicalImpression) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (ci *ClinicalImpression) UnmarshalJSON(data []byte) error {
	var raw struct {
		Assessor          *fhir.Reference              `json:"assessor"`
		Code              *fhir.CodeableConcept        `json:"code"`
		Contained         []fhir.Resource              `json:"contained"`
		Date              *fhir.DateTime               `json:"date"`
		Description       *fhir.String                 `json:"description"`
		EffectiveDateTime *fhir.DateTime               `json:"effectiveDateTime"`
		EffectivePeriod   *fhir.Period                 `json:"effectivePeriod"`
		Encounter         *fhir.Reference              `json:"encounter"`
		Extension         []*fhir.Extension            `json:"extension"`
		Finding           []*ClinicalImpressionFinding `json:"finding"`

		ID                       string                             `json:"id"`
		Identifier               []*fhir.Identifier                 `json:"identifier"`
		ImplicitRules            *fhir.URI                          `json:"implicitRules"`
		Investigation            []*ClinicalImpressionInvestigation `json:"investigation"`
		Language                 *fhir.Code                         `json:"language"`
		Meta                     *fhir.Meta                         `json:"meta"`
		ModifierExtension        []*fhir.Extension                  `json:"modifierExtension"`
		Note                     []*fhir.Annotation                 `json:"note"`
		Previous                 *fhir.Reference                    `json:"previous"`
		Problem                  []*fhir.Reference                  `json:"problem"`
		PrognosisCodeableConcept []*fhir.CodeableConcept            `json:"prognosisCodeableConcept"`
		PrognosisReference       []*fhir.Reference                  `json:"prognosisReference"`
		Protocol                 []*fhir.URI                        `json:"protocol"`
		Status                   *fhir.Code                         `json:"status"`
		StatusReason             *fhir.CodeableConcept              `json:"statusReason"`
		Subject                  *fhir.Reference                    `json:"subject"`
		Summary                  *fhir.String                       `json:"summary"`
		SupportingInfo           []*fhir.Reference                  `json:"supportingInfo"`
		Text                     *fhir.Narrative                    `json:"text"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	ci.Assessor = raw.Assessor
	ci.Code = raw.Code
	ci.Contained = raw.Contained
	ci.Date = raw.Date
	ci.Description = raw.Description
	ci.Effective, err = validate.SelectOneOf[fhir.Element]("ClinicalImpression.effective",
		raw.EffectiveDateTime,
		raw.EffectivePeriod)
	if err != nil {
		return err
	}
	ci.Encounter = raw.Encounter
	ci.Extension = raw.Extension
	ci.Finding = raw.Finding
	ci.ID = raw.ID
	ci.Identifier = raw.Identifier
	ci.ImplicitRules = raw.ImplicitRules
	ci.Investigation = raw.Investigation
	ci.Language = raw.Language
	ci.Meta = raw.Meta
	ci.ModifierExtension = raw.ModifierExtension
	ci.Note = raw.Note
	ci.Previous = raw.Previous
	ci.Problem = raw.Problem
	ci.PrognosisCodeableConcept = raw.PrognosisCodeableConcept
	ci.PrognosisReference = raw.PrognosisReference
	ci.Protocol = raw.Protocol
	ci.Status = raw.Status
	ci.StatusReason = raw.StatusReason
	ci.Subject = raw.Subject
	ci.Summary = raw.Summary
	ci.SupportingInfo = raw.SupportingInfo
	ci.Text = raw.Text
	return nil
}

var _ json.Marshaler = (*ClinicalImpression)(nil)
var _ json.Unmarshaler = (*ClinicalImpression)(nil)

func (cif *ClinicalImpressionFinding) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cif *ClinicalImpressionFinding) UnmarshalJSON(data []byte) error {
	var raw struct {
		Basis     *fhir.String      `json:"basis"`
		Extension []*fhir.Extension `json:"extension"`

		ID                  string                `json:"id"`
		ItemCodeableConcept *fhir.CodeableConcept `json:"itemCodeableConcept"`
		ItemReference       *fhir.Reference       `json:"itemReference"`
		ModifierExtension   []*fhir.Extension     `json:"modifierExtension"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cif.Basis = raw.Basis
	cif.Extension = raw.Extension
	cif.ID = raw.ID
	cif.ItemCodeableConcept = raw.ItemCodeableConcept
	cif.ItemReference = raw.ItemReference
	cif.ModifierExtension = raw.ModifierExtension
	return nil
}

var _ json.Marshaler = (*ClinicalImpressionFinding)(nil)
var _ json.Unmarshaler = (*ClinicalImpressionFinding)(nil)

func (cii *ClinicalImpressionInvestigation) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (cii *ClinicalImpressionInvestigation) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code      *fhir.CodeableConcept `json:"code"`
		Extension []*fhir.Extension     `json:"extension"`

		ID                string            `json:"id"`
		Item              []*fhir.Reference `json:"item"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	cii.Code = raw.Code
	cii.Extension = raw.Extension
	cii.ID = raw.ID
	cii.Item = raw.Item
	cii.ModifierExtension = raw.ModifierExtension
	return nil
}

var _ json.Marshaler = (*ClinicalImpressionInvestigation)(nil)
var _ json.Unmarshaler = (*ClinicalImpressionInvestigation)(nil)
