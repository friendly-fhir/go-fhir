// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package plandefinition

import (
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"
)

// This resource allows for the definition of various types of plans as a
// sharable, consumable, and executable artifact. The resource is general
// enough to support the description of a broad range of clinical artifacts
// such as clinical decision support rules, order sets and protocols.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/PlanDefinition
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinition struct {

	// An action or group of actions to be taken as part of the plan.
	Action []*PlanDefinitionAction `fhirpath:"action"`

	// The date on which the resource content was approved by the publisher.
	// Approval happens once when the content is officially approved for usage.
	ApprovalDate *fhir.Date `fhirpath:"approvalDate"`

	// An individiual or organization primarily involved in the creation and
	// maintenance of the content.
	Author []*fhir.ContactDetail `fhirpath:"author"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []*fhir.ContactDetail `fhirpath:"contact"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// A copyright statement relating to the plan definition and/or its contents.
	// Copyright statements are generally legal restrictions on the use and
	// publishing of the plan definition.
	Copyright *fhir.Markdown `fhirpath:"copyright"`

	// The date (and optionally time) when the plan definition was published. The
	// date must change when the business version changes and it must change if the
	// status code changes. In addition, it should change when the substantive
	// content of the plan definition changes.
	Date *fhir.DateTime `fhirpath:"date"`

	// A free text natural language description of the plan definition from a
	// consumer's perspective.
	Description *fhir.Markdown `fhirpath:"description"`

	// An individual or organization primarily responsible for internal coherence
	// of the content.
	Editor []*fhir.ContactDetail `fhirpath:"editor"`

	// The period during which the plan definition content was or is planned to be
	// in active use.
	EffectivePeriod *fhir.Period `fhirpath:"effectivePeriod"`

	// An individual or organization responsible for officially endorsing the
	// content for use in some setting.
	Endorser []*fhir.ContactDetail `fhirpath:"endorser"`

	// A Boolean value to indicate that this plan definition is authored for
	// testing purposes (or education/evaluation/marketing) and is not intended to
	// be used for genuine usage.
	Experimental *fhir.Boolean `fhirpath:"experimental"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Goals that describe what the activities within the plan are intended to
	// achieve. For example, weight loss, restoring an activity of daily living,
	// obtaining herd immunity via immunization, meeting a process improvement
	// objective, etc.
	Goal []*PlanDefinitionGoal `fhirpath:"goal"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// A formal identifier that is used to identify this plan definition when it is
	// represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// A legal or geographic region in which the plan definition is intended to be
	// used.
	Jurisdiction []*fhir.CodeableConcept `fhirpath:"jurisdiction"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The date on which the resource content was last reviewed. Review happens
	// periodically after approval but does not change the original approval date.
	LastReviewDate *fhir.Date `fhirpath:"lastReviewDate"`

	// A reference to a Library resource containing any formal logic used by the
	// plan definition.
	Library []*fhir.Canonical `fhirpath:"library"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A natural language name identifying the plan definition. This name should be
	// usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name *fhir.String `fhirpath:"name"`

	// The name of the organization or individual that published the plan
	// definition.
	Publisher *fhir.String `fhirpath:"publisher"`

	// Explanation of why this plan definition is needed and why it has been
	// designed as it has.
	Purpose *fhir.Markdown `fhirpath:"purpose"`

	// Related artifacts such as additional documentation, justification, or
	// bibliographic references.
	RelatedArtifact []*fhir.RelatedArtifact `fhirpath:"relatedArtifact"`

	// An individual or organization primarily responsible for review of some
	// aspect of the content.
	Reviewer []*fhir.ContactDetail `fhirpath:"reviewer"`

	// The status of this plan definition. Enables tracking the life-cycle of the
	// content.
	Status *fhir.Code `fhirpath:"status"`

	// A code or group definition that describes the intended subject of the plan
	// definition.
	Subject fhir.Element `fhirpath:"subject"`

	// An explanatory or alternate title for the plan definition giving additional
	// information about its content.
	Subtitle *fhir.String `fhirpath:"subtitle"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// A short, descriptive, user-friendly title for the plan definition.
	Title *fhir.String `fhirpath:"title"`

	// Descriptive topics related to the content of the plan definition. Topics
	// provide a high-level categorization of the definition that can be useful for
	// filtering and searching.
	Topic []*fhir.CodeableConcept `fhirpath:"topic"`

	// A high-level category for the plan definition that distinguishes the kinds
	// of systems that would be interested in the plan definition.
	Type *fhir.CodeableConcept `fhirpath:"type"`

	// An absolute URI that is used to identify this plan definition when it is
	// referenced in a specification, model, design or an instance; also called its
	// canonical identifier. This SHOULD be globally unique and SHOULD be a literal
	// address at which at which an authoritative instance of this plan definition
	// is (or will be) published. This URL can be the target of a canonical
	// reference. It SHALL remain the same when the plan definition is stored on
	// different servers.
	URL *fhir.URI `fhirpath:"url"`

	// A detailed description of how the plan definition is used from a clinical
	// perspective.
	Usage *fhir.String `fhirpath:"usage"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...)
	// or may be references to specific programs (insurance plans, studies, ...)
	// and may be used to assist with indexing and searching for appropriate plan
	// definition instances.
	UseContext []*fhir.UsageContext `fhirpath:"useContext"`

	// The identifier that is used to identify this version of the plan definition
	// when it is referenced in a specification, model, design or instance. This is
	// an arbitrary value managed by the plan definition author and is not expected
	// to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd)
	// if a managed version is not available. There is also no expectation that
	// versions can be placed in a lexicographical sequence. To provide a version
	// consistent with the Decision Support Service specification, use the format
	// Major.Minor.Revision (e.g. 1.0.0). For more information on versioning
	// knowledge assets, refer to the Decision Support Service specification. Note
	// that a version is required for non-experimental active artifacts.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BasePlanDefinition
	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetAction returns the value of the field Action.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetAction() []*PlanDefinitionAction {
	if pd == nil {
		return nil
	}
	return pd.Action
}

// GetApprovalDate returns the value of the field ApprovalDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetApprovalDate() *fhir.Date {
	if pd == nil {
		return nil
	}
	return pd.ApprovalDate
}

// GetAuthor returns the value of the field Author.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetAuthor() []*fhir.ContactDetail {
	if pd == nil {
		return nil
	}
	return pd.Author
}

// GetContact returns the value of the field Contact.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetContact() []*fhir.ContactDetail {
	if pd == nil {
		return nil
	}
	return pd.Contact
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetContained() []fhir.Resource {
	if pd == nil {
		return nil
	}
	return pd.Contained
}

// GetCopyright returns the value of the field Copyright.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetCopyright() *fhir.Markdown {
	if pd == nil {
		return nil
	}
	return pd.Copyright
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetDate() *fhir.DateTime {
	if pd == nil {
		return nil
	}
	return pd.Date
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetDescription() *fhir.Markdown {
	if pd == nil {
		return nil
	}
	return pd.Description
}

// GetEditor returns the value of the field Editor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetEditor() []*fhir.ContactDetail {
	if pd == nil {
		return nil
	}
	return pd.Editor
}

// GetEffectivePeriod returns the value of the field EffectivePeriod.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetEffectivePeriod() *fhir.Period {
	if pd == nil {
		return nil
	}
	return pd.EffectivePeriod
}

// GetEndorser returns the value of the field Endorser.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetEndorser() []*fhir.ContactDetail {
	if pd == nil {
		return nil
	}
	return pd.Endorser
}

// GetExperimental returns the value of the field Experimental.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetExperimental() *fhir.Boolean {
	if pd == nil {
		return nil
	}
	return pd.Experimental
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetExtension() []*fhir.Extension {
	if pd == nil {
		return nil
	}
	return pd.Extension
}

// GetGoal returns the value of the field Goal.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetGoal() []*PlanDefinitionGoal {
	if pd == nil {
		return nil
	}
	return pd.Goal
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetID() string {
	if pd == nil {
		return ""
	}
	return pd.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetIdentifier() []*fhir.Identifier {
	if pd == nil {
		return nil
	}
	return pd.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetImplicitRules() *fhir.URI {
	if pd == nil {
		return nil
	}
	return pd.ImplicitRules
}

// GetJurisdiction returns the value of the field Jurisdiction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetJurisdiction() []*fhir.CodeableConcept {
	if pd == nil {
		return nil
	}
	return pd.Jurisdiction
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetLanguage() *fhir.Code {
	if pd == nil {
		return nil
	}
	return pd.Language
}

// GetLastReviewDate returns the value of the field LastReviewDate.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetLastReviewDate() *fhir.Date {
	if pd == nil {
		return nil
	}
	return pd.LastReviewDate
}

// GetLibrary returns the value of the field Library.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetLibrary() []*fhir.Canonical {
	if pd == nil {
		return nil
	}
	return pd.Library
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetMeta() *fhir.Meta {
	if pd == nil {
		return nil
	}
	return pd.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetModifierExtension() []*fhir.Extension {
	if pd == nil {
		return nil
	}
	return pd.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetName() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Name
}

// GetPublisher returns the value of the field Publisher.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetPublisher() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Publisher
}

// GetPurpose returns the value of the field Purpose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetPurpose() *fhir.Markdown {
	if pd == nil {
		return nil
	}
	return pd.Purpose
}

// GetRelatedArtifact returns the value of the field RelatedArtifact.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetRelatedArtifact() []*fhir.RelatedArtifact {
	if pd == nil {
		return nil
	}
	return pd.RelatedArtifact
}

// GetReviewer returns the value of the field Reviewer.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetReviewer() []*fhir.ContactDetail {
	if pd == nil {
		return nil
	}
	return pd.Reviewer
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetStatus() *fhir.Code {
	if pd == nil {
		return nil
	}
	return pd.Status
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetSubject() fhir.Element {
	if pd == nil {
		return nil
	}
	return pd.Subject
}

// GetSubjectCodeableConcept returns the value of the field Subject.
func (pd *PlanDefinition) GetSubjectCodeableConcept() *fhir.CodeableConcept {
	if pd == nil {
		return nil
	}
	val, ok := pd.Subject.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetSubjectReference returns the value of the field Subject.
func (pd *PlanDefinition) GetSubjectReference() *fhir.Reference {
	if pd == nil {
		return nil
	}
	val, ok := pd.Subject.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetSubtitle returns the value of the field Subtitle.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetSubtitle() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Subtitle
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetText() *fhir.Narrative {
	if pd == nil {
		return nil
	}
	return pd.Text
}

// GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetTitle() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Title
}

// GetTopic returns the value of the field Topic.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetTopic() []*fhir.CodeableConcept {
	if pd == nil {
		return nil
	}
	return pd.Topic
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetType() *fhir.CodeableConcept {
	if pd == nil {
		return nil
	}
	return pd.Type
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetURL() *fhir.URI {
	if pd == nil {
		return nil
	}
	return pd.URL
}

// GetUsage returns the value of the field Usage.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetUsage() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Usage
}

// GetUseContext returns the value of the field UseContext.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetUseContext() []*fhir.UsageContext {
	if pd == nil {
		return nil
	}
	return pd.UseContext
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pd *PlanDefinition) GetVersion() *fhir.String {
	if pd == nil {
		return nil
	}
	return pd.Version
}

// Action defined by the plan// An action or group of actions to be taken as part of the plan.// Note that there is overlap between many of the elements defined here and the
// ActivityDefinition resource. When an ActivityDefinition is referenced (using
// the definition element), the overlapping elements in the plan override the
// content of the referenced ActivityDefinition unless otherwise documented in
// the specific elements. See the PlanDefinition resource for more detailed
// information.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionAction struct {

	// Defines whether the action can be selected multiple times.
	CardinalityBehavior *fhir.Code `fhirpath:"cardinalityBehavior"`

	// A code that provides meaning for the action or action group. For example, a
	// section may have a LOINC code for the section of a documentation template.
	Code []*fhir.CodeableConcept `fhirpath:"code"`

	// An expression that describes applicability criteria or start/stop conditions
	// for the action.
	Condition []*PlanDefinitionActionCondition `fhirpath:"condition"`

	// A reference to an ActivityDefinition that describes the action to be taken
	// in detail, or a PlanDefinition that describes a series of actions to be
	// taken.
	Definition fhir.Element `fhirpath:"definition"`

	// A brief description of the action used to provide a summary to display to
	// the user.
	Description *fhir.String `fhirpath:"description"`

	// Didactic or other informational resources associated with the action that
	// can be provided to the CDS recipient. Information resources can include
	// inline text commentary and links to web resources.
	Documentation []*fhir.RelatedArtifact `fhirpath:"documentation"`

	// Customizations that should be applied to the statically defined resource.
	// For example, if the dosage of a medication must be computed based on the
	// patient's weight, a customization would be used to specify an expression
	// that calculated the weight, and the path on the resource that would contain
	// the result.
	DynamicValue []*PlanDefinitionActionDynamicValue `fhirpath:"dynamicValue"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Identifies goals that this action supports. The reference must be to a goal
	// element defined within this plan definition.
	GoalID []*fhir.ID `fhirpath:"goalId"`

	// Defines the grouping behavior for the action and its children.
	GroupingBehavior *fhir.Code `fhirpath:"groupingBehavior"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Defines input data requirements for the action.
	Input []*fhir.DataRequirement `fhirpath:"input"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Defines the outputs of the action, if any.
	Output []*fhir.DataRequirement `fhirpath:"output"`

	// Indicates who should participate in performing the action described.
	Participant []*PlanDefinitionActionParticipant `fhirpath:"participant"`

	// Defines whether the action should usually be preselected.
	PrecheckBehavior *fhir.Code `fhirpath:"precheckBehavior"`

	// A user-visible prefix for the action.
	Prefix *fhir.String `fhirpath:"prefix"`

	// Indicates how quickly the action should be addressed with respect to other
	// actions.
	Priority *fhir.Code `fhirpath:"priority"`

	// A description of why this action is necessary or appropriate.
	Reason []*fhir.CodeableConcept `fhirpath:"reason"`

	// A relationship to another action such as "before" or "30-60 minutes after
	// start of".
	RelatedAction []*PlanDefinitionActionRelatedAction `fhirpath:"relatedAction"`

	// Defines the required behavior for the action.
	RequiredBehavior *fhir.Code `fhirpath:"requiredBehavior"`

	// Defines the selection behavior for the action and its children.
	SelectionBehavior *fhir.Code `fhirpath:"selectionBehavior"`

	// A code or group definition that describes the intended subject of the action
	// and its children, if any.
	Subject fhir.Element `fhirpath:"subject"`

	// A text equivalent of the action to be performed. This provides a
	// human-interpretable description of the action when the definition is
	// consumed by a system that might not be capable of interpreting it
	// dynamically.
	TextEquivalent *fhir.String `fhirpath:"textEquivalent"`

	// An optional value describing when the action should be performed.
	Timing fhir.Element `fhirpath:"timing"`

	// The title of the action displayed to a user.
	Title *fhir.String `fhirpath:"title"`

	// A reference to a StructureMap resource that defines a transform that can be
	// executed to produce the intent resource using the ActivityDefinition
	// instance as the input.
	Transform *fhir.Canonical `fhirpath:"transform"`

	// A description of when the action should be triggered.
	Trigger []*fhir.TriggerDefinition `fhirpath:"trigger"`

	// The type of action to perform (create, update, remove).
	Type *fhir.CodeableConcept `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCardinalityBehavior returns the value of the field CardinalityBehavior.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetCardinalityBehavior() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.CardinalityBehavior
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetCode() []*fhir.CodeableConcept {
	if pda == nil {
		return nil
	}
	return pda.Code
}

// GetCondition returns the value of the field Condition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetCondition() []*PlanDefinitionActionCondition {
	if pda == nil {
		return nil
	}
	return pda.Condition
}

// GetDefinition returns the value of the field Definition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetDefinition() fhir.Element {
	if pda == nil {
		return nil
	}
	return pda.Definition
}

// GetDefinitionCanonical returns the value of the field Definition.
func (pda *PlanDefinitionAction) GetDefinitionCanonical() *fhir.Canonical {
	if pda == nil {
		return nil
	}
	val, ok := pda.Definition.(*fhir.Canonical)
	if !ok {
		return nil
	}
	return val
}

// GetDefinitionURI returns the value of the field Definition.
func (pda *PlanDefinitionAction) GetDefinitionURI() *fhir.URI {
	if pda == nil {
		return nil
	}
	val, ok := pda.Definition.(*fhir.URI)
	if !ok {
		return nil
	}
	return val
} // GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetDescription() *fhir.String {
	if pda == nil {
		return nil
	}
	return pda.Description
}

// GetDocumentation returns the value of the field Documentation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetDocumentation() []*fhir.RelatedArtifact {
	if pda == nil {
		return nil
	}
	return pda.Documentation
}

// GetDynamicValue returns the value of the field DynamicValue.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetDynamicValue() []*PlanDefinitionActionDynamicValue {
	if pda == nil {
		return nil
	}
	return pda.DynamicValue
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetExtension() []*fhir.Extension {
	if pda == nil {
		return nil
	}
	return pda.Extension
}

// GetGoalID returns the value of the field GoalID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetGoalID() []*fhir.ID {
	if pda == nil {
		return nil
	}
	return pda.GoalID
}

// GetGroupingBehavior returns the value of the field GroupingBehavior.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetGroupingBehavior() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.GroupingBehavior
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetID() string {
	if pda == nil {
		return ""
	}
	return pda.ID
}

// GetInput returns the value of the field Input.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetInput() []*fhir.DataRequirement {
	if pda == nil {
		return nil
	}
	return pda.Input
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetModifierExtension() []*fhir.Extension {
	if pda == nil {
		return nil
	}
	return pda.ModifierExtension
}

// GetOutput returns the value of the field Output.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetOutput() []*fhir.DataRequirement {
	if pda == nil {
		return nil
	}
	return pda.Output
}

// GetParticipant returns the value of the field Participant.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetParticipant() []*PlanDefinitionActionParticipant {
	if pda == nil {
		return nil
	}
	return pda.Participant
}

// GetPrecheckBehavior returns the value of the field PrecheckBehavior.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetPrecheckBehavior() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.PrecheckBehavior
}

// GetPrefix returns the value of the field Prefix.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetPrefix() *fhir.String {
	if pda == nil {
		return nil
	}
	return pda.Prefix
}

// GetPriority returns the value of the field Priority.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetPriority() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.Priority
}

// GetReason returns the value of the field Reason.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetReason() []*fhir.CodeableConcept {
	if pda == nil {
		return nil
	}
	return pda.Reason
}

// GetRelatedAction returns the value of the field RelatedAction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetRelatedAction() []*PlanDefinitionActionRelatedAction {
	if pda == nil {
		return nil
	}
	return pda.RelatedAction
}

// GetRequiredBehavior returns the value of the field RequiredBehavior.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetRequiredBehavior() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.RequiredBehavior
}

// GetSelectionBehavior returns the value of the field SelectionBehavior.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetSelectionBehavior() *fhir.Code {
	if pda == nil {
		return nil
	}
	return pda.SelectionBehavior
}

// GetSubject returns the value of the field Subject.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetSubject() fhir.Element {
	if pda == nil {
		return nil
	}
	return pda.Subject
}

// GetSubjectCodeableConcept returns the value of the field Subject.
func (pda *PlanDefinitionAction) GetSubjectCodeableConcept() *fhir.CodeableConcept {
	if pda == nil {
		return nil
	}
	val, ok := pda.Subject.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
}

// GetSubjectReference returns the value of the field Subject.
func (pda *PlanDefinitionAction) GetSubjectReference() *fhir.Reference {
	if pda == nil {
		return nil
	}
	val, ok := pda.Subject.(*fhir.Reference)
	if !ok {
		return nil
	}
	return val
} // GetTextEquivalent returns the value of the field TextEquivalent.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetTextEquivalent() *fhir.String {
	if pda == nil {
		return nil
	}
	return pda.TextEquivalent
}

// GetTiming returns the value of the field Timing.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetTiming() fhir.Element {
	if pda == nil {
		return nil
	}
	return pda.Timing
}

// GetTimingDateTime returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingDateTime() *fhir.DateTime {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetTimingAge returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingAge() *fhir.Age {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.Age)
	if !ok {
		return nil
	}
	return val
}

// GetTimingPeriod returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingPeriod() *fhir.Period {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.Period)
	if !ok {
		return nil
	}
	return val
}

// GetTimingDuration returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingDuration() *fhir.Duration {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.Duration)
	if !ok {
		return nil
	}
	return val
}

// GetTimingRange returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingRange() *fhir.Range {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetTimingTiming returns the value of the field Timing.
func (pda *PlanDefinitionAction) GetTimingTiming() *fhir.Timing {
	if pda == nil {
		return nil
	}
	val, ok := pda.Timing.(*fhir.Timing)
	if !ok {
		return nil
	}
	return val
} // GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetTitle() *fhir.String {
	if pda == nil {
		return nil
	}
	return pda.Title
}

// GetTransform returns the value of the field Transform.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetTransform() *fhir.Canonical {
	if pda == nil {
		return nil
	}
	return pda.Transform
}

// GetTrigger returns the value of the field Trigger.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetTrigger() []*fhir.TriggerDefinition {
	if pda == nil {
		return nil
	}
	return pda.Trigger
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pda *PlanDefinitionAction) GetType() *fhir.CodeableConcept {
	if pda == nil {
		return nil
	}
	return pda.Type
}

// Whether or not the action is applicable// An expression that describes applicability criteria or start/stop conditions
// for the action.// When multiple conditions of the same kind are present, the effects are
// combined using AND semantics, so the overall condition is true only if all
// the conditions are true.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionActionCondition struct {

	// An expression that returns true or false, indicating whether the condition
	// is satisfied.
	Expression *fhir.Expression `fhirpath:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The kind of condition.
	Kind *fhir.Code `fhirpath:"kind"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExpression returns the value of the field Expression.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdac *PlanDefinitionActionCondition) GetExpression() *fhir.Expression {
	if pdac == nil {
		return nil
	}
	return pdac.Expression
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdac *PlanDefinitionActionCondition) GetExtension() []*fhir.Extension {
	if pdac == nil {
		return nil
	}
	return pdac.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdac *PlanDefinitionActionCondition) GetID() string {
	if pdac == nil {
		return ""
	}
	return pdac.ID
}

// GetKind returns the value of the field Kind.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdac *PlanDefinitionActionCondition) GetKind() *fhir.Code {
	if pdac == nil {
		return nil
	}
	return pdac.Kind
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdac *PlanDefinitionActionCondition) GetModifierExtension() []*fhir.Extension {
	if pdac == nil {
		return nil
	}
	return pdac.ModifierExtension
}

// Dynamic aspects of the definition// Customizations that should be applied to the statically defined resource.
// For example, if the dosage of a medication must be computed based on the
// patient's weight, a customization would be used to specify an expression
// that calculated the weight, and the path on the resource that would contain
// the result.// Dynamic values are applied in the order in which they are defined in the
// PlanDefinition resource. Note that when dynamic values are also specified by
// a referenced ActivityDefinition, the dynamicValues from the
// ActivityDefinition are applied first, followed by the dynamicValues
// specified here. In addition, if both a transform and dynamic values are
// specific, the dynamic values are applied to the result of the transform.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionActionDynamicValue struct {

	// An expression specifying the value of the customized element.
	Expression *fhir.Expression `fhirpath:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The path to the element to be customized. This is the path on the resource
	// that will hold the result of the calculation defined by the expression. The
	// specified path SHALL be a FHIRPath resolveable on the specified target type
	// of the ActivityDefinition, and SHALL consist only of identifiers, constant
	// indexers, and a restricted subset of functions. The path is allowed to
	// contain qualifiers (.) to traverse sub-elements, as well as indexers ([x])
	// to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath
	// Profile](fhirpath.html#simple) for full details).
	Path *fhir.String `fhirpath:"path"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExpression returns the value of the field Expression.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdadv *PlanDefinitionActionDynamicValue) GetExpression() *fhir.Expression {
	if pdadv == nil {
		return nil
	}
	return pdadv.Expression
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdadv *PlanDefinitionActionDynamicValue) GetExtension() []*fhir.Extension {
	if pdadv == nil {
		return nil
	}
	return pdadv.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdadv *PlanDefinitionActionDynamicValue) GetID() string {
	if pdadv == nil {
		return ""
	}
	return pdadv.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdadv *PlanDefinitionActionDynamicValue) GetModifierExtension() []*fhir.Extension {
	if pdadv == nil {
		return nil
	}
	return pdadv.ModifierExtension
}

// GetPath returns the value of the field Path.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdadv *PlanDefinitionActionDynamicValue) GetPath() *fhir.String {
	if pdadv == nil {
		return nil
	}
	return pdadv.Path
}

// Who should participate in the action// Indicates who should participate in performing the action described.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionActionParticipant struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// The role the participant should play in performing the described action.
	Role *fhir.CodeableConcept `fhirpath:"role"`

	// The type of participant in the action.
	Type *fhir.Code `fhirpath:"type"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdap *PlanDefinitionActionParticipant) GetExtension() []*fhir.Extension {
	if pdap == nil {
		return nil
	}
	return pdap.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdap *PlanDefinitionActionParticipant) GetID() string {
	if pdap == nil {
		return ""
	}
	return pdap.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdap *PlanDefinitionActionParticipant) GetModifierExtension() []*fhir.Extension {
	if pdap == nil {
		return nil
	}
	return pdap.ModifierExtension
}

// GetRole returns the value of the field Role.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdap *PlanDefinitionActionParticipant) GetRole() *fhir.CodeableConcept {
	if pdap == nil {
		return nil
	}
	return pdap.Role
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdap *PlanDefinitionActionParticipant) GetType() *fhir.Code {
	if pdap == nil {
		return nil
	}
	return pdap.Type
}

// Relationship to another action// A relationship to another action such as "before" or "30-60 minutes after
// start of".// When an action depends on multiple actions, the meaning is that all actions
// are dependencies, rather than that any of the actions are a dependency.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionActionRelatedAction struct {

	// The element id of the related action.
	ActionID *fhir.ID `fhirpath:"actionId"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A duration or range of durations to apply to the relationship. For example,
	// 30-60 minutes before.
	Offset fhir.Element `fhirpath:"offset"`

	// The relationship of this action to the related action.
	Relationship *fhir.Code `fhirpath:"relationship"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetActionID returns the value of the field ActionID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetActionID() *fhir.ID {
	if pdara == nil {
		return nil
	}
	return pdara.ActionID
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetExtension() []*fhir.Extension {
	if pdara == nil {
		return nil
	}
	return pdara.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetID() string {
	if pdara == nil {
		return ""
	}
	return pdara.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetModifierExtension() []*fhir.Extension {
	if pdara == nil {
		return nil
	}
	return pdara.ModifierExtension
}

// GetOffset returns the value of the field Offset.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetOffset() fhir.Element {
	if pdara == nil {
		return nil
	}
	return pdara.Offset
}

// GetOffsetDuration returns the value of the field Offset.
func (pdara *PlanDefinitionActionRelatedAction) GetOffsetDuration() *fhir.Duration {
	if pdara == nil {
		return nil
	}
	val, ok := pdara.Offset.(*fhir.Duration)
	if !ok {
		return nil
	}
	return val
}

// GetOffsetRange returns the value of the field Offset.
func (pdara *PlanDefinitionActionRelatedAction) GetOffsetRange() *fhir.Range {
	if pdara == nil {
		return nil
	}
	val, ok := pdara.Offset.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
} // GetRelationship returns the value of the field Relationship.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdara *PlanDefinitionActionRelatedAction) GetRelationship() *fhir.Code {
	if pdara == nil {
		return nil
	}
	return pdara.Relationship
}

// What the plan is trying to accomplish// Goals that describe what the activities within the plan are intended to
// achieve. For example, weight loss, restoring an activity of daily living,
// obtaining herd immunity via immunization, meeting a process improvement
// objective, etc.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionGoal struct {

	// Identifies problems, conditions, issues, or concerns the goal is intended to
	// address.
	Addresses []*fhir.CodeableConcept `fhirpath:"addresses"`

	// Indicates a category the goal falls within.
	Category *fhir.CodeableConcept `fhirpath:"category"`

	// Human-readable and/or coded description of a specific desired objective of
	// care, such as "control blood pressure" or "negotiate an obstacle course" or
	// "dance with child at wedding".
	Description *fhir.CodeableConcept `fhirpath:"description"`

	// Didactic or other informational resources associated with the goal that
	// provide further supporting information about the goal. Information resources
	// can include inline text commentary and links to web resources.
	Documentation []*fhir.RelatedArtifact `fhirpath:"documentation"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Identifies the expected level of importance associated with
	// reaching/sustaining the defined goal.
	Priority *fhir.CodeableConcept `fhirpath:"priority"`

	// The event after which the goal should begin being pursued.
	Start *fhir.CodeableConcept `fhirpath:"start"`

	// Indicates what should be done and within what timeframe.
	Target []*PlanDefinitionGoalTarget `fhirpath:"target"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetAddresses returns the value of the field Addresses.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetAddresses() []*fhir.CodeableConcept {
	if pdg == nil {
		return nil
	}
	return pdg.Addresses
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetCategory() *fhir.CodeableConcept {
	if pdg == nil {
		return nil
	}
	return pdg.Category
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetDescription() *fhir.CodeableConcept {
	if pdg == nil {
		return nil
	}
	return pdg.Description
}

// GetDocumentation returns the value of the field Documentation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetDocumentation() []*fhir.RelatedArtifact {
	if pdg == nil {
		return nil
	}
	return pdg.Documentation
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetExtension() []*fhir.Extension {
	if pdg == nil {
		return nil
	}
	return pdg.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetID() string {
	if pdg == nil {
		return ""
	}
	return pdg.ID
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetModifierExtension() []*fhir.Extension {
	if pdg == nil {
		return nil
	}
	return pdg.ModifierExtension
}

// GetPriority returns the value of the field Priority.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetPriority() *fhir.CodeableConcept {
	if pdg == nil {
		return nil
	}
	return pdg.Priority
}

// GetStart returns the value of the field Start.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetStart() *fhir.CodeableConcept {
	if pdg == nil {
		return nil
	}
	return pdg.Start
}

// GetTarget returns the value of the field Target.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdg *PlanDefinitionGoal) GetTarget() []*PlanDefinitionGoalTarget {
	if pdg == nil {
		return nil
	}
	return pdg.Target
}

// Target outcome for the goal// Indicates what should be done and within what timeframe.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-PlanDefinition.json
type PlanDefinitionGoalTarget struct {

	// The target value of the measure to be achieved to signify fulfillment of the
	// goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the
	// range can be specified. When a low value is missing, it indicates that the
	// goal is achieved at any value at or below the high value. Similarly, if the
	// high value is missing, it indicates that the goal is achieved at any value
	// at or above the low value.
	Detail fhir.Element `fhirpath:"detail"`

	// Indicates the timeframe after the start of the goal in which the goal should
	// be met.
	Due *fhir.Duration `fhirpath:"due"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The parameter whose value is to be tracked, e.g. body weight, blood
	// pressure, or hemoglobin A1c level.
	Measure *fhir.CodeableConcept `fhirpath:"measure"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetDetail returns the value of the field Detail.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetDetail() fhir.Element {
	if pdgt == nil {
		return nil
	}
	return pdgt.Detail
}

// GetDetailQuantity returns the value of the field Detail.
func (pdgt *PlanDefinitionGoalTarget) GetDetailQuantity() *fhir.Quantity {
	if pdgt == nil {
		return nil
	}
	val, ok := pdgt.Detail.(*fhir.Quantity)
	if !ok {
		return nil
	}
	return val
}

// GetDetailRange returns the value of the field Detail.
func (pdgt *PlanDefinitionGoalTarget) GetDetailRange() *fhir.Range {
	if pdgt == nil {
		return nil
	}
	val, ok := pdgt.Detail.(*fhir.Range)
	if !ok {
		return nil
	}
	return val
}

// GetDetailCodeableConcept returns the value of the field Detail.
func (pdgt *PlanDefinitionGoalTarget) GetDetailCodeableConcept() *fhir.CodeableConcept {
	if pdgt == nil {
		return nil
	}
	val, ok := pdgt.Detail.(*fhir.CodeableConcept)
	if !ok {
		return nil
	}
	return val
} // GetDue returns the value of the field Due.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetDue() *fhir.Duration {
	if pdgt == nil {
		return nil
	}
	return pdgt.Due
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetExtension() []*fhir.Extension {
	if pdgt == nil {
		return nil
	}
	return pdgt.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetID() string {
	if pdgt == nil {
		return ""
	}
	return pdgt.ID
}

// GetMeasure returns the value of the field Measure.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetMeasure() *fhir.CodeableConcept {
	if pdgt == nil {
		return nil
	}
	return pdgt.Measure
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (pdgt *PlanDefinitionGoalTarget) GetModifierExtension() []*fhir.Extension {
	if pdgt == nil {
		return nil
	}
	return pdgt.ModifierExtension
}
