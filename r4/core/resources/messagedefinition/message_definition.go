// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package messagedefinition

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Defines the characteristics of a message that can be shared between systems,
// including the type of event that initiates the message, the content to be
// transmitted and what response(s), if any, are permitted.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/MessageDefinition
//   - Source File: StructureDefinition-MessageDefinition.json
type MessageDefinition struct {

	// Indicates what types of messages may be sent as an application-level
	// response to this message.
	AllowedResponse []*MessageDefinitionAllowedResponse `fhirpath:"allowedResponse"`

	// The MessageDefinition that is the basis for the contents of this resource.
	Base *fhir.Canonical `fhirpath:"base"`

	// The impact of the content of the message.
	Category *fhir.Code `fhirpath:"category"`

	// Contact details to assist a user in finding and communicating with the
	// publisher.
	Contact []*fhir.ContactDetail `fhirpath:"contact"`

	// These resources do not have an independent existence apart from the resource
	// that contains them - they cannot be identified independently, and nor can
	// they have their own independent transaction scope.
	Contained []fhir.Resource `fhirpath:"contained"`

	// A copyright statement relating to the message definition and/or its
	// contents. Copyright statements are generally legal restrictions on the use
	// and publishing of the message definition.
	Copyright *fhir.Markdown `fhirpath:"copyright"`

	// The date (and optionally time) when the message definition was published.
	// The date must change when the business version changes and it must change if
	// the status code changes. In addition, it should change when the substantive
	// content of the message definition changes.
	Date *fhir.DateTime `fhirpath:"date"`

	// A free text natural language description of the message definition from a
	// consumer's perspective.
	Description *fhir.Markdown `fhirpath:"description"`

	// Event code or link to the EventDefinition.
	Event fhir.Element `fhirpath:"event"`

	// A Boolean value to indicate that this message definition is authored for
	// testing purposes (or education/evaluation/marketing) and is not intended to
	// be used for genuine usage.
	Experimental *fhir.Boolean `fhirpath:"experimental"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Identifies the resource (or resources) that are being addressed by the
	// event. For example, the Encounter for an admit message or two Account
	// records for a merge.
	Focus []*MessageDefinitionFocus `fhirpath:"focus"`

	// Canonical reference to a GraphDefinition. If a URL is provided, it is the
	// canonical reference to a [GraphDefinition](graphdefinition.html) that it
	// controls what resources are to be added to the bundle when building the
	// document. The GraphDefinition can also specify profiles that apply to the
	// various resources.
	Graph []*fhir.Canonical `fhirpath:"graph"`

	// The logical id of the resource, as used in the URL for the resource. Once
	// assigned, this value never changes.
	ID string `fhirpath:"id"`

	// A formal identifier that is used to identify this message definition when it
	// is represented in other formats, or referenced in a specification, model,
	// design or an instance.
	Identifier []*fhir.Identifier `fhirpath:"identifier"`

	// A reference to a set of rules that were followed when the resource was
	// constructed, and which must be understood when processing the content.
	// Often, this is a reference to an implementation guide that defines the
	// special rules along with other profiles etc.
	ImplicitRules *fhir.URI `fhirpath:"implicitRules"`

	// A legal or geographic region in which the message definition is intended to
	// be used.
	Jurisdiction []*fhir.CodeableConcept `fhirpath:"jurisdiction"`

	// The base language in which the resource is written.
	Language *fhir.Code `fhirpath:"language"`

	// The metadata about the resource. This is content that is maintained by the
	// infrastructure. Changes to the content might not always be associated with
	// version changes to the resource.
	Meta *fhir.Meta `fhirpath:"meta"`

	// May be used to represent additional information that is not part of the
	// basic definition of the resource and that modifies the understanding of the
	// element that contains it and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer is allowed to define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A natural language name identifying the message definition. This name should
	// be usable as an identifier for the module by machine processing applications
	// such as code generation.
	Name *fhir.String `fhirpath:"name"`

	// Identifies a protocol or workflow that this MessageDefinition represents a
	// step in.
	Parent []*fhir.Canonical `fhirpath:"parent"`

	// The name of the organization or individual that published the message
	// definition.
	Publisher *fhir.String `fhirpath:"publisher"`

	// Explanation of why this message definition is needed and why it has been
	// designed as it has.
	Purpose *fhir.Markdown `fhirpath:"purpose"`

	// A MessageDefinition that is superseded by this definition.
	Replaces []*fhir.Canonical `fhirpath:"replaces"`

	// Declare at a message definition level whether a response is required or only
	// upon error or success, or never.
	ResponseRequired *fhir.Code `fhirpath:"responseRequired"`

	// The status of this message definition. Enables tracking the life-cycle of
	// the content.
	Status *fhir.Code `fhirpath:"status"`

	// A human-readable narrative that contains a summary of the resource and can
	// be used to represent the content of the resource to a human. The narrative
	// need not encode all the structured data, but is required to contain
	// sufficient detail to make it "clinically safe" for a human to just read the
	// narrative. Resource definitions may define what content should be
	// represented in the narrative to ensure clinical safety.
	Text *fhir.Narrative `fhirpath:"text"`

	// A short, descriptive, user-friendly title for the message definition.
	Title *fhir.String `fhirpath:"title"`

	// The business identifier that is used to reference the MessageDefinition and
	// *is* expected to be consistent from server to server.
	URL *fhir.URI `fhirpath:"url"`

	// The content was developed with a focus and intent of supporting the contexts
	// that are listed. These contexts may be general categories (gender, age, ...)
	// or may be references to specific programs (insurance plans, studies, ...)
	// and may be used to assist with indexing and searching for appropriate
	// message definition instances.
	UseContext []*fhir.UsageContext `fhirpath:"useContext"`

	// The identifier that is used to identify this version of the message
	// definition when it is referenced in a specification, model, design or
	// instance. This is an arbitrary value managed by the message definition
	// author and is not expected to be globally unique. For example, it might be a
	// timestamp (e.g. yyyymmdd) if a managed version is not available. There is
	// also no expectation that versions can be placed in a lexicographical
	// sequence.
	Version *fhir.String `fhirpath:"version"`

	profileimpl.BaseDomainResource
	profileimpl.BaseResource
}

// GetAllowedResponse returns the value of the field AllowedResponse.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetAllowedResponse() []*MessageDefinitionAllowedResponse {
	if md == nil {
		return nil
	}
	return md.AllowedResponse
}

// GetBase returns the value of the field Base.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetBase() *fhir.Canonical {
	if md == nil {
		return nil
	}
	return md.Base
}

// GetCategory returns the value of the field Category.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetCategory() *fhir.Code {
	if md == nil {
		return nil
	}
	return md.Category
}

// GetContact returns the value of the field Contact.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetContact() []*fhir.ContactDetail {
	if md == nil {
		return nil
	}
	return md.Contact
}

// GetContained returns the value of the field Contained.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetContained() []fhir.Resource {
	if md == nil {
		return nil
	}
	return md.Contained
}

// GetCopyright returns the value of the field Copyright.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetCopyright() *fhir.Markdown {
	if md == nil {
		return nil
	}
	return md.Copyright
}

// GetDate returns the value of the field Date.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetDate() *fhir.DateTime {
	if md == nil {
		return nil
	}
	return md.Date
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetDescription() *fhir.Markdown {
	if md == nil {
		return nil
	}
	return md.Description
}

// GetEvent returns the value of the field Event.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetEvent() fhir.Element {
	if md == nil {
		return nil
	}
	return md.Event
}

// GetEventCoding returns the value of the field Event.
func (md *MessageDefinition) GetEventCoding() *fhir.Coding {
	if md == nil {
		return nil
	}
	val, ok := md.Event.(*fhir.Coding)
	if !ok {
		return nil
	}
	return val
}

// GetEventURI returns the value of the field Event.
func (md *MessageDefinition) GetEventURI() *fhir.URI {
	if md == nil {
		return nil
	}
	val, ok := md.Event.(*fhir.URI)
	if !ok {
		return nil
	}
	return val
} // GetExperimental returns the value of the field Experimental.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetExperimental() *fhir.Boolean {
	if md == nil {
		return nil
	}
	return md.Experimental
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetExtension() []*fhir.Extension {
	if md == nil {
		return nil
	}
	return md.Extension
}

// GetFocus returns the value of the field Focus.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetFocus() []*MessageDefinitionFocus {
	if md == nil {
		return nil
	}
	return md.Focus
}

// GetGraph returns the value of the field Graph.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetGraph() []*fhir.Canonical {
	if md == nil {
		return nil
	}
	return md.Graph
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetID() string {
	if md == nil {
		return ""
	}
	return md.ID
}

// GetIdentifier returns the value of the field Identifier.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetIdentifier() []*fhir.Identifier {
	if md == nil {
		return nil
	}
	return md.Identifier
}

// GetImplicitRules returns the value of the field ImplicitRules.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetImplicitRules() *fhir.URI {
	if md == nil {
		return nil
	}
	return md.ImplicitRules
}

// GetJurisdiction returns the value of the field Jurisdiction.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetJurisdiction() []*fhir.CodeableConcept {
	if md == nil {
		return nil
	}
	return md.Jurisdiction
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetLanguage() *fhir.Code {
	if md == nil {
		return nil
	}
	return md.Language
}

// GetMeta returns the value of the field Meta.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetMeta() *fhir.Meta {
	if md == nil {
		return nil
	}
	return md.Meta
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetModifierExtension() []*fhir.Extension {
	if md == nil {
		return nil
	}
	return md.ModifierExtension
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetName() *fhir.String {
	if md == nil {
		return nil
	}
	return md.Name
}

// GetParent returns the value of the field Parent.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetParent() []*fhir.Canonical {
	if md == nil {
		return nil
	}
	return md.Parent
}

// GetPublisher returns the value of the field Publisher.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetPublisher() *fhir.String {
	if md == nil {
		return nil
	}
	return md.Publisher
}

// GetPurpose returns the value of the field Purpose.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetPurpose() *fhir.Markdown {
	if md == nil {
		return nil
	}
	return md.Purpose
}

// GetReplaces returns the value of the field Replaces.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetReplaces() []*fhir.Canonical {
	if md == nil {
		return nil
	}
	return md.Replaces
}

// GetResponseRequired returns the value of the field ResponseRequired.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetResponseRequired() *fhir.Code {
	if md == nil {
		return nil
	}
	return md.ResponseRequired
}

// GetStatus returns the value of the field Status.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetStatus() *fhir.Code {
	if md == nil {
		return nil
	}
	return md.Status
}

// GetText returns the value of the field Text.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetText() *fhir.Narrative {
	if md == nil {
		return nil
	}
	return md.Text
}

// GetTitle returns the value of the field Title.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetTitle() *fhir.String {
	if md == nil {
		return nil
	}
	return md.Title
}

// GetURL returns the value of the field URL.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetURL() *fhir.URI {
	if md == nil {
		return nil
	}
	return md.URL
}

// GetUseContext returns the value of the field UseContext.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetUseContext() []*fhir.UsageContext {
	if md == nil {
		return nil
	}
	return md.UseContext
}

// GetVersion returns the value of the field Version.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (md *MessageDefinition) GetVersion() *fhir.String {
	if md == nil {
		return nil
	}
	return md.Version
}

// Responses to this message// Indicates what types of messages may be sent as an application-level
// response to this message.// This indicates an application level response to "close" a transaction
// implicit in a particular request message. To define a complete workflow
// scenario, look to the [[PlanDefinition]] resource which allows the
// definition of complex orchestrations, conditionality, etc.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-MessageDefinition.json
type MessageDefinitionAllowedResponse struct {

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// A reference to the message definition that must be adhered to by this
	// supported response.
	Message *fhir.Canonical `fhirpath:"message"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// Provides a description of the circumstances in which this response should be
	// used (as opposed to one of the alternative responses).
	Situation *fhir.Markdown `fhirpath:"situation"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdar *MessageDefinitionAllowedResponse) GetExtension() []*fhir.Extension {
	if mdar == nil {
		return nil
	}
	return mdar.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdar *MessageDefinitionAllowedResponse) GetID() string {
	if mdar == nil {
		return ""
	}
	return mdar.ID
}

// GetMessage returns the value of the field Message.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdar *MessageDefinitionAllowedResponse) GetMessage() *fhir.Canonical {
	if mdar == nil {
		return nil
	}
	return mdar.Message
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdar *MessageDefinitionAllowedResponse) GetModifierExtension() []*fhir.Extension {
	if mdar == nil {
		return nil
	}
	return mdar.ModifierExtension
}

// GetSituation returns the value of the field Situation.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdar *MessageDefinitionAllowedResponse) GetSituation() *fhir.Markdown {
	if mdar == nil {
		return nil
	}
	return mdar.Situation
}

// Resource(s) that are the subject of the event// Identifies the resource (or resources) that are being addressed by the
// event. For example, the Encounter for an admit message or two Account
// records for a merge.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition:
//   - Source File: StructureDefinition-MessageDefinition.json
type MessageDefinitionFocus struct {

	// The kind of resource that must be the focus for this message.
	Code *fhir.Code `fhirpath:"code"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*fhir.Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Identifies the maximum number of resources of this type that must be pointed
	// to by a message in order for it to be valid against this MessageDefinition.
	Max *fhir.String `fhirpath:"max"`

	// Identifies the minimum number of resources of this type that must be pointed
	// to by a message in order for it to be valid against this MessageDefinition.
	Min *fhir.UnsignedInt `fhirpath:"min"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element and that modifies the understanding of the
	// element in which it is contained and/or the understanding of the containing
	// element's descendants. Usually modifier elements provide negation or
	// qualification. To make the use of extensions safe and manageable, there is a
	// strict set of governance applied to the definition and use of extensions.
	// Though any implementer can define an extension, there is a set of
	// requirements that SHALL be met as part of the definition of the extension.
	// Applications processing a resource are required to check for modifier
	// extensions.
	// Modifier extensions SHALL NOT change the meaning of any elements on Resource
	// or DomainResource (including cannot change the meaning of modifierExtension
	// itself).
	ModifierExtension []*fhir.Extension `fhirpath:"modifierExtension"`

	// A profile that reflects constraints for the focal resource (and potentially
	// for related resources).
	Profile *fhir.Canonical `fhirpath:"profile"`

	profileimpl.BaseBackboneElement
	profileimpl.BaseElement
}

// GetCode returns the value of the field Code.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetCode() *fhir.Code {
	if mdf == nil {
		return nil
	}
	return mdf.Code
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetExtension() []*fhir.Extension {
	if mdf == nil {
		return nil
	}
	return mdf.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetID() string {
	if mdf == nil {
		return ""
	}
	return mdf.ID
}

// GetMax returns the value of the field Max.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetMax() *fhir.String {
	if mdf == nil {
		return nil
	}
	return mdf.Max
}

// GetMin returns the value of the field Min.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetMin() *fhir.UnsignedInt {
	if mdf == nil {
		return nil
	}
	return mdf.Min
}

// GetModifierExtension returns the value of the field ModifierExtension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetModifierExtension() []*fhir.Extension {
	if mdf == nil {
		return nil
	}
	return mdf.ModifierExtension
}

// GetProfile returns the value of the field Profile.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (mdf *MessageDefinitionFocus) GetProfile() *fhir.Canonical {
	if mdf == nil {
		return nil
	}
	return mdf.Profile
}

func (md *MessageDefinition) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (md *MessageDefinition) UnmarshalJSON(data []byte) error {
	var raw struct {
		AllowedResponse []*MessageDefinitionAllowedResponse `json:"allowedResponse"`
		Base            *fhir.Canonical                     `json:"base"`
		Category        *fhir.Code                          `json:"category"`
		Contact         []*fhir.ContactDetail               `json:"contact"`
		Contained       []fhir.Resource                     `json:"contained"`
		Copyright       *fhir.Markdown                      `json:"copyright"`
		Date            *fhir.DateTime                      `json:"date"`
		Description     *fhir.Markdown                      `json:"description"`
		EventCoding     *fhir.Coding                        `json:"eventCoding"`
		EventURI        *fhir.URI                           `json:"eventURI"`
		Experimental    *fhir.Boolean                       `json:"experimental"`
		Extension       []*fhir.Extension                   `json:"extension"`
		Focus           []*MessageDefinitionFocus           `json:"focus"`
		Graph           []*fhir.Canonical                   `json:"graph"`

		ID                string                  `json:"id"`
		Identifier        []*fhir.Identifier      `json:"identifier"`
		ImplicitRules     *fhir.URI               `json:"implicitRules"`
		Jurisdiction      []*fhir.CodeableConcept `json:"jurisdiction"`
		Language          *fhir.Code              `json:"language"`
		Meta              *fhir.Meta              `json:"meta"`
		ModifierExtension []*fhir.Extension       `json:"modifierExtension"`
		Name              *fhir.String            `json:"name"`
		Parent            []*fhir.Canonical       `json:"parent"`
		Publisher         *fhir.String            `json:"publisher"`
		Purpose           *fhir.Markdown          `json:"purpose"`
		Replaces          []*fhir.Canonical       `json:"replaces"`
		ResponseRequired  *fhir.Code              `json:"responseRequired"`
		Status            *fhir.Code              `json:"status"`
		Text              *fhir.Narrative         `json:"text"`
		Title             *fhir.String            `json:"title"`
		URL               *fhir.URI               `json:"url"`
		UseContext        []*fhir.UsageContext    `json:"useContext"`
		Version           *fhir.String            `json:"version"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	md.AllowedResponse = raw.AllowedResponse
	md.Base = raw.Base
	md.Category = raw.Category
	md.Contact = raw.Contact
	md.Contained = raw.Contained
	md.Copyright = raw.Copyright
	md.Date = raw.Date
	md.Description = raw.Description
	md.Event, err = validate.SelectOneOf[fhir.Element]("MessageDefinition.event",
		raw.EventCoding,
		raw.EventURI)
	if err != nil {
		return err
	}
	md.Experimental = raw.Experimental
	md.Extension = raw.Extension
	md.Focus = raw.Focus
	md.Graph = raw.Graph
	md.ID = raw.ID
	md.Identifier = raw.Identifier
	md.ImplicitRules = raw.ImplicitRules
	md.Jurisdiction = raw.Jurisdiction
	md.Language = raw.Language
	md.Meta = raw.Meta
	md.ModifierExtension = raw.ModifierExtension
	md.Name = raw.Name
	md.Parent = raw.Parent
	md.Publisher = raw.Publisher
	md.Purpose = raw.Purpose
	md.Replaces = raw.Replaces
	md.ResponseRequired = raw.ResponseRequired
	md.Status = raw.Status
	md.Text = raw.Text
	md.Title = raw.Title
	md.URL = raw.URL
	md.UseContext = raw.UseContext
	md.Version = raw.Version
	return nil
}

var _ json.Marshaler = (*MessageDefinition)(nil)
var _ json.Unmarshaler = (*MessageDefinition)(nil)

func (mdar *MessageDefinitionAllowedResponse) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (mdar *MessageDefinitionAllowedResponse) UnmarshalJSON(data []byte) error {
	var raw struct {
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		Message           *fhir.Canonical   `json:"message"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Situation         *fhir.Markdown    `json:"situation"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	mdar.Extension = raw.Extension
	mdar.ID = raw.ID
	mdar.Message = raw.Message
	mdar.ModifierExtension = raw.ModifierExtension
	mdar.Situation = raw.Situation
	return nil
}

var _ json.Marshaler = (*MessageDefinitionAllowedResponse)(nil)
var _ json.Unmarshaler = (*MessageDefinitionAllowedResponse)(nil)

func (mdf *MessageDefinitionFocus) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (mdf *MessageDefinitionFocus) UnmarshalJSON(data []byte) error {
	var raw struct {
		Code      *fhir.Code        `json:"code"`
		Extension []*fhir.Extension `json:"extension"`

		ID                string            `json:"id"`
		Max               *fhir.String      `json:"max"`
		Min               *fhir.UnsignedInt `json:"min"`
		ModifierExtension []*fhir.Extension `json:"modifierExtension"`
		Profile           *fhir.Canonical   `json:"profile"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	mdf.Code = raw.Code
	mdf.Extension = raw.Extension
	mdf.ID = raw.ID
	mdf.Max = raw.Max
	mdf.Min = raw.Min
	mdf.ModifierExtension = raw.ModifierExtension
	mdf.Profile = raw.Profile
	return nil
}

var _ json.Marshaler = (*MessageDefinitionFocus)(nil)
var _ json.Unmarshaler = (*MessageDefinitionFocus)(nil)
