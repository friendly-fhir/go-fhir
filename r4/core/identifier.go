// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Base StructureDefinition for Identifier Type: An identifier - identifies
// some entity uniquely and unambiguously. Typically this is used for business
// identifiers.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Identifier
//   - Source File: StructureDefinition-Identifier.json
type Identifier struct {

	// Organization that issued/manages the identifier.
	Assigner *Reference `fhirpath:"assigner"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// Time period during which identifier is/was valid for use.
	Period *Period `fhirpath:"period"`

	// Establishes the namespace for the value - that is, a URL that describes a
	// set values that are unique.
	System *URI `fhirpath:"system"`

	// A coded type for the identifier that can be used to determine which
	// identifier to use for a specific purpose.
	Type *CodeableConcept `fhirpath:"type"`

	// The purpose of this identifier.
	Use *Code `fhirpath:"use"`

	// The portion of the identifier typically relevant to the user and which is
	// unique within the context of the system.
	Value *String `fhirpath:"value"`

	profileimpl.BaseElement
}

// GetAssigner returns the value of the field Assigner.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetAssigner() *Reference {
	if i == nil {
		return nil
	}
	return i.Assigner
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetExtension() []*Extension {
	if i == nil {
		return nil
	}
	return i.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetID() string {
	if i == nil {
		return ""
	}
	return i.ID
}

// GetPeriod returns the value of the field Period.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetPeriod() *Period {
	if i == nil {
		return nil
	}
	return i.Period
}

// GetSystem returns the value of the field System.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetSystem() *URI {
	if i == nil {
		return nil
	}
	return i.System
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetType() *CodeableConcept {
	if i == nil {
		return nil
	}
	return i.Type
}

// GetUse returns the value of the field Use.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetUse() *Code {
	if i == nil {
		return nil
	}
	return i.Use
}

// GetValue returns the value of the field Value.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (i *Identifier) GetValue() *String {
	if i == nil {
		return nil
	}
	return i.Value
}

func (i *Identifier) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (i *Identifier) UnmarshalJSON(data []byte) error {
	var raw struct {
		Assigner  *Reference   `json:"assigner"`
		Extension []*Extension `json:"extension"`

		ID     string           `json:"id"`
		Period *Period          `json:"period"`
		System *URI             `json:"system"`
		Type   *CodeableConcept `json:"type"`
		Use    *Code            `json:"use"`
		Value  *String          `json:"value"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	i.Assigner = raw.Assigner
	i.Extension = raw.Extension
	i.ID = raw.ID
	i.Period = raw.Period
	i.System = raw.System
	i.Type = raw.Type
	i.Use = raw.Use
	i.Value = raw.Value
	return nil
}

var _ json.Marshaler = (*Identifier)(nil)
var _ json.Unmarshaler = (*Identifier)(nil)
