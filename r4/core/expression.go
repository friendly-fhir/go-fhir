// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Base StructureDefinition for Expression Type: A expression that is evaluated
// in a specified context and returns a value. The context of use of the
// expression must specify the context in which the expression is evaluated,
// and how the result of the expression is used.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/Expression
//   - Source File: StructureDefinition-Expression.json
type Expression struct {

	// A brief, natural language description of the condition that effectively
	// communicates the intended semantics.
	Description *String `fhirpath:"description"`

	// An expression in the specified language that returns a value.
	Expression *String `fhirpath:"expression"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The media type of the language for the expression.
	Language *Code `fhirpath:"language"`

	// A short name assigned to the expression to allow for multiple reuse of the
	// expression in the context where it is defined.
	Name *ID `fhirpath:"name"`

	// A URI that defines where the expression is found.
	Reference *URI `fhirpath:"reference"`

	profileimpl.BaseElement
}

// GetDescription returns the value of the field Description.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetDescription() *String {
	if e == nil {
		return nil
	}
	return e.Description
}

// GetExpression returns the value of the field Expression.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetExpression() *String {
	if e == nil {
		return nil
	}
	return e.Expression
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetExtension() []*Extension {
	if e == nil {
		return nil
	}
	return e.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetID() string {
	if e == nil {
		return ""
	}
	return e.ID
}

// GetLanguage returns the value of the field Language.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetLanguage() *Code {
	if e == nil {
		return nil
	}
	return e.Language
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetName() *ID {
	if e == nil {
		return nil
	}
	return e.Name
}

// GetReference returns the value of the field Reference.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (e *Expression) GetReference() *URI {
	if e == nil {
		return nil
	}
	return e.Reference
}

func (e *Expression) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (e *Expression) UnmarshalJSON(data []byte) error {
	var raw struct {
		Description *String      `json:"description"`
		Expression  *String      `json:"expression"`
		Extension   []*Extension `json:"extension"`

		ID        string `json:"id"`
		Language  *Code  `json:"language"`
		Name      *ID    `json:"name"`
		Reference *URI   `json:"reference"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	e.Description = raw.Description
	e.Expression = raw.Expression
	e.Extension = raw.Extension
	e.ID = raw.ID
	e.Language = raw.Language
	e.Name = raw.Name
	e.Reference = raw.Reference
	return nil
}

var _ json.Marshaler = (*Expression)(nil)
var _ json.Unmarshaler = (*Expression)(nil)
