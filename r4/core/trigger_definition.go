// GENERATE CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/internal/validate"
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Base StructureDefinition for TriggerDefinition Type: A description of a
// triggering event. Triggering events can be named events, data events, or
// periodic, as determined by the type element.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/TriggerDefinition
//   - Source File: StructureDefinition-TriggerDefinition.json
type TriggerDefinition struct {

	// A boolean-valued expression that is evaluated in the context of the
	// container of the trigger definition and returns whether or not the trigger
	// fires.
	Condition *Expression `fhirpath:"condition"`

	// The triggering data of the event (if this is a data trigger). If more than
	// one data is requirement is specified, then all the data requirements must be
	// true.
	Data []*DataRequirement `fhirpath:"data"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// A formal name for the event. This may be an absolute URI that identifies the
	// event formally (e.g. from a trigger registry), or a simple relative URI that
	// identifies the event in a local context.
	Name *String `fhirpath:"name"`

	// The timing of the event (if this is a periodic trigger).
	Timing Element `fhirpath:"timing"`

	// The type of triggering event.
	Type *Code `fhirpath:"type"`

	profileimpl.BaseElement
}

// GetCondition returns the value of the field Condition.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetCondition() *Expression {
	if td == nil {
		return nil
	}
	return td.Condition
}

// GetData returns the value of the field Data.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetData() []*DataRequirement {
	if td == nil {
		return nil
	}
	return td.Data
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetExtension() []*Extension {
	if td == nil {
		return nil
	}
	return td.Extension
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetID() string {
	if td == nil {
		return ""
	}
	return td.ID
}

// GetName returns the value of the field Name.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetName() *String {
	if td == nil {
		return nil
	}
	return td.Name
}

// GetTiming returns the value of the field Timing.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetTiming() Element {
	if td == nil {
		return nil
	}
	return td.Timing
}

// GetTimingTiming returns the value of the field Timing.
func (td *TriggerDefinition) GetTimingTiming() *Timing {
	if td == nil {
		return nil
	}
	val, ok := td.Timing.(*Timing)
	if !ok {
		return nil
	}
	return val
}

// GetTimingReference returns the value of the field Timing.
func (td *TriggerDefinition) GetTimingReference() *Reference {
	if td == nil {
		return nil
	}
	val, ok := td.Timing.(*Reference)
	if !ok {
		return nil
	}
	return val
}

// GetTimingDate returns the value of the field Timing.
func (td *TriggerDefinition) GetTimingDate() *Date {
	if td == nil {
		return nil
	}
	val, ok := td.Timing.(*Date)
	if !ok {
		return nil
	}
	return val
}

// GetTimingDateTime returns the value of the field Timing.
func (td *TriggerDefinition) GetTimingDateTime() *DateTime {
	if td == nil {
		return nil
	}
	val, ok := td.Timing.(*DateTime)
	if !ok {
		return nil
	}
	return val
}

// GetType returns the value of the field Type.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (td *TriggerDefinition) GetType() *Code {
	if td == nil {
		return nil
	}
	return td.Type
}

func (td *TriggerDefinition) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (td *TriggerDefinition) UnmarshalJSON(data []byte) error {
	var raw struct {
		Condition *Expression        `json:"condition"`
		Data      []*DataRequirement `json:"data"`
		Extension []*Extension       `json:"extension"`

		ID              string     `json:"id"`
		Name            *String    `json:"name"`
		TimingTiming    *Timing    `json:"timingTiming"`
		TimingReference *Reference `json:"timingReference"`
		TimingDate      *Date      `json:"timingDate"`
		TimingDateTime  *DateTime  `json:"timingDateTime"`
		Type            *Code      `json:"type"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	td.Condition = raw.Condition
	td.Data = raw.Data
	td.Extension = raw.Extension
	td.ID = raw.ID
	td.Name = raw.Name
	td.Timing, err = validate.SelectOneOf[Element]("TriggerDefinition.timing",
		raw.TimingTiming,
		raw.TimingReference,
		raw.TimingDate,
		raw.TimingDateTime)
	if err != nil {
		return err
	}
	td.Type = raw.Type
	return nil
}

var _ json.Marshaler = (*TriggerDefinition)(nil)
var _ json.Unmarshaler = (*TriggerDefinition)(nil)
