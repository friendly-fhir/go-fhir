// GENERATED CODE - DO NOT EDIT
//
// This file is generated by the FHIR Fhenix code generator tool, which can be
// located at https://github.com/friendly-fhir/fhenix.

package fhir

import (
	"github.com/friendly-fhir/go-fhir/r4/core/internal/profileimpl"

	"encoding/json"
)

// Base StructureDefinition for SampledData Type: A series of measurements
// taken by a device, with upper and lower limits. There may be more than one
// dimension in the data.
//
// Meta Details:
//
//   - Package IG: hl7.fhir.r4.core@4.0.1
//   - StructureDefinition: http://hl7.org/fhir/StructureDefinition/SampledData
//   - Source File: StructureDefinition-SampledData.json
type SampledData struct {

	// A series of data points which are decimal values separated by a single space
	// (character u20). The special values "E" (error), "L" (below detection limit)
	// and "U" (above detection limit) can also be used in place of a decimal
	// value.
	Data *String `fhirpath:"data"`

	// The number of sample points at each time point. If this value is greater
	// than one, then the dimensions will be interlaced - all the sample points for
	// a point in time will be recorded at once.
	Dimensions *PositiveInt `fhirpath:"dimensions"`

	// May be used to represent additional information that is not part of the
	// basic definition of the element. To make the use of extensions safe and
	// manageable, there is a strict set of governance applied to the definition
	// and use of extensions. Though any implementer can define an extension, there
	// is a set of requirements that SHALL be met as part of the definition of the
	// extension.
	Extension []*Extension `fhirpath:"extension"`

	// A correction factor that is applied to the sampled data points before they
	// are added to the origin.
	Factor *Decimal `fhirpath:"factor"`

	// Unique id for the element within a resource (for internal references). This
	// may be any string value that does not contain spaces.
	ID string `fhirpath:"id"`

	// The lower limit of detection of the measured points. This is needed if any
	// of the data points have the value "L" (lower than detection limit).
	LowerLimit *Decimal `fhirpath:"lowerLimit"`

	// The base quantity that a measured value of zero represents. In addition,
	// this provides the units of the entire measurement series.
	Origin *Quantity `fhirpath:"origin"`

	// The length of time between sampling times, measured in milliseconds.
	Period *Decimal `fhirpath:"period"`

	// The upper limit of detection of the measured points. This is needed if any
	// of the data points have the value "U" (higher than detection limit).
	UpperLimit *Decimal `fhirpath:"upperLimit"`

	profileimpl.BaseElement
}

// GetData returns the value of the field Data.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetData() *String {
	if sd == nil {
		return nil
	}
	return sd.Data
}

// GetDimensions returns the value of the field Dimensions.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetDimensions() *PositiveInt {
	if sd == nil {
		return nil
	}
	return sd.Dimensions
}

// GetExtension returns the value of the field Extension.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetExtension() []*Extension {
	if sd == nil {
		return nil
	}
	return sd.Extension
}

// GetFactor returns the value of the field Factor.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetFactor() *Decimal {
	if sd == nil {
		return nil
	}
	return sd.Factor
}

// GetID returns the value of the field ID.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetID() string {
	if sd == nil {
		return ""
	}
	return sd.ID
}

// GetLowerLimit returns the value of the field LowerLimit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetLowerLimit() *Decimal {
	if sd == nil {
		return nil
	}
	return sd.LowerLimit
}

// GetOrigin returns the value of the field Origin.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetOrigin() *Quantity {
	if sd == nil {
		return nil
	}
	return sd.Origin
}

// GetPeriod returns the value of the field Period.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetPeriod() *Decimal {
	if sd == nil {
		return nil
	}
	return sd.Period
}

// GetUpperLimit returns the value of the field UpperLimit.
// This function is safe to call on nil pointers, and will return the zero value
// instead.
func (sd *SampledData) GetUpperLimit() *Decimal {
	if sd == nil {
		return nil
	}
	return sd.UpperLimit
}

func (sd *SampledData) MarshalJSON() ([]byte, error) {
	return nil, nil
}

func (sd *SampledData) UnmarshalJSON(data []byte) error {
	var raw struct {
		Data       *String      `json:"data"`
		Dimensions *PositiveInt `json:"dimensions"`
		Extension  []*Extension `json:"extension"`
		Factor     *Decimal     `json:"factor"`

		ID         string    `json:"id"`
		LowerLimit *Decimal  `json:"lowerLimit"`
		Origin     *Quantity `json:"origin"`
		Period     *Decimal  `json:"period"`
		UpperLimit *Decimal  `json:"upperLimit"`
	}

	var err error
	if err = json.Unmarshal(data, &raw); err != nil {
		return err
	}

	sd.Data = raw.Data
	sd.Dimensions = raw.Dimensions
	sd.Extension = raw.Extension
	sd.Factor = raw.Factor
	sd.ID = raw.ID
	sd.LowerLimit = raw.LowerLimit
	sd.Origin = raw.Origin
	sd.Period = raw.Period
	sd.UpperLimit = raw.UpperLimit
	return nil
}

var _ json.Marshaler = (*SampledData)(nil)
var _ json.Unmarshaler = (*SampledData)(nil)
